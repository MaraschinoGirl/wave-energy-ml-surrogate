<html>
<head>
<title>2955.47d81759e4605daaff24.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
2955.47d81759e4605daaff24.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;2955.47d81759e4605daaff24.js?v=47d81759e4605daaff24&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA,0EAA0E,GAAG;;AAE7E;AACA,gBAAgB,QAAQ;;AAExB;AACA,gBAAgB,SAAS;;AAEzB;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtHqS;AAC7P;AACW;;AAEnD;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,sCAAsC,aAAa;AACnD,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wBAAwB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,wBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,MAAM;AACN;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,WAAW,yGAAyG;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,0BAA0B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA,2BAA2B;AAC3B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB,qBAAqB;AACrB,qBAAqB;AACrB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,WAAW;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,qBAAqB;AAC/B,UAAU,yBAAyB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA,0DAA0D;AAC1D,wDAAwD,mBAAmB;AAC3E;AACA;AACA,mDAAmD,GAAG;AACtD,MAAM,OAAE;AACR,eAAe,OAAE;AACjB,gBAAgB,OAAE;AAClB;AACA,gBAAgB,OAAE;AAClB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,yBAAyB;AACzB;AACA;AACA,mBAAmB,cAAI;AACvB;AACA;AACA;AACA,cAAc,OAAO;AACrB,+DAA+D,cAAI;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,qBAAqB;AACrB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,oBAAoB;AACpB,wBAAwB;AACxB,wBAAwB;AACxB;AACA;AACA;AACA;AACA,eAAe,cAAI;AACnB;AACA,qBAAqB;AACrB;AACA;AACA;AACA,4BAA4B,WAAW;AACvC,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wCAAwC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oBAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAQ;AACvB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB,kBAAQ;AAC1B;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAO,6BAA6B,iBAAO,eAAe,iBAAO;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2CAA2C;AACrD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA,wCAAwC,YAAY,kBAAkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,iCAAiC,6BAA6B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,cAAI;AACpG;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,yBAAyB;AACzB,uBAAuB;AACvB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,4BAA4B;AAC5B,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kBAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc;AACd,qBAAqB;AACrB,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,QAAQ;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,QAAQ;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,uBAAuB;AACjE;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA,8BAA8B;AAC9B,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uBAAuB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,MAAM;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8BAAgB;AACpC;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAe;AAC9B,WAAW,yBAAe;AAC1B;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,eAAK;AAClD,0CAA0C,eAAK;AAC/C,yCAAyC,eAAK;AAC9C,mCAAmC,eAAK;AACxC,oCAAoC,eAAK;AACzC,kCAAkC,eAAK;AACvC,uCAAuC,eAAK;AAC5C,0CAA0C,eAAK;AAC/C,2CAA2C,eAAK;AAChD,0CAA0C,eAAK;AAC/C;AACA,CAAC;AACD,2CAA2C,eAAK;AAChD;AACA,CAAC;AACD,mCAAmC,eAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yBAAe;AAC5C;AACA;AACA,oCAAoC,qBAAW,UAAU,2BAA2B;AACpF,8CAA8C,qBAAW;AACzD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,eAAK,UAAU,qDAAqD;AAClG;AACA,gCAAgC,eAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAA4D;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,eAAK;AAC3C,uCAAuC,eAAK;AAC5C;AACA,iCAAiC,eAAK;AACtC,sCAAsC,eAAK;AAC3C,kCAAkC,eAAK;AACvC,wCAAwC,eAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,kBAAQ;AACZ,mBAAmB;AACnB;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mCAAmC,eAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,iCAAiC,eAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA,8CAA8C,2DAA2D;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,0DAA0D;AACpH;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4CAA4C;AAC/D;AACA;AACA,kBAAkB,qBAAqB;AACvC,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sCAAsC;AACvE;AACA;AACA;AACA;AACA,qCAAqC,mBAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,IAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,QAAQ;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAAgB;AAClC;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA,iCAAiC,0BAA0B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB,kBAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,UAAU,2BAA2B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,yBAAyB,qCAAqC;AAC9D;AACA,qBAAqB;AACrB;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iBAAiB,GAAG;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,6BAA6B;AAC7B,uBAAuB;AACvB;AACA;AACA;AACA,IAAI,kBAAQ;AACZ;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,yBAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8BAAgB;AAC/B;AACA,aAAa,8BAAgB;AAC7B;AACA;AACA,mBAAmB,8BAAgB;AACnC;AACA;AACA;AACA;AACA;AACA,mBAAmB,8BAAgB;AACnC;AACA;AACA;AACA;AACA,WAAW,yBAAe;AAC1B;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+DAA+D;AAC7F;AACA;AACA,oCAAoC,4DAA4D;AAChG;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B,UAAU,OAAO;AACjB;AACA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA,mBAAmB,4CAA4C;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,MAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iDAAiD;AACjD;AACA,mBAAmB,yBAAe;AAClC;AACA,WAAW,yBAAe;AAC1B;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,sCAAsC,0BAA0B;AAChE;AACA;AACA;AACA,mBAAmB,yBAAe;AAClC;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yBAAe;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iDAAiD;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yBAAe;AACzC;AACA;AACA;AACA;AACA;AACA,UAAU,SAAS;AACnB;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,wBAAwB,cAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yBAAe;AACpC,mBAAmB,oCAAoC,cAAI;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yBAAe;AACpC,mBAAmB,oCAAoC,cAAI;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8CAA8C;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,wDAAwD,iCAAiC;AACzF;AACA;AACA;AACA,wBAAwB,yBAAe;AACvC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iCAAiC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,UAAU,mDAAmD;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yBAAe;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,SAAS;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,6BAA6B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,kEAAkE;AACxE,MAAM,yDAAyD;AAC/D,MAAM,yDAAyD;AAC/D,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA,8BAA8B,yBAAe;AAC7C;AACA;AACA;AACA;AACA;AACA,8BAA8B,yBAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAe;AACvC;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yBAAyB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB,WAAW,yBAAyB;AACzD,uBAAuB,yBAAe;AACtC,SAAS;AACT;AACA;AACA;AACA;AACA,qBAAqB,WAAW,mDAAmD;AACnF,uBAAuB,yBAAe;AACtC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,eAAe,yBAAe;AAC9B;AACA,0BAA0B;AAC1B;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,eAAe,yBAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oCAAoC;AACrE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yBAAe,mBAAmB,yBAAe;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAe;AACtC;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C,cAAc,WAAW;AACzB;AACA,mBAAmB,yBAAe;AAClC;AACA;AACA;AACA;AACA,UAAU,aAAa,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAe;AACvC;AACA;AACA,UAAU,aAAa;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oCAAoC;AACzE,UAAU,iBAAiB;AAC3B;AACA,YAAY,mDAAmD;AAC/D,gBAAgB;AAChB;AACA;AACA;AACA;AACA,qBAAqB,uEAAuE;AAC5F;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,8BAA8B,8DAA8D;AAC5F;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,UAAU,yBAAyB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oBAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8CAA8C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2CAA2C;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,6CAA6C;AAC7C;AACA;;AAEA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,mBAAmB,cAAI;AACvB;AACA,8BAA8B;AAC9B;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,oCAAoC;AACpC;AACA;AACA,yCAAyC,QAAQ;AACjD,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB,YAAY;AAC7C;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,+BAA+B;AAC/B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY,EAAE,sCAAsC,EAAE,iDAAiD;AAC9H;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,cAAc,wCAAwC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8BAA8B;AAC5C,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kBAAQ;AAChB;AACA;AACA;AACA;AACA;AACA,IAAI,kBAAQ;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6BAA6B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,6BAA6B;AAC7B,gCAAgC;AAChC,kCAAkC;AAClC,mCAAmC;AACnC,+BAA+B;AAC/B,8BAA8B;AAC9B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,cAAI;AAC5E,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD,wBAAwB,QAAQ;AAChC;AACA,mCAAmC,UAAU;AAC7C,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wJAAwJ,mBAAS;AACjK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oCAAoC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,cAAI;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA,cAAc,MAAM;AACpB,cAAc,SAAS;AACvB,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,yBAAe;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kBAAQ;AAChB,6BAA6B,cAAc,UAAU,IAAI;AACzD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4BAA4B,oEAAoE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,kBAAQ;AACZ,kBAAkB;AAClB;AACA;AACA,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA,sBAAsB,eAAe;AACrC;AACA;AACA,aAAa;AACb;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB,WAAW;AAC5B;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,eAAK,UAAU,iCAAiC;AAC3E,+BAA+B,eAAK,UAAU,8CAA8C;AAC5F,iCAAiC,4BAAW,uCAAuC,4BAAW,sCAAsC,4BAAW;AAC/I,uBAAuB;AACvB;AACA,eAAe,4BAAW;AAC1B;AACA;AACA;AACA;AACA;AACA,kEAAkE,EAAE;AACpE;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,4BAA4B,qBAAqB;AACjD,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,6BAA6B,QAAQ,WAAW,YAAY,cAAc;AAC1E,8BAA8B,QAAQ,WAAW,YAAY,cAAc;AAC3E;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,2BAA2B;AAC3B,KAAK;AACL,+BAA+B,8BAA8B;AAC7D,8BAA8B,8BAA8B;AAC5D,gCAAgC,cAAc;AAC9C,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI,sBAAsB;AACvC;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,IAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,wBAAwB,eAAe;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA,mCAAmC;AACnC,2BAA2B,kBAAkB,cAAI;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,yBAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,SAAS;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,2EAA2E,EAAE,4BAA4B;AAC3K,oDAAoD,cAAc,SAAS;AAC3E;AACA;AACA;AACA,4BAA4B,4DAA4D;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA,uDAAuD,qBAAW;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,qBAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAW,8BAA8B,qBAAW;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,OAAO;AACjC,wEAAwE,yBAAe;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,cAAc,sCAAsC;AACpD;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB,IAAI,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4BAAW,6EAA6E,QAAQ;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iCAAiC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,2EAA2E,yBAAe;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wBAAwB;AACtC;AACA,kDAAkD,yBAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,KAAK,yBAAyB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,KAAK,2BAA2B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4BAAW;AAChC,sEAAsE,OAAO;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,eAAK,UAAU,mDAAmD;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,4BAA4B;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,kBAAkB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,QAAQ;AAChF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAI;AACzC;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAK,UAAU,0BAA0B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,+CAA+C;AAC/C,sDAAsD;AACtD;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,sBAAsB,MAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,mBAAmB,yBAAW,oBAAoB,2BAAa;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA,oDAAoD,KAAK;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2BAA2B;AAC7D,mCAAmC,4BAA4B;AAC/D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA,gDAAgD,WAAW,IAAI,WAAW;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,eAAK;AACrC;AACA;AACA;AACA,SAAS,UAAK;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,eAAK;AAC1C;AACA,eAAe,2BAAa;AAC5B;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,UAAK;AACtC;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,2CAA2C,yBAAe;AAC1D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA,oCAAoC,UAAK;AACzC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA,yCAAyC,2CAA2C;AACpF,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAI;;AAE7C,sCAAsC,qBAAW;AACjD,wBAAwB;AACxB,CAAC;AACD,mCAAmC,oBAAU;AAC7C,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mCAAmC;AACpE;AACA,CAAC;AACD;AACA;AACA,oDAAoD,oCAAoC;AACxF,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8DAA8D,qBAAqB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAA2D;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAe;AACvC,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+FAA+F;AACpI;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAK;AAC5C;AACA,qBAAqB,2BAAa;AAClC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,MAAM;AAChC,+BAA+B,yBAAW;AAC1C;AACA;AACA,6DAA6D,yBAAW;AACxE;AACA;AACA,yBAAyB;AACzB;AACA;AACA,2EAA2E,2CAA2C;AACtH,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA,MAAM,WAAM;AACZ;AACA;AACA,uBAAuB;AACvB;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,2BAA2B,0BAA0B,OAAO;AAC5D;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,WAAM,iCAAiC,QAAQ,0BAA0B,WAAM,4DAA4D;AACvJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,wBAAwB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,2CAA2C;AACjG;AACA;AACA,4BAA4B;AAC5B,KAAK,IAAI,iCAAiC;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA,4BAA4B,yBAAe;AAC3C;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA,wBAAwB,wBAAU;AAClC;AACA,4BAA4B,yBAAe;AAC3C;AACA;AACA,0BAA0B,wBAAU;AACpC,4BAA4B,yBAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oCAAoC;AACxE;AACA;AACA;AACA,cAAc,yBAAW;AACzB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAe;AACtC;AACA,uBAAuB,yBAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kDAAkD,QAAQ,4GAA4G;AACtK;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,UAAU,MAAM;AAChB,aAAa;AACb;AACA,mCAAmC,eAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,mDAAmD,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iCAAiC;AAC/C;AACA,wBAAwB,kCAAkC;AAC1D,4FAA4F,MAAM;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wCAAwC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,mBAAmB;AACnB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB,mBAAmB;AACtC,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C,4BAA4B,mBAAmB;AAC/C,SAAS;AACT;AACA,wBAAwB,mBAAmB;AAC3C;AACA,8BAA8B,mBAAmB;AACjD,aAAa;AACb;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA,SAAS;AACT;AACA,qBAAqB,mBAAmB;AACxC;AACA,iCAAiC,mBAAmB;AACpD,aAAa;AACb;AACA,iCAAiC,mBAAmB;AACpD;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,mBAAmB;AACnB;AACA;AACA;AACA,iCAAiC,eAAK;AACtC;AACA,CAAC;AACD,sCAAsC,eAAK;AAC3C;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,sBAAsB;AACtB,oBAAoB;AACpB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ,6DAA6D;AAClH;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,wCAAwC,sEAAsE;AAC9G;AACA,aAAa;AACb;AACA;AACA,4BAA4B,gEAAgE;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,cAAc,kBAAkB;AAChC;AACA,kBAAkB,MAAM;AACxB;AACA;AACA,qCAAqC,+BAA+B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA,qCAAqC,+BAA+B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+BAA+B;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2BAA2B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,MAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,mBAAmB,qBAAW;AAC9B,qBAAqB,oBAAU;AAC/B,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,iBAAO;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,qBAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,eAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,0BAA0B;AAC1B,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAK;AACpC;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,eAAK;AAC1C;AACA;AACA;AACA;AACA,uCAAuC,eAAK;AAC5C;AACA;AACA;AACA;AACA,mBAAmB,kBAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,eAAK;AACxC;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA,kCAAkC,eAAK;AACvC;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kBAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,KAAK;AACL,CAAC;AACD,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAQ;AAC9B;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAK;AAC5C;AACA;AACA;AACA,4CAA4C,eAAK;AACjD,sCAAsC,eAAK;AAC3C;AACA,eAAe,2BAAa,WAAW,4CAA4C;AACnF;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6CAA6C;AACjE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAQ;AACnB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;AACL;AACA,+CAA+C,0BAA0B;AACzE,iDAAiD,4BAA4B;AAC7E;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2BAA2B;AAC1E;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAE2rB;;;;;;;;;;;ACx4V3rB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,0BAA0B,2BAA2B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,QAAQ;;AAEjB;AACA;AACA;;AAEA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV,8GAA8G;AAC9G;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2EAA2E,eAAe;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD;AAClD,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,IAAI,iBAAiB;AACrB;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,yBAAyB,KAAK&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/w3c-keyname/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/view/dist/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/style-mod/src/style-mod.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;export var base = {</span><span class="s3">\n  </span><span class="s1">8: </span><span class="s3">\&quot;</span><span class="s1">Backspace</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">9: </span><span class="s3">\&quot;</span><span class="s1">Tab</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">10: </span><span class="s3">\&quot;</span><span class="s1">Enter</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">12: </span><span class="s3">\&quot;</span><span class="s1">NumLock</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">13: </span><span class="s3">\&quot;</span><span class="s1">Enter</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">16: </span><span class="s3">\&quot;</span><span class="s1">Shift</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">17: </span><span class="s3">\&quot;</span><span class="s1">Control</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">18: </span><span class="s3">\&quot;</span><span class="s1">Alt</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">20: </span><span class="s3">\&quot;</span><span class="s1">CapsLock</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">27: </span><span class="s3">\&quot;</span><span class="s1">Escape</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">32: </span><span class="s3">\&quot; \&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">33: </span><span class="s3">\&quot;</span><span class="s1">PageUp</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">34: </span><span class="s3">\&quot;</span><span class="s1">PageDown</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">35: </span><span class="s3">\&quot;</span><span class="s1">End</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">36: </span><span class="s3">\&quot;</span><span class="s1">Home</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">37: </span><span class="s3">\&quot;</span><span class="s1">ArrowLeft</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">38: </span><span class="s3">\&quot;</span><span class="s1">ArrowUp</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">39: </span><span class="s3">\&quot;</span><span class="s1">ArrowRight</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">40: </span><span class="s3">\&quot;</span><span class="s1">ArrowDown</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">44: </span><span class="s3">\&quot;</span><span class="s1">PrintScreen</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">45: </span><span class="s3">\&quot;</span><span class="s1">Insert</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">46: </span><span class="s3">\&quot;</span><span class="s1">Delete</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">59: </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">61: </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">91: </span><span class="s3">\&quot;</span><span class="s1">Meta</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">92: </span><span class="s3">\&quot;</span><span class="s1">Meta</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">106: </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">107: </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">108: </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">109: </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">110: </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">111: </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">144: </span><span class="s3">\&quot;</span><span class="s1">NumLock</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">145: </span><span class="s3">\&quot;</span><span class="s1">ScrollLock</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">160: </span><span class="s3">\&quot;</span><span class="s1">Shift</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">161: </span><span class="s3">\&quot;</span><span class="s1">Shift</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">162: </span><span class="s3">\&quot;</span><span class="s1">Control</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">163: </span><span class="s3">\&quot;</span><span class="s1">Control</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">164: </span><span class="s3">\&quot;</span><span class="s1">Alt</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">165: </span><span class="s3">\&quot;</span><span class="s1">Alt</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">173: </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">186: </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">187: </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">188: </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">189: </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">190: </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">191: </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">192: </span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">219: </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">220: </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">221: </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">222: </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export var shift = {</span><span class="s3">\n  </span><span class="s1">48: </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">49: </span><span class="s3">\&quot;</span><span class="s1">!</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">50: </span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">51: </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">52: </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">53: </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">54: </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">55: </span><span class="s3">\&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">56: </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">57: </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">59: </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">61: </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">173: </span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">186: </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">187: </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">188: </span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">189: </span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">190: </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">191: </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">192: </span><span class="s3">\&quot;</span><span class="s1">~</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">219: </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">220: </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">221: </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">222: </span><span class="s3">\&quot;\\\&quot;\&quot;\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var mac = typeof navigator != </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; /Mac/.test(navigator.platform)</span><span class="s3">\n</span><span class="s1">var ie = typeof navigator != </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; /MSIE </span><span class="s3">\\</span><span class="s1">d|Trident</span><span class="s3">\\</span><span class="s1">/(?:[7-9]|</span><span class="s3">\\</span><span class="s1">d{2,})</span><span class="s3">\\</span><span class="s1">..*rv:(</span><span class="s3">\\</span><span class="s1">d+)/.exec(navigator.userAgent)</span><span class="s3">\n\n</span><span class="s1">// Fill in the digit keys</span><span class="s3">\n</span><span class="s1">for (var i = 0; i &lt; 10; i++) base[48 + i] = base[96 + i] = String(i)</span><span class="s3">\n\n</span><span class="s1">// The function keys</span><span class="s3">\n</span><span class="s1">for (var i = 1; i &lt;= 24; i++) base[i + 111] = </span><span class="s3">\&quot;</span><span class="s1">F</span><span class="s3">\&quot; </span><span class="s1">+ i</span><span class="s3">\n\n</span><span class="s1">// And the alphabetic keys</span><span class="s3">\n</span><span class="s1">for (var i = 65; i &lt;= 90; i++) {</span><span class="s3">\n  </span><span class="s1">base[i] = String.fromCharCode(i + 32)</span><span class="s3">\n  </span><span class="s1">shift[i] = String.fromCharCode(i)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// For each code that doesn't have a shift-equivalent, copy the base name</span><span class="s3">\n</span><span class="s1">for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]</span><span class="s3">\n\n</span><span class="s1">export function keyName(event) {</span><span class="s3">\n  </span><span class="s1">// On macOS, keys held with Shift and Cmd don't reflect the effect of Shift in `.key`.</span><span class="s3">\n  </span><span class="s1">// On IE, shift effect is never included in `.key`.</span><span class="s3">\n  </span><span class="s1">var ignoreKey = mac &amp;&amp; event.metaKey &amp;&amp; event.shiftKey &amp;&amp; !event.ctrlKey &amp;&amp; !event.altKey ||</span><span class="s3">\n      </span><span class="s1">ie &amp;&amp; event.shiftKey &amp;&amp; event.key &amp;&amp; event.key.length == 1 ||</span><span class="s3">\n      </span><span class="s1">event.key == </span><span class="s3">\&quot;</span><span class="s1">Unidentified</span><span class="s3">\&quot;\n  </span><span class="s1">var name = (!ignoreKey &amp;&amp; event.key) ||</span><span class="s3">\n    </span><span class="s1">(event.shiftKey ? shift : base)[event.keyCode] ||</span><span class="s3">\n    </span><span class="s1">event.key || </span><span class="s3">\&quot;</span><span class="s1">Unidentified</span><span class="s3">\&quot;\n  </span><span class="s1">// Edge sometimes produces wrong names (Issue #3)</span><span class="s3">\n  </span><span class="s1">if (name == </span><span class="s3">\&quot;</span><span class="s1">Esc</span><span class="s3">\&quot;</span><span class="s1">) name = </span><span class="s3">\&quot;</span><span class="s1">Escape</span><span class="s3">\&quot;\n  </span><span class="s1">if (name == </span><span class="s3">\&quot;</span><span class="s1">Del</span><span class="s3">\&quot;</span><span class="s1">) name = </span><span class="s3">\&quot;</span><span class="s1">Delete</span><span class="s3">\&quot;\n  </span><span class="s1">// https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/</span><span class="s3">\n  </span><span class="s1">if (name == </span><span class="s3">\&quot;</span><span class="s1">Left</span><span class="s3">\&quot;</span><span class="s1">) name = </span><span class="s3">\&quot;</span><span class="s1">ArrowLeft</span><span class="s3">\&quot;\n  </span><span class="s1">if (name == </span><span class="s3">\&quot;</span><span class="s1">Up</span><span class="s3">\&quot;</span><span class="s1">) name = </span><span class="s3">\&quot;</span><span class="s1">ArrowUp</span><span class="s3">\&quot;\n  </span><span class="s1">if (name == </span><span class="s3">\&quot;</span><span class="s1">Right</span><span class="s3">\&quot;</span><span class="s1">) name = </span><span class="s3">\&quot;</span><span class="s1">ArrowRight</span><span class="s3">\&quot;\n  </span><span class="s1">if (name == </span><span class="s3">\&quot;</span><span class="s1">Down</span><span class="s3">\&quot;</span><span class="s1">) name = </span><span class="s3">\&quot;</span><span class="s1">ArrowDown</span><span class="s3">\&quot;\n  </span><span class="s1">return name</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { Text, RangeSet, MapMode, RangeValue, findClusterBreak, EditorSelection, Facet, StateEffect, ChangeSet, findColumn, CharCategory, EditorState, Annotation, Transaction, Prec, codePointAt, codePointSize, combineConfig, StateField, RangeSetBuilder, countColumn } from '@codemirror/state';</span><span class="s3">\n</span><span class="s1">import { StyleModule } from 'style-mod';</span><span class="s3">\n</span><span class="s1">import { keyName, base, shift } from 'w3c-keyname';</span><span class="s3">\n\n</span><span class="s1">function getSelection(root) {</span><span class="s3">\n    </span><span class="s1">let target;</span><span class="s3">\n    </span><span class="s1">// Browsers differ on whether shadow roots have a getSelection</span><span class="s3">\n    </span><span class="s1">// method. If it exists, use that, otherwise, call it on the</span><span class="s3">\n    </span><span class="s1">// document.</span><span class="s3">\n    </span><span class="s1">if (root.nodeType == 11) { // Shadow root</span><span class="s3">\n        </span><span class="s1">target = root.getSelection ? root : root.ownerDocument;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">target = root;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return target.getSelection();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function contains(dom, node) {</span><span class="s3">\n    </span><span class="s1">return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function hasSelection(dom, selection) {</span><span class="s3">\n    </span><span class="s1">if (!selection.anchorNode)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">// Firefox will raise 'permission denied' errors when accessing</span><span class="s3">\n        </span><span class="s1">// properties of `sel.anchorNode` when it's in a generated CSS</span><span class="s3">\n        </span><span class="s1">// element.</span><span class="s3">\n        </span><span class="s1">return contains(dom, selection.anchorNode);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">catch (_) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function clientRectsFor(dom) {</span><span class="s3">\n    </span><span class="s1">if (dom.nodeType == 3)</span><span class="s3">\n        </span><span class="s1">return textRange(dom, 0, dom.nodeValue.length).getClientRects();</span><span class="s3">\n    </span><span class="s1">else if (dom.nodeType == 1)</span><span class="s3">\n        </span><span class="s1">return dom.getClientRects();</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">return [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Scans forward and backward through DOM positions equivalent to the</span><span class="s3">\n</span><span class="s1">// given one to see if the two are in the same place (i.e. after a</span><span class="s3">\n</span><span class="s1">// text node vs at the end of that text node)</span><span class="s3">\n</span><span class="s1">function isEquivalentPosition(node, off, targetNode, targetOff) {</span><span class="s3">\n    </span><span class="s1">return targetNode ? (scanFor(node, off, targetNode, targetOff, -1) ||</span><span class="s3">\n        </span><span class="s1">scanFor(node, off, targetNode, targetOff, 1)) : false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function domIndex(node) {</span><span class="s3">\n    </span><span class="s1">for (var index = 0;; index++) {</span><span class="s3">\n        </span><span class="s1">node = node.previousSibling;</span><span class="s3">\n        </span><span class="s1">if (!node)</span><span class="s3">\n            </span><span class="s1">return index;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isBlockElement(node) {</span><span class="s3">\n    </span><span class="s1">return node.nodeType == 1 &amp;&amp; /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H</span><span class="s3">\\</span><span class="s1">d|SECTION|PRE)$/.test(node.nodeName);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function scanFor(node, off, targetNode, targetOff, dir) {</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">if (node == targetNode &amp;&amp; off == targetOff)</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">if (off == (dir &lt; 0 ? 0 : maxOffset(node))) {</span><span class="s3">\n            </span><span class="s1">if (node.nodeName == </span><span class="s3">\&quot;</span><span class="s1">DIV</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">let parent = node.parentNode;</span><span class="s3">\n            </span><span class="s1">if (!parent || parent.nodeType != 1)</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">off = domIndex(node) + (dir &lt; 0 ? 0 : 1);</span><span class="s3">\n            </span><span class="s1">node = parent;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (node.nodeType == 1) {</span><span class="s3">\n            </span><span class="s1">node = node.childNodes[off + (dir &lt; 0 ? -1 : 0)];</span><span class="s3">\n            </span><span class="s1">if (node.nodeType == 1 &amp;&amp; node.contentEditable == </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">off = dir &lt; 0 ? maxOffset(node) : 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function maxOffset(node) {</span><span class="s3">\n    </span><span class="s1">return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function flattenRect(rect, left) {</span><span class="s3">\n    </span><span class="s1">let x = left ? rect.left : rect.right;</span><span class="s3">\n    </span><span class="s1">return { left: x, right: x, top: rect.top, bottom: rect.bottom };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function windowRect(win) {</span><span class="s3">\n    </span><span class="s1">let vp = win.visualViewport;</span><span class="s3">\n    </span><span class="s1">if (vp)</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">left: 0, right: vp.width,</span><span class="s3">\n            </span><span class="s1">top: 0, bottom: vp.height</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return { left: 0, right: win.innerWidth,</span><span class="s3">\n        </span><span class="s1">top: 0, bottom: win.innerHeight };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getScale(elt, rect) {</span><span class="s3">\n    </span><span class="s1">let scaleX = rect.width / elt.offsetWidth;</span><span class="s3">\n    </span><span class="s1">let scaleY = rect.height / elt.offsetHeight;</span><span class="s3">\n    </span><span class="s1">if (scaleX &gt; 0.995 &amp;&amp; scaleX &lt; 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) &lt; 1)</span><span class="s3">\n        </span><span class="s1">scaleX = 1;</span><span class="s3">\n    </span><span class="s1">if (scaleY &gt; 0.995 &amp;&amp; scaleY &lt; 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) &lt; 1)</span><span class="s3">\n        </span><span class="s1">scaleY = 1;</span><span class="s3">\n    </span><span class="s1">return { scaleX, scaleY };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {</span><span class="s3">\n    </span><span class="s1">let doc = dom.ownerDocument, win = doc.defaultView || window;</span><span class="s3">\n    </span><span class="s1">for (let cur = dom, stop = false; cur &amp;&amp; !stop;) {</span><span class="s3">\n        </span><span class="s1">if (cur.nodeType == 1) { // Element</span><span class="s3">\n            </span><span class="s1">let bounding, top = cur == doc.body;</span><span class="s3">\n            </span><span class="s1">let scaleX = 1, scaleY = 1;</span><span class="s3">\n            </span><span class="s1">if (top) {</span><span class="s3">\n                </span><span class="s1">bounding = windowRect(win);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position))</span><span class="s3">\n                    </span><span class="s1">stop = true;</span><span class="s3">\n                </span><span class="s1">if (cur.scrollHeight &lt;= cur.clientHeight &amp;&amp; cur.scrollWidth &lt;= cur.clientWidth) {</span><span class="s3">\n                    </span><span class="s1">cur = cur.assignedSlot || cur.parentNode;</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">let rect = cur.getBoundingClientRect();</span><span class="s3">\n                </span><span class="s1">({ scaleX, scaleY } = getScale(cur, rect));</span><span class="s3">\n                </span><span class="s1">// Make sure scrollbar width isn't included in the rectangle</span><span class="s3">\n                </span><span class="s1">bounding = { left: rect.left, right: rect.left + cur.clientWidth * scaleX,</span><span class="s3">\n                    </span><span class="s1">top: rect.top, bottom: rect.top + cur.clientHeight * scaleY };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let moveX = 0, moveY = 0;</span><span class="s3">\n            </span><span class="s1">if (y == </span><span class="s3">\&quot;</span><span class="s1">nearest</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">if (rect.top &lt; bounding.top) {</span><span class="s3">\n                    </span><span class="s1">moveY = -(bounding.top - rect.top + yMargin);</span><span class="s3">\n                    </span><span class="s1">if (side &gt; 0 &amp;&amp; rect.bottom &gt; bounding.bottom + moveY)</span><span class="s3">\n                        </span><span class="s1">moveY = rect.bottom - bounding.bottom + moveY + yMargin;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (rect.bottom &gt; bounding.bottom) {</span><span class="s3">\n                    </span><span class="s1">moveY = rect.bottom - bounding.bottom + yMargin;</span><span class="s3">\n                    </span><span class="s1">if (side &lt; 0 &amp;&amp; (rect.top - moveY) &lt; bounding.top)</span><span class="s3">\n                        </span><span class="s1">moveY = -(bounding.top + moveY - rect.top + yMargin);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;</span><span class="s3">\n                </span><span class="s1">let targetTop = y == </span><span class="s3">\&quot;</span><span class="s1">center</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; rectHeight &lt;= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 :</span><span class="s3">\n                    </span><span class="s1">y == </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot; </span><span class="s1">|| y == </span><span class="s3">\&quot;</span><span class="s1">center</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; side &lt; 0 ? rect.top - yMargin :</span><span class="s3">\n                        </span><span class="s1">rect.bottom - boundingHeight + yMargin;</span><span class="s3">\n                </span><span class="s1">moveY = targetTop - bounding.top;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (x == </span><span class="s3">\&quot;</span><span class="s1">nearest</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">if (rect.left &lt; bounding.left) {</span><span class="s3">\n                    </span><span class="s1">moveX = -(bounding.left - rect.left + xMargin);</span><span class="s3">\n                    </span><span class="s1">if (side &gt; 0 &amp;&amp; rect.right &gt; bounding.right + moveX)</span><span class="s3">\n                        </span><span class="s1">moveX = rect.right - bounding.right + moveX + xMargin;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (rect.right &gt; bounding.right) {</span><span class="s3">\n                    </span><span class="s1">moveX = rect.right - bounding.right + xMargin;</span><span class="s3">\n                    </span><span class="s1">if (side &lt; 0 &amp;&amp; rect.left &lt; bounding.left + moveX)</span><span class="s3">\n                        </span><span class="s1">moveX = -(bounding.left + moveX - rect.left + xMargin);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let targetLeft = x == </span><span class="s3">\&quot;</span><span class="s1">center</span><span class="s3">\&quot; </span><span class="s1">? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 :</span><span class="s3">\n                    </span><span class="s1">(x == </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot;</span><span class="s1">) == ltr ? rect.left - xMargin :</span><span class="s3">\n                        </span><span class="s1">rect.right - (bounding.right - bounding.left) + xMargin;</span><span class="s3">\n                </span><span class="s1">moveX = targetLeft - bounding.left;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (moveX || moveY) {</span><span class="s3">\n                </span><span class="s1">if (top) {</span><span class="s3">\n                    </span><span class="s1">win.scrollBy(moveX, moveY);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">let movedX = 0, movedY = 0;</span><span class="s3">\n                    </span><span class="s1">if (moveY) {</span><span class="s3">\n                        </span><span class="s1">let start = cur.scrollTop;</span><span class="s3">\n                        </span><span class="s1">cur.scrollTop += moveY / scaleY;</span><span class="s3">\n                        </span><span class="s1">movedY = (cur.scrollTop - start) * scaleY;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (moveX) {</span><span class="s3">\n                        </span><span class="s1">let start = cur.scrollLeft;</span><span class="s3">\n                        </span><span class="s1">cur.scrollLeft += moveX / scaleX;</span><span class="s3">\n                        </span><span class="s1">movedX = (cur.scrollLeft - start) * scaleX;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">rect = { left: rect.left - movedX, top: rect.top - movedY,</span><span class="s3">\n                        </span><span class="s1">right: rect.right - movedX, bottom: rect.bottom - movedY };</span><span class="s3">\n                    </span><span class="s1">if (movedX &amp;&amp; Math.abs(movedX - moveX) &lt; 1)</span><span class="s3">\n                        </span><span class="s1">x = </span><span class="s3">\&quot;</span><span class="s1">nearest</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n                    </span><span class="s1">if (movedY &amp;&amp; Math.abs(movedY - moveY) &lt; 1)</span><span class="s3">\n                        </span><span class="s1">y = </span><span class="s3">\&quot;</span><span class="s1">nearest</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (top)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">cur = cur.assignedSlot || cur.parentNode;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (cur.nodeType == 11) { // A shadow root</span><span class="s3">\n            </span><span class="s1">cur = cur.host;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function scrollableParents(dom) {</span><span class="s3">\n    </span><span class="s1">let doc = dom.ownerDocument, x, y;</span><span class="s3">\n    </span><span class="s1">for (let cur = dom.parentNode; cur;) {</span><span class="s3">\n        </span><span class="s1">if (cur == doc.body || (x &amp;&amp; y)) {</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (cur.nodeType == 1) {</span><span class="s3">\n            </span><span class="s1">if (!y &amp;&amp; cur.scrollHeight &gt; cur.clientHeight)</span><span class="s3">\n                </span><span class="s1">y = cur;</span><span class="s3">\n            </span><span class="s1">if (!x &amp;&amp; cur.scrollWidth &gt; cur.clientWidth)</span><span class="s3">\n                </span><span class="s1">x = cur;</span><span class="s3">\n            </span><span class="s1">cur = cur.assignedSlot || cur.parentNode;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (cur.nodeType == 11) {</span><span class="s3">\n            </span><span class="s1">cur = cur.host;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return { x, y };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class DOMSelectionState {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.anchorNode = null;</span><span class="s3">\n        </span><span class="s1">this.anchorOffset = 0;</span><span class="s3">\n        </span><span class="s1">this.focusNode = null;</span><span class="s3">\n        </span><span class="s1">this.focusOffset = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(domSel) {</span><span class="s3">\n        </span><span class="s1">return this.anchorNode == domSel.anchorNode &amp;&amp; this.anchorOffset == domSel.anchorOffset &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.focusNode == domSel.focusNode &amp;&amp; this.focusOffset == domSel.focusOffset;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setRange(range) {</span><span class="s3">\n        </span><span class="s1">let { anchorNode, focusNode } = range;</span><span class="s3">\n        </span><span class="s1">// Clip offsets to node size to avoid crashes when Safari reports bogus offsets (#1152)</span><span class="s3">\n        </span><span class="s1">this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set(anchorNode, anchorOffset, focusNode, focusOffset) {</span><span class="s3">\n        </span><span class="s1">this.anchorNode = anchorNode;</span><span class="s3">\n        </span><span class="s1">this.anchorOffset = anchorOffset;</span><span class="s3">\n        </span><span class="s1">this.focusNode = focusNode;</span><span class="s3">\n        </span><span class="s1">this.focusOffset = focusOffset;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">let preventScrollSupported = null;</span><span class="s3">\n</span><span class="s1">// Feature-detects support for .focus({preventScroll: true}), and uses</span><span class="s3">\n</span><span class="s1">// a fallback kludge when not supported.</span><span class="s3">\n</span><span class="s1">function focusPreventScroll(dom) {</span><span class="s3">\n    </span><span class="s1">if (dom.setActive)</span><span class="s3">\n        </span><span class="s1">return dom.setActive(); // in IE</span><span class="s3">\n    </span><span class="s1">if (preventScrollSupported)</span><span class="s3">\n        </span><span class="s1">return dom.focus(preventScrollSupported);</span><span class="s3">\n    </span><span class="s1">let stack = [];</span><span class="s3">\n    </span><span class="s1">for (let cur = dom; cur; cur = cur.parentNode) {</span><span class="s3">\n        </span><span class="s1">stack.push(cur, cur.scrollTop, cur.scrollLeft);</span><span class="s3">\n        </span><span class="s1">if (cur == cur.ownerDocument)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dom.focus(preventScrollSupported == null ? {</span><span class="s3">\n        </span><span class="s1">get preventScroll() {</span><span class="s3">\n            </span><span class="s1">preventScrollSupported = { preventScroll: true };</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} : undefined);</span><span class="s3">\n    </span><span class="s1">if (!preventScrollSupported) {</span><span class="s3">\n        </span><span class="s1">preventScrollSupported = false;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; stack.length;) {</span><span class="s3">\n            </span><span class="s1">let elt = stack[i++], top = stack[i++], left = stack[i++];</span><span class="s3">\n            </span><span class="s1">if (elt.scrollTop != top)</span><span class="s3">\n                </span><span class="s1">elt.scrollTop = top;</span><span class="s3">\n            </span><span class="s1">if (elt.scrollLeft != left)</span><span class="s3">\n                </span><span class="s1">elt.scrollLeft = left;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">let scratchRange;</span><span class="s3">\n</span><span class="s1">function textRange(node, from, to = from) {</span><span class="s3">\n    </span><span class="s1">let range = scratchRange || (scratchRange = document.createRange());</span><span class="s3">\n    </span><span class="s1">range.setEnd(node, to);</span><span class="s3">\n    </span><span class="s1">range.setStart(node, from);</span><span class="s3">\n    </span><span class="s1">return range;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function dispatchKey(elt, name, code, mods) {</span><span class="s3">\n    </span><span class="s1">let options = { key: name, code: name, keyCode: code, which: code, cancelable: true };</span><span class="s3">\n    </span><span class="s1">if (mods)</span><span class="s3">\n        </span><span class="s1">({ altKey: options.altKey, ctrlKey: options.ctrlKey, shiftKey: options.shiftKey, metaKey: options.metaKey } = mods);</span><span class="s3">\n    </span><span class="s1">let down = new KeyboardEvent(</span><span class="s3">\&quot;</span><span class="s1">keydown</span><span class="s3">\&quot;</span><span class="s1">, options);</span><span class="s3">\n    </span><span class="s1">down.synthetic = true;</span><span class="s3">\n    </span><span class="s1">elt.dispatchEvent(down);</span><span class="s3">\n    </span><span class="s1">let up = new KeyboardEvent(</span><span class="s3">\&quot;</span><span class="s1">keyup</span><span class="s3">\&quot;</span><span class="s1">, options);</span><span class="s3">\n    </span><span class="s1">up.synthetic = true;</span><span class="s3">\n    </span><span class="s1">elt.dispatchEvent(up);</span><span class="s3">\n    </span><span class="s1">return down.defaultPrevented || up.defaultPrevented;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getRoot(node) {</span><span class="s3">\n    </span><span class="s1">while (node) {</span><span class="s3">\n        </span><span class="s1">if (node &amp;&amp; (node.nodeType == 9 || node.nodeType == 11 &amp;&amp; node.host))</span><span class="s3">\n            </span><span class="s1">return node;</span><span class="s3">\n        </span><span class="s1">node = node.assignedSlot || node.parentNode;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function clearAttributes(node) {</span><span class="s3">\n    </span><span class="s1">while (node.attributes.length)</span><span class="s3">\n        </span><span class="s1">node.removeAttributeNode(node.attributes[0]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function atElementStart(doc, selection) {</span><span class="s3">\n    </span><span class="s1">let node = selection.focusNode, offset = selection.focusOffset;</span><span class="s3">\n    </span><span class="s1">if (!node || selection.anchorNode != node || selection.anchorOffset != offset)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">// Safari can report bogus offsets (#1152)</span><span class="s3">\n    </span><span class="s1">offset = Math.min(offset, maxOffset(node));</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">if (offset) {</span><span class="s3">\n            </span><span class="s1">if (node.nodeType != 1)</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">let prev = node.childNodes[offset - 1];</span><span class="s3">\n            </span><span class="s1">if (prev.contentEditable == </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">offset--;</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">node = prev;</span><span class="s3">\n                </span><span class="s1">offset = maxOffset(node);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (node == doc) {</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">offset = domIndex(node);</span><span class="s3">\n            </span><span class="s1">node = node.parentNode;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isScrolledToBottom(elt) {</span><span class="s3">\n    </span><span class="s1">return elt.scrollTop &gt; Math.max(1, elt.scrollHeight - elt.clientHeight - 4);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function textNodeBefore(startNode, startOffset) {</span><span class="s3">\n    </span><span class="s1">for (let node = startNode, offset = startOffset;;) {</span><span class="s3">\n        </span><span class="s1">if (node.nodeType == 3 &amp;&amp; offset &gt; 0) {</span><span class="s3">\n            </span><span class="s1">return { node: node, offset: offset };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (node.nodeType == 1 &amp;&amp; offset &gt; 0) {</span><span class="s3">\n            </span><span class="s1">if (node.contentEditable == </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">node = node.childNodes[offset - 1];</span><span class="s3">\n            </span><span class="s1">offset = maxOffset(node);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (node.parentNode &amp;&amp; !isBlockElement(node)) {</span><span class="s3">\n            </span><span class="s1">offset = domIndex(node);</span><span class="s3">\n            </span><span class="s1">node = node.parentNode;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function textNodeAfter(startNode, startOffset) {</span><span class="s3">\n    </span><span class="s1">for (let node = startNode, offset = startOffset;;) {</span><span class="s3">\n        </span><span class="s1">if (node.nodeType == 3 &amp;&amp; offset &lt; node.nodeValue.length) {</span><span class="s3">\n            </span><span class="s1">return { node: node, offset: offset };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (node.nodeType == 1 &amp;&amp; offset &lt; node.childNodes.length) {</span><span class="s3">\n            </span><span class="s1">if (node.contentEditable == </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">node = node.childNodes[offset];</span><span class="s3">\n            </span><span class="s1">offset = 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (node.parentNode &amp;&amp; !isBlockElement(node)) {</span><span class="s3">\n            </span><span class="s1">offset = domIndex(node) + 1;</span><span class="s3">\n            </span><span class="s1">node = node.parentNode;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class DOMPos {</span><span class="s3">\n    </span><span class="s1">constructor(node, offset, precise = true) {</span><span class="s3">\n        </span><span class="s1">this.node = node;</span><span class="s3">\n        </span><span class="s1">this.offset = offset;</span><span class="s3">\n        </span><span class="s1">this.precise = precise;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static before(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom), precise); }</span><span class="s3">\n    </span><span class="s1">static after(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const noChildren = [];</span><span class="s3">\n</span><span class="s1">class ContentView {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.parent = null;</span><span class="s3">\n        </span><span class="s1">this.dom = null;</span><span class="s3">\n        </span><span class="s1">this.flags = 2 /* ViewFlag.NodeDirty */;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get overrideDOMText() { return null; }</span><span class="s3">\n    </span><span class="s1">get posAtStart() {</span><span class="s3">\n        </span><span class="s1">return this.parent ? this.parent.posBefore(this) : 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get posAtEnd() {</span><span class="s3">\n        </span><span class="s1">return this.posAtStart + this.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">posBefore(view) {</span><span class="s3">\n        </span><span class="s1">let pos = this.posAtStart;</span><span class="s3">\n        </span><span class="s1">for (let child of this.children) {</span><span class="s3">\n            </span><span class="s1">if (child == view)</span><span class="s3">\n                </span><span class="s1">return pos;</span><span class="s3">\n            </span><span class="s1">pos += child.length + child.breakAfter;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Invalid child in posBefore</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">posAfter(view) {</span><span class="s3">\n        </span><span class="s1">return this.posBefore(view) + view.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">sync(view, track) {</span><span class="s3">\n        </span><span class="s1">if (this.flags &amp; 2 /* ViewFlag.NodeDirty */) {</span><span class="s3">\n            </span><span class="s1">let parent = this.dom;</span><span class="s3">\n            </span><span class="s1">let prev = null, next;</span><span class="s3">\n            </span><span class="s1">for (let child of this.children) {</span><span class="s3">\n                </span><span class="s1">if (child.flags &amp; 7 /* ViewFlag.Dirty */) {</span><span class="s3">\n                    </span><span class="s1">if (!child.dom &amp;&amp; (next = prev ? prev.nextSibling : parent.firstChild)) {</span><span class="s3">\n                        </span><span class="s1">let contentView = ContentView.get(next);</span><span class="s3">\n                        </span><span class="s1">if (!contentView || !contentView.parent &amp;&amp; contentView.canReuseDOM(child))</span><span class="s3">\n                            </span><span class="s1">child.reuseDOM(next);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">child.sync(view, track);</span><span class="s3">\n                    </span><span class="s1">child.flags &amp;= ~7 /* ViewFlag.Dirty */;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">next = prev ? prev.nextSibling : parent.firstChild;</span><span class="s3">\n                </span><span class="s1">if (track &amp;&amp; !track.written &amp;&amp; track.node == parent &amp;&amp; next != child.dom)</span><span class="s3">\n                    </span><span class="s1">track.written = true;</span><span class="s3">\n                </span><span class="s1">if (child.dom.parentNode == parent) {</span><span class="s3">\n                    </span><span class="s1">while (next &amp;&amp; next != child.dom)</span><span class="s3">\n                        </span><span class="s1">next = rm$1(next);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">parent.insertBefore(child.dom, next);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">prev = child.dom;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">next = prev ? prev.nextSibling : parent.firstChild;</span><span class="s3">\n            </span><span class="s1">if (next &amp;&amp; track &amp;&amp; track.node == parent)</span><span class="s3">\n                </span><span class="s1">track.written = true;</span><span class="s3">\n            </span><span class="s1">while (next)</span><span class="s3">\n                </span><span class="s1">next = rm$1(next);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (this.flags &amp; 1 /* ViewFlag.ChildDirty */) {</span><span class="s3">\n            </span><span class="s1">for (let child of this.children)</span><span class="s3">\n                </span><span class="s1">if (child.flags &amp; 7 /* ViewFlag.Dirty */) {</span><span class="s3">\n                    </span><span class="s1">child.sync(view, track);</span><span class="s3">\n                    </span><span class="s1">child.flags &amp;= ~7 /* ViewFlag.Dirty */;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">reuseDOM(_dom) { }</span><span class="s3">\n    </span><span class="s1">localPosFromDOM(node, offset) {</span><span class="s3">\n        </span><span class="s1">let after;</span><span class="s3">\n        </span><span class="s1">if (node == this.dom) {</span><span class="s3">\n            </span><span class="s1">after = this.dom.childNodes[offset];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;</span><span class="s3">\n            </span><span class="s1">for (;;) {</span><span class="s3">\n                </span><span class="s1">let parent = node.parentNode;</span><span class="s3">\n                </span><span class="s1">if (parent == this.dom)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">if (bias == 0 &amp;&amp; parent.firstChild != parent.lastChild) {</span><span class="s3">\n                    </span><span class="s1">if (node == parent.firstChild)</span><span class="s3">\n                        </span><span class="s1">bias = -1;</span><span class="s3">\n                    </span><span class="s1">else</span><span class="s3">\n                        </span><span class="s1">bias = 1;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">node = parent;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (bias &lt; 0)</span><span class="s3">\n                </span><span class="s1">after = node;</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">after = node.nextSibling;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (after == this.dom.firstChild)</span><span class="s3">\n            </span><span class="s1">return 0;</span><span class="s3">\n        </span><span class="s1">while (after &amp;&amp; !ContentView.get(after))</span><span class="s3">\n            </span><span class="s1">after = after.nextSibling;</span><span class="s3">\n        </span><span class="s1">if (!after)</span><span class="s3">\n            </span><span class="s1">return this.length;</span><span class="s3">\n        </span><span class="s1">for (let i = 0, pos = 0;; i++) {</span><span class="s3">\n            </span><span class="s1">let child = this.children[i];</span><span class="s3">\n            </span><span class="s1">if (child.dom == after)</span><span class="s3">\n                </span><span class="s1">return pos;</span><span class="s3">\n            </span><span class="s1">pos += child.length + child.breakAfter;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">domBoundsAround(from, to, offset = 0) {</span><span class="s3">\n        </span><span class="s1">let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;</span><span class="s3">\n        </span><span class="s1">for (let i = 0, pos = offset, prevEnd = offset; i &lt; this.children.length; i++) {</span><span class="s3">\n            </span><span class="s1">let child = this.children[i], end = pos + child.length;</span><span class="s3">\n            </span><span class="s1">if (pos &lt; from &amp;&amp; end &gt; to)</span><span class="s3">\n                </span><span class="s1">return child.domBoundsAround(from, to, pos);</span><span class="s3">\n            </span><span class="s1">if (end &gt;= from &amp;&amp; fromI == -1) {</span><span class="s3">\n                </span><span class="s1">fromI = i;</span><span class="s3">\n                </span><span class="s1">fromStart = pos;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (pos &gt; to &amp;&amp; child.dom.parentNode == this.dom) {</span><span class="s3">\n                </span><span class="s1">toI = i;</span><span class="s3">\n                </span><span class="s1">toEnd = prevEnd;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">prevEnd = end;</span><span class="s3">\n            </span><span class="s1">pos = end + child.breakAfter;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { from: fromStart, to: toEnd &lt; 0 ? offset + this.length : toEnd,</span><span class="s3">\n            </span><span class="s1">startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,</span><span class="s3">\n            </span><span class="s1">endDOM: toI &lt; this.children.length &amp;&amp; toI &gt;= 0 ? this.children[toI].dom : null };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">markDirty(andParent = false) {</span><span class="s3">\n        </span><span class="s1">this.flags |= 2 /* ViewFlag.NodeDirty */;</span><span class="s3">\n        </span><span class="s1">this.markParentsDirty(andParent);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">markParentsDirty(childList) {</span><span class="s3">\n        </span><span class="s1">for (let parent = this.parent; parent; parent = parent.parent) {</span><span class="s3">\n            </span><span class="s1">if (childList)</span><span class="s3">\n                </span><span class="s1">parent.flags |= 2 /* ViewFlag.NodeDirty */;</span><span class="s3">\n            </span><span class="s1">if (parent.flags &amp; 1 /* ViewFlag.ChildDirty */)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">parent.flags |= 1 /* ViewFlag.ChildDirty */;</span><span class="s3">\n            </span><span class="s1">childList = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setParent(parent) {</span><span class="s3">\n        </span><span class="s1">if (this.parent != parent) {</span><span class="s3">\n            </span><span class="s1">this.parent = parent;</span><span class="s3">\n            </span><span class="s1">if (this.flags &amp; 7 /* ViewFlag.Dirty */)</span><span class="s3">\n                </span><span class="s1">this.markParentsDirty(true);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setDOM(dom) {</span><span class="s3">\n        </span><span class="s1">if (this.dom == dom)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">if (this.dom)</span><span class="s3">\n            </span><span class="s1">this.dom.cmView = null;</span><span class="s3">\n        </span><span class="s1">this.dom = dom;</span><span class="s3">\n        </span><span class="s1">dom.cmView = this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get rootView() {</span><span class="s3">\n        </span><span class="s1">for (let v = this;;) {</span><span class="s3">\n            </span><span class="s1">let parent = v.parent;</span><span class="s3">\n            </span><span class="s1">if (!parent)</span><span class="s3">\n                </span><span class="s1">return v;</span><span class="s3">\n            </span><span class="s1">v = parent;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">replaceChildren(from, to, children = noChildren) {</span><span class="s3">\n        </span><span class="s1">this.markDirty();</span><span class="s3">\n        </span><span class="s1">for (let i = from; i &lt; to; i++) {</span><span class="s3">\n            </span><span class="s1">let child = this.children[i];</span><span class="s3">\n            </span><span class="s1">if (child.parent == this &amp;&amp; children.indexOf(child) &lt; 0)</span><span class="s3">\n                </span><span class="s1">child.destroy();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (children.length &lt; 250)</span><span class="s3">\n            </span><span class="s1">this.children.splice(from, to - from, ...children);</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">this.children = [].concat(this.children.slice(0, from), children, this.children.slice(to));</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; children.length; i++)</span><span class="s3">\n            </span><span class="s1">children[i].setParent(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ignoreMutation(_rec) { return false; }</span><span class="s3">\n    </span><span class="s1">ignoreEvent(_event) { return false; }</span><span class="s3">\n    </span><span class="s1">childCursor(pos = this.length) {</span><span class="s3">\n        </span><span class="s1">return new ChildCursor(this.children, pos, this.children.length);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">childPos(pos, bias = 1) {</span><span class="s3">\n        </span><span class="s1">return this.childCursor().findPos(pos, bias);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">let name = this.constructor.name.replace(</span><span class="s3">\&quot;</span><span class="s1">View</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return name + (this.children.length ? </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot; </span><span class="s1">+ this.children.join() + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">this.length ? </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot; </span><span class="s1">+ (name == </span><span class="s3">\&quot;</span><span class="s1">Text</span><span class="s3">\&quot; </span><span class="s1">? this.text : this.length) + </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">) +</span><span class="s3">\n            </span><span class="s1">(this.breakAfter ? </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static get(node) { return node.cmView; }</span><span class="s3">\n    </span><span class="s1">get isEditable() { return true; }</span><span class="s3">\n    </span><span class="s1">get isWidget() { return false; }</span><span class="s3">\n    </span><span class="s1">get isHidden() { return false; }</span><span class="s3">\n    </span><span class="s1">merge(from, to, source, hasStart, openStart, openEnd) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">become(other) { return false; }</span><span class="s3">\n    </span><span class="s1">canReuseDOM(other) {</span><span class="s3">\n        </span><span class="s1">return other.constructor == this.constructor &amp;&amp; !((this.flags | other.flags) &amp; 8 /* ViewFlag.Composition */);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// When this is a zero-length view with a side, this should return a</span><span class="s3">\n    </span><span class="s1">// number &lt;= 0 to indicate it is before its position, or a</span><span class="s3">\n    </span><span class="s1">// number &gt; 0 when after its position.</span><span class="s3">\n    </span><span class="s1">getSide() { return 0; }</span><span class="s3">\n    </span><span class="s1">destroy() {</span><span class="s3">\n        </span><span class="s1">for (let child of this.children)</span><span class="s3">\n            </span><span class="s1">if (child.parent == this)</span><span class="s3">\n                </span><span class="s1">child.destroy();</span><span class="s3">\n        </span><span class="s1">this.parent = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">ContentView.prototype.breakAfter = 0;</span><span class="s3">\n</span><span class="s1">// Remove a DOM node and return its next sibling.</span><span class="s3">\n</span><span class="s1">function rm$1(dom) {</span><span class="s3">\n    </span><span class="s1">let next = dom.nextSibling;</span><span class="s3">\n    </span><span class="s1">dom.parentNode.removeChild(dom);</span><span class="s3">\n    </span><span class="s1">return next;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class ChildCursor {</span><span class="s3">\n    </span><span class="s1">constructor(children, pos, i) {</span><span class="s3">\n        </span><span class="s1">this.children = children;</span><span class="s3">\n        </span><span class="s1">this.pos = pos;</span><span class="s3">\n        </span><span class="s1">this.i = i;</span><span class="s3">\n        </span><span class="s1">this.off = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">findPos(pos, bias = 1) {</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">if (pos &gt; this.pos || pos == this.pos &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(bias &gt; 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {</span><span class="s3">\n                </span><span class="s1">this.off = pos - this.pos;</span><span class="s3">\n                </span><span class="s1">return this;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let next = this.children[--this.i];</span><span class="s3">\n            </span><span class="s1">this.pos -= next.length + next.breakAfter;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {</span><span class="s3">\n    </span><span class="s1">let { children } = parent;</span><span class="s3">\n    </span><span class="s1">let before = children.length ? children[fromI] : null;</span><span class="s3">\n    </span><span class="s1">let last = insert.length ? insert[insert.length - 1] : null;</span><span class="s3">\n    </span><span class="s1">let breakAtEnd = last ? last.breakAfter : breakAtStart;</span><span class="s3">\n    </span><span class="s1">// Change within a single child</span><span class="s3">\n    </span><span class="s1">if (fromI == toI &amp;&amp; before &amp;&amp; !breakAtStart &amp;&amp; !breakAtEnd &amp;&amp; insert.length &lt; 2 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd))</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">if (toI &lt; children.length) {</span><span class="s3">\n        </span><span class="s1">let after = children[toI];</span><span class="s3">\n        </span><span class="s1">// Make sure the end of the child after the update is preserved in `after`</span><span class="s3">\n        </span><span class="s1">if (after &amp;&amp; (toOff &lt; after.length || after.breakAfter &amp;&amp; (last === null || last === void 0 ? void 0 : last.breakAfter))) {</span><span class="s3">\n            </span><span class="s1">// If we're splitting a child, separate part of it to avoid that</span><span class="s3">\n            </span><span class="s1">// being mangled when updating the child before the update.</span><span class="s3">\n            </span><span class="s1">if (fromI == toI) {</span><span class="s3">\n                </span><span class="s1">after = after.split(toOff);</span><span class="s3">\n                </span><span class="s1">toOff = 0;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// If the element after the replacement should be merged with</span><span class="s3">\n            </span><span class="s1">// the last replacing element, update `content`</span><span class="s3">\n            </span><span class="s1">if (!breakAtEnd &amp;&amp; last &amp;&amp; after.merge(0, toOff, last, true, 0, openEnd)) {</span><span class="s3">\n                </span><span class="s1">insert[insert.length - 1] = after;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">// Remove the start of the after element, if necessary, and</span><span class="s3">\n                </span><span class="s1">// add it to `content`.</span><span class="s3">\n                </span><span class="s1">if (toOff || after.children.length &amp;&amp; !after.children[0].length)</span><span class="s3">\n                    </span><span class="s1">after.merge(0, toOff, null, false, 0, openEnd);</span><span class="s3">\n                </span><span class="s1">insert.push(after);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (after === null || after === void 0 ? void 0 : after.breakAfter) {</span><span class="s3">\n            </span><span class="s1">// The element at `toI` is entirely covered by this range.</span><span class="s3">\n            </span><span class="s1">// Preserve its line break, if any.</span><span class="s3">\n            </span><span class="s1">if (last)</span><span class="s3">\n                </span><span class="s1">last.breakAfter = 1;</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">breakAtStart = 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Since we've handled the next element from the current elements</span><span class="s3">\n        </span><span class="s1">// now, make sure `toI` points after that.</span><span class="s3">\n        </span><span class="s1">toI++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (before) {</span><span class="s3">\n        </span><span class="s1">before.breakAfter = breakAtStart;</span><span class="s3">\n        </span><span class="s1">if (fromOff &gt; 0) {</span><span class="s3">\n            </span><span class="s1">if (!breakAtStart &amp;&amp; insert.length &amp;&amp; before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {</span><span class="s3">\n                </span><span class="s1">before.breakAfter = insert.shift().breakAfter;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (fromOff &lt; before.length || before.children.length &amp;&amp; before.children[before.children.length - 1].length == 0) {</span><span class="s3">\n                </span><span class="s1">before.merge(fromOff, before.length, null, false, openStart, 0);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">fromI++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Try to merge widgets on the boundaries of the replacement</span><span class="s3">\n    </span><span class="s1">while (fromI &lt; toI &amp;&amp; insert.length) {</span><span class="s3">\n        </span><span class="s1">if (children[toI - 1].become(insert[insert.length - 1])) {</span><span class="s3">\n            </span><span class="s1">toI--;</span><span class="s3">\n            </span><span class="s1">insert.pop();</span><span class="s3">\n            </span><span class="s1">openEnd = insert.length ? 0 : openStart;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (children[fromI].become(insert[0])) {</span><span class="s3">\n            </span><span class="s1">fromI++;</span><span class="s3">\n            </span><span class="s1">insert.shift();</span><span class="s3">\n            </span><span class="s1">openStart = insert.length ? 0 : openEnd;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!insert.length &amp;&amp; fromI &amp;&amp; toI &lt; children.length &amp;&amp; !children[fromI - 1].breakAfter &amp;&amp;</span><span class="s3">\n        </span><span class="s1">children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))</span><span class="s3">\n        </span><span class="s1">fromI--;</span><span class="s3">\n    </span><span class="s1">if (fromI &lt; toI || insert.length)</span><span class="s3">\n        </span><span class="s1">parent.replaceChildren(fromI, toI, insert);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {</span><span class="s3">\n    </span><span class="s1">let cur = parent.childCursor();</span><span class="s3">\n    </span><span class="s1">let { i: toI, off: toOff } = cur.findPos(to, 1);</span><span class="s3">\n    </span><span class="s1">let { i: fromI, off: fromOff } = cur.findPos(from, -1);</span><span class="s3">\n    </span><span class="s1">let dLen = from - to;</span><span class="s3">\n    </span><span class="s1">for (let view of insert)</span><span class="s3">\n        </span><span class="s1">dLen += view.length;</span><span class="s3">\n    </span><span class="s1">parent.length += dLen;</span><span class="s3">\n    </span><span class="s1">replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">let nav = typeof navigator != </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">? navigator : { userAgent: </span><span class="s3">\&quot;\&quot;</span><span class="s1">, vendor: </span><span class="s3">\&quot;\&quot;</span><span class="s1">, platform: </span><span class="s3">\&quot;\&quot; </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">let doc = typeof document != </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">? document : { documentElement: { style: {} } };</span><span class="s3">\n</span><span class="s1">const ie_edge = /*@__PURE__*//Edge</span><span class="s3">\\</span><span class="s1">/(</span><span class="s3">\\</span><span class="s1">d+)/.exec(nav.userAgent);</span><span class="s3">\n</span><span class="s1">const ie_upto10 = /*@__PURE__*//MSIE </span><span class="s3">\\</span><span class="s1">d/.test(nav.userAgent);</span><span class="s3">\n</span><span class="s1">const ie_11up = /*@__PURE__*//Trident</span><span class="s3">\\</span><span class="s1">/(?:[7-9]|</span><span class="s3">\\</span><span class="s1">d{2,})</span><span class="s3">\\</span><span class="s1">..*rv:(</span><span class="s3">\\</span><span class="s1">d+)/.exec(nav.userAgent);</span><span class="s3">\n</span><span class="s1">const ie = !!(ie_upto10 || ie_11up || ie_edge);</span><span class="s3">\n</span><span class="s1">const gecko = !ie &amp;&amp; /*@__PURE__*//gecko</span><span class="s3">\\</span><span class="s1">/(</span><span class="s3">\\</span><span class="s1">d+)/i.test(nav.userAgent);</span><span class="s3">\n</span><span class="s1">const chrome = !ie &amp;&amp; /*@__PURE__*//Chrome</span><span class="s3">\\</span><span class="s1">/(</span><span class="s3">\\</span><span class="s1">d+)/.exec(nav.userAgent);</span><span class="s3">\n</span><span class="s1">const webkit = </span><span class="s3">\&quot;</span><span class="s1">webkitFontSmoothing</span><span class="s3">\&quot; </span><span class="s1">in doc.documentElement.style;</span><span class="s3">\n</span><span class="s1">const safari = !ie &amp;&amp; /*@__PURE__*//Apple Computer/.test(nav.vendor);</span><span class="s3">\n</span><span class="s1">const ios = safari &amp;&amp; (/*@__PURE__*//Mobile</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">w+/.test(nav.userAgent) || nav.maxTouchPoints &gt; 2);</span><span class="s3">\n</span><span class="s1">var browser = {</span><span class="s3">\n    </span><span class="s1">mac: ios || /*@__PURE__*//Mac/.test(nav.platform),</span><span class="s3">\n    </span><span class="s1">windows: /*@__PURE__*//Win/.test(nav.platform),</span><span class="s3">\n    </span><span class="s1">linux: /*@__PURE__*//Linux|X11/.test(nav.platform),</span><span class="s3">\n    </span><span class="s1">ie,</span><span class="s3">\n    </span><span class="s1">ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,</span><span class="s3">\n    </span><span class="s1">gecko,</span><span class="s3">\n    </span><span class="s1">gecko_version: gecko ? +(/*@__PURE__*//Firefox</span><span class="s3">\\</span><span class="s1">/(</span><span class="s3">\\</span><span class="s1">d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,</span><span class="s3">\n    </span><span class="s1">chrome: !!chrome,</span><span class="s3">\n    </span><span class="s1">chrome_version: chrome ? +chrome[1] : 0,</span><span class="s3">\n    </span><span class="s1">ios,</span><span class="s3">\n    </span><span class="s1">android: /*@__PURE__*//Android</span><span class="s3">\\</span><span class="s1">b/.test(nav.userAgent),</span><span class="s3">\n    </span><span class="s1">webkit,</span><span class="s3">\n    </span><span class="s1">safari,</span><span class="s3">\n    </span><span class="s1">webkit_version: webkit ? +(/*@__PURE__*//</span><span class="s3">\\</span><span class="s1">bAppleWebKit</span><span class="s3">\\</span><span class="s1">/(</span><span class="s3">\\</span><span class="s1">d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,</span><span class="s3">\n    </span><span class="s1">tabSize: doc.documentElement.style.tabSize != null ? </span><span class="s3">\&quot;</span><span class="s1">tab-size</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">-moz-tab-size</span><span class="s3">\&quot;\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const MaxJoinLen = 256;</span><span class="s3">\n</span><span class="s1">class TextView extends ContentView {</span><span class="s3">\n    </span><span class="s1">constructor(text) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.text = text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get length() { return this.text.length; }</span><span class="s3">\n    </span><span class="s1">createDOM(textDOM) {</span><span class="s3">\n        </span><span class="s1">this.setDOM(textDOM || document.createTextNode(this.text));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">sync(view, track) {</span><span class="s3">\n        </span><span class="s1">if (!this.dom)</span><span class="s3">\n            </span><span class="s1">this.createDOM();</span><span class="s3">\n        </span><span class="s1">if (this.dom.nodeValue != this.text) {</span><span class="s3">\n            </span><span class="s1">if (track &amp;&amp; track.node == this.dom)</span><span class="s3">\n                </span><span class="s1">track.written = true;</span><span class="s3">\n            </span><span class="s1">this.dom.nodeValue = this.text;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">reuseDOM(dom) {</span><span class="s3">\n        </span><span class="s1">if (dom.nodeType == 3)</span><span class="s3">\n            </span><span class="s1">this.createDOM(dom);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">merge(from, to, source) {</span><span class="s3">\n        </span><span class="s1">if ((this.flags &amp; 8 /* ViewFlag.Composition */) ||</span><span class="s3">\n            </span><span class="s1">source &amp;&amp; (!(source instanceof TextView) ||</span><span class="s3">\n                </span><span class="s1">this.length - (to - from) + source.length &gt; MaxJoinLen ||</span><span class="s3">\n                </span><span class="s1">(source.flags &amp; 8 /* ViewFlag.Composition */)))</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">this.text = this.text.slice(0, from) + (source ? source.text : </span><span class="s3">\&quot;\&quot;</span><span class="s1">) + this.text.slice(to);</span><span class="s3">\n        </span><span class="s1">this.markDirty();</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">split(from) {</span><span class="s3">\n        </span><span class="s1">let result = new TextView(this.text.slice(from));</span><span class="s3">\n        </span><span class="s1">this.text = this.text.slice(0, from);</span><span class="s3">\n        </span><span class="s1">this.markDirty();</span><span class="s3">\n        </span><span class="s1">result.flags |= this.flags &amp; 8 /* ViewFlag.Composition */;</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">localPosFromDOM(node, offset) {</span><span class="s3">\n        </span><span class="s1">return node == this.dom ? offset : offset ? this.text.length : 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">domAtPos(pos) { return new DOMPos(this.dom, pos); }</span><span class="s3">\n    </span><span class="s1">domBoundsAround(_from, _to, offset) {</span><span class="s3">\n        </span><span class="s1">return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">coordsAt(pos, side) {</span><span class="s3">\n        </span><span class="s1">return textCoords(this.dom, pos, side);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class MarkView extends ContentView {</span><span class="s3">\n    </span><span class="s1">constructor(mark, children = [], length = 0) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.mark = mark;</span><span class="s3">\n        </span><span class="s1">this.children = children;</span><span class="s3">\n        </span><span class="s1">this.length = length;</span><span class="s3">\n        </span><span class="s1">for (let ch of children)</span><span class="s3">\n            </span><span class="s1">ch.setParent(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setAttrs(dom) {</span><span class="s3">\n        </span><span class="s1">clearAttributes(dom);</span><span class="s3">\n        </span><span class="s1">if (this.mark.class)</span><span class="s3">\n            </span><span class="s1">dom.className = this.mark.class;</span><span class="s3">\n        </span><span class="s1">if (this.mark.attrs)</span><span class="s3">\n            </span><span class="s1">for (let name in this.mark.attrs)</span><span class="s3">\n                </span><span class="s1">dom.setAttribute(name, this.mark.attrs[name]);</span><span class="s3">\n        </span><span class="s1">return dom;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">canReuseDOM(other) {</span><span class="s3">\n        </span><span class="s1">return super.canReuseDOM(other) &amp;&amp; !((this.flags | other.flags) &amp; 8 /* ViewFlag.Composition */);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">reuseDOM(node) {</span><span class="s3">\n        </span><span class="s1">if (node.nodeName == this.mark.tagName.toUpperCase()) {</span><span class="s3">\n            </span><span class="s1">this.setDOM(node);</span><span class="s3">\n            </span><span class="s1">this.flags |= 4 /* ViewFlag.AttrsDirty */ | 2 /* ViewFlag.NodeDirty */;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">sync(view, track) {</span><span class="s3">\n        </span><span class="s1">if (!this.dom)</span><span class="s3">\n            </span><span class="s1">this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));</span><span class="s3">\n        </span><span class="s1">else if (this.flags &amp; 4 /* ViewFlag.AttrsDirty */)</span><span class="s3">\n            </span><span class="s1">this.setAttrs(this.dom);</span><span class="s3">\n        </span><span class="s1">super.sync(view, track);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">merge(from, to, source, _hasStart, openStart, openEnd) {</span><span class="s3">\n        </span><span class="s1">if (source &amp;&amp; (!(source instanceof MarkView &amp;&amp; source.mark.eq(this.mark)) ||</span><span class="s3">\n            </span><span class="s1">(from &amp;&amp; openStart &lt;= 0) || (to &lt; this.length &amp;&amp; openEnd &lt;= 0)))</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart - 1, openEnd - 1);</span><span class="s3">\n        </span><span class="s1">this.markDirty();</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">split(from) {</span><span class="s3">\n        </span><span class="s1">let result = [], off = 0, detachFrom = -1, i = 0;</span><span class="s3">\n        </span><span class="s1">for (let elt of this.children) {</span><span class="s3">\n            </span><span class="s1">let end = off + elt.length;</span><span class="s3">\n            </span><span class="s1">if (end &gt; from)</span><span class="s3">\n                </span><span class="s1">result.push(off &lt; from ? elt.split(from - off) : elt);</span><span class="s3">\n            </span><span class="s1">if (detachFrom &lt; 0 &amp;&amp; off &gt;= from)</span><span class="s3">\n                </span><span class="s1">detachFrom = i;</span><span class="s3">\n            </span><span class="s1">off = end;</span><span class="s3">\n            </span><span class="s1">i++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let length = this.length - from;</span><span class="s3">\n        </span><span class="s1">this.length = from;</span><span class="s3">\n        </span><span class="s1">if (detachFrom &gt; -1) {</span><span class="s3">\n            </span><span class="s1">this.children.length = detachFrom;</span><span class="s3">\n            </span><span class="s1">this.markDirty();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new MarkView(this.mark, result, length);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">domAtPos(pos) {</span><span class="s3">\n        </span><span class="s1">return inlineDOMAtPos(this, pos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">coordsAt(pos, side) {</span><span class="s3">\n        </span><span class="s1">return coordsInChildren(this, pos, side);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function textCoords(text, pos, side) {</span><span class="s3">\n    </span><span class="s1">let length = text.nodeValue.length;</span><span class="s3">\n    </span><span class="s1">if (pos &gt; length)</span><span class="s3">\n        </span><span class="s1">pos = length;</span><span class="s3">\n    </span><span class="s1">let from = pos, to = pos, flatten = 0;</span><span class="s3">\n    </span><span class="s1">if (pos == 0 &amp;&amp; side &lt; 0 || pos == length &amp;&amp; side &gt;= 0) {</span><span class="s3">\n        </span><span class="s1">if (!(browser.chrome || browser.gecko)) { // These browsers reliably return valid rectangles for empty ranges</span><span class="s3">\n            </span><span class="s1">if (pos) {</span><span class="s3">\n                </span><span class="s1">from--;</span><span class="s3">\n                </span><span class="s1">flatten = 1;</span><span class="s3">\n            </span><span class="s1">} // FIXME this is wrong in RTL text</span><span class="s3">\n            </span><span class="s1">else if (to &lt; length) {</span><span class="s3">\n                </span><span class="s1">to++;</span><span class="s3">\n                </span><span class="s1">flatten = -1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">if (side &lt; 0)</span><span class="s3">\n            </span><span class="s1">from--;</span><span class="s3">\n        </span><span class="s1">else if (to &lt; length)</span><span class="s3">\n            </span><span class="s1">to++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let rects = textRange(text, from, to).getClientRects();</span><span class="s3">\n    </span><span class="s1">if (!rects.length)</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">let rect = rects[(flatten ? flatten &lt; 0 : side &gt;= 0) ? 0 : rects.length - 1];</span><span class="s3">\n    </span><span class="s1">if (browser.safari &amp;&amp; !flatten &amp;&amp; rect.width == 0)</span><span class="s3">\n        </span><span class="s1">rect = Array.prototype.find.call(rects, r =&gt; r.width) || rect;</span><span class="s3">\n    </span><span class="s1">return flatten ? flattenRect(rect, flatten &lt; 0) : rect || null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Also used for collapsed ranges that don't have a placeholder widget!</span><span class="s3">\n</span><span class="s1">class WidgetView extends ContentView {</span><span class="s3">\n    </span><span class="s1">static create(widget, length, side) {</span><span class="s3">\n        </span><span class="s1">return new WidgetView(widget, length, side);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">constructor(widget, length, side) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.widget = widget;</span><span class="s3">\n        </span><span class="s1">this.length = length;</span><span class="s3">\n        </span><span class="s1">this.side = side;</span><span class="s3">\n        </span><span class="s1">this.prevWidget = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">split(from) {</span><span class="s3">\n        </span><span class="s1">let result = WidgetView.create(this.widget, this.length - from, this.side);</span><span class="s3">\n        </span><span class="s1">this.length -= from;</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">sync(view) {</span><span class="s3">\n        </span><span class="s1">if (!this.dom || !this.widget.updateDOM(this.dom, view)) {</span><span class="s3">\n            </span><span class="s1">if (this.dom &amp;&amp; this.prevWidget)</span><span class="s3">\n                </span><span class="s1">this.prevWidget.destroy(this.dom);</span><span class="s3">\n            </span><span class="s1">this.prevWidget = null;</span><span class="s3">\n            </span><span class="s1">this.setDOM(this.widget.toDOM(view));</span><span class="s3">\n            </span><span class="s1">if (!this.widget.editable)</span><span class="s3">\n                </span><span class="s1">this.dom.contentEditable = </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getSide() { return this.side; }</span><span class="s3">\n    </span><span class="s1">merge(from, to, source, hasStart, openStart, openEnd) {</span><span class="s3">\n        </span><span class="s1">if (source &amp;&amp; (!(source instanceof WidgetView) || !this.widget.compare(source.widget) ||</span><span class="s3">\n            </span><span class="s1">from &gt; 0 &amp;&amp; openStart &lt;= 0 || to &lt; this.length &amp;&amp; openEnd &lt;= 0))</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">this.length = from + (source ? source.length : 0) + (this.length - to);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">become(other) {</span><span class="s3">\n        </span><span class="s1">if (other instanceof WidgetView &amp;&amp; other.side == this.side &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.widget.constructor == other.widget.constructor) {</span><span class="s3">\n            </span><span class="s1">if (!this.widget.compare(other.widget))</span><span class="s3">\n                </span><span class="s1">this.markDirty(true);</span><span class="s3">\n            </span><span class="s1">if (this.dom &amp;&amp; !this.prevWidget)</span><span class="s3">\n                </span><span class="s1">this.prevWidget = this.widget;</span><span class="s3">\n            </span><span class="s1">this.widget = other.widget;</span><span class="s3">\n            </span><span class="s1">this.length = other.length;</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ignoreMutation() { return true; }</span><span class="s3">\n    </span><span class="s1">ignoreEvent(event) { return this.widget.ignoreEvent(event); }</span><span class="s3">\n    </span><span class="s1">get overrideDOMText() {</span><span class="s3">\n        </span><span class="s1">if (this.length == 0)</span><span class="s3">\n            </span><span class="s1">return Text.empty;</span><span class="s3">\n        </span><span class="s1">let top = this;</span><span class="s3">\n        </span><span class="s1">while (top.parent)</span><span class="s3">\n            </span><span class="s1">top = top.parent;</span><span class="s3">\n        </span><span class="s1">let { view } = top, text = view &amp;&amp; view.state.doc, start = this.posAtStart;</span><span class="s3">\n        </span><span class="s1">return text ? text.slice(start, start + this.length) : Text.empty;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">domAtPos(pos) {</span><span class="s3">\n        </span><span class="s1">return (this.length ? pos == 0 : this.side &gt; 0)</span><span class="s3">\n            </span><span class="s1">? DOMPos.before(this.dom)</span><span class="s3">\n            </span><span class="s1">: DOMPos.after(this.dom, pos == this.length);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">domBoundsAround() { return null; }</span><span class="s3">\n    </span><span class="s1">coordsAt(pos, side) {</span><span class="s3">\n        </span><span class="s1">let custom = this.widget.coordsAt(this.dom, pos, side);</span><span class="s3">\n        </span><span class="s1">if (custom)</span><span class="s3">\n            </span><span class="s1">return custom;</span><span class="s3">\n        </span><span class="s1">let rects = this.dom.getClientRects(), rect = null;</span><span class="s3">\n        </span><span class="s1">if (!rects.length)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">let fromBack = this.side ? this.side &lt; 0 : pos &gt; 0;</span><span class="s3">\n        </span><span class="s1">for (let i = fromBack ? rects.length - 1 : 0;; i += (fromBack ? -1 : 1)) {</span><span class="s3">\n            </span><span class="s1">rect = rects[i];</span><span class="s3">\n            </span><span class="s1">if (pos &gt; 0 ? i == 0 : i == rects.length - 1 || rect.top &lt; rect.bottom)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return flattenRect(rect, !fromBack);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get isEditable() { return false; }</span><span class="s3">\n    </span><span class="s1">get isWidget() { return true; }</span><span class="s3">\n    </span><span class="s1">get isHidden() { return this.widget.isHidden; }</span><span class="s3">\n    </span><span class="s1">destroy() {</span><span class="s3">\n        </span><span class="s1">super.destroy();</span><span class="s3">\n        </span><span class="s1">if (this.dom)</span><span class="s3">\n            </span><span class="s1">this.widget.destroy(this.dom);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// These are drawn around uneditable widgets to avoid a number of</span><span class="s3">\n</span><span class="s1">// browser bugs that show up when the cursor is directly next to</span><span class="s3">\n</span><span class="s1">// uneditable inline content.</span><span class="s3">\n</span><span class="s1">class WidgetBufferView extends ContentView {</span><span class="s3">\n    </span><span class="s1">constructor(side) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.side = side;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get length() { return 0; }</span><span class="s3">\n    </span><span class="s1">merge() { return false; }</span><span class="s3">\n    </span><span class="s1">become(other) {</span><span class="s3">\n        </span><span class="s1">return other instanceof WidgetBufferView &amp;&amp; other.side == this.side;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">split() { return new WidgetBufferView(this.side); }</span><span class="s3">\n    </span><span class="s1">sync() {</span><span class="s3">\n        </span><span class="s1">if (!this.dom) {</span><span class="s3">\n            </span><span class="s1">let dom = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">img</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">dom.className = </span><span class="s3">\&quot;</span><span class="s1">cm-widgetBuffer</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">dom.setAttribute(</span><span class="s3">\&quot;</span><span class="s1">aria-hidden</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">this.setDOM(dom);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getSide() { return this.side; }</span><span class="s3">\n    </span><span class="s1">domAtPos(pos) { return this.side &gt; 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom); }</span><span class="s3">\n    </span><span class="s1">localPosFromDOM() { return 0; }</span><span class="s3">\n    </span><span class="s1">domBoundsAround() { return null; }</span><span class="s3">\n    </span><span class="s1">coordsAt(pos) {</span><span class="s3">\n        </span><span class="s1">return this.dom.getBoundingClientRect();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get overrideDOMText() {</span><span class="s3">\n        </span><span class="s1">return Text.empty;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get isHidden() { return true; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;</span><span class="s3">\n</span><span class="s1">function inlineDOMAtPos(parent, pos) {</span><span class="s3">\n    </span><span class="s1">let dom = parent.dom, { children } = parent, i = 0;</span><span class="s3">\n    </span><span class="s1">for (let off = 0; i &lt; children.length; i++) {</span><span class="s3">\n        </span><span class="s1">let child = children[i], end = off + child.length;</span><span class="s3">\n        </span><span class="s1">if (end == off &amp;&amp; child.getSide() &lt;= 0)</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">if (pos &gt; off &amp;&amp; pos &lt; end &amp;&amp; child.dom.parentNode == dom)</span><span class="s3">\n            </span><span class="s1">return child.domAtPos(pos - off);</span><span class="s3">\n        </span><span class="s1">if (pos &lt;= off)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">off = end;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (let j = i; j &gt; 0; j--) {</span><span class="s3">\n        </span><span class="s1">let prev = children[j - 1];</span><span class="s3">\n        </span><span class="s1">if (prev.dom.parentNode == dom)</span><span class="s3">\n            </span><span class="s1">return prev.domAtPos(prev.length);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (let j = i; j &lt; children.length; j++) {</span><span class="s3">\n        </span><span class="s1">let next = children[j];</span><span class="s3">\n        </span><span class="s1">if (next.dom.parentNode == dom)</span><span class="s3">\n            </span><span class="s1">return next.domAtPos(0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return new DOMPos(dom, 0);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Assumes `view`, if a mark view, has precisely 1 child.</span><span class="s3">\n</span><span class="s1">function joinInlineInto(parent, view, open) {</span><span class="s3">\n    </span><span class="s1">let last, { children } = parent;</span><span class="s3">\n    </span><span class="s1">if (open &gt; 0 &amp;&amp; view instanceof MarkView &amp;&amp; children.length &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(last = children[children.length - 1]) instanceof MarkView &amp;&amp; last.mark.eq(view.mark)) {</span><span class="s3">\n        </span><span class="s1">joinInlineInto(last, view.children[0], open - 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">children.push(view);</span><span class="s3">\n        </span><span class="s1">view.setParent(parent);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">parent.length += view.length;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function coordsInChildren(view, pos, side) {</span><span class="s3">\n    </span><span class="s1">let before = null, beforePos = -1, after = null, afterPos = -1;</span><span class="s3">\n    </span><span class="s1">function scan(view, pos) {</span><span class="s3">\n        </span><span class="s1">for (let i = 0, off = 0; i &lt; view.children.length &amp;&amp; off &lt;= pos; i++) {</span><span class="s3">\n            </span><span class="s1">let child = view.children[i], end = off + child.length;</span><span class="s3">\n            </span><span class="s1">if (end &gt;= pos) {</span><span class="s3">\n                </span><span class="s1">if (child.children.length) {</span><span class="s3">\n                    </span><span class="s1">scan(child, pos - off);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if ((!after || after.isHidden &amp;&amp; side &gt; 0) &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">(end &gt; pos || off == end &amp;&amp; child.getSide() &gt; 0)) {</span><span class="s3">\n                    </span><span class="s1">after = child;</span><span class="s3">\n                    </span><span class="s1">afterPos = pos - off;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (off &lt; pos || (off == end &amp;&amp; child.getSide() &lt; 0) &amp;&amp; !child.isHidden) {</span><span class="s3">\n                    </span><span class="s1">before = child;</span><span class="s3">\n                    </span><span class="s1">beforePos = pos - off;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">off = end;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scan(view, pos);</span><span class="s3">\n    </span><span class="s1">let target = (side &lt; 0 ? before : after) || before || after;</span><span class="s3">\n    </span><span class="s1">if (target)</span><span class="s3">\n        </span><span class="s1">return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);</span><span class="s3">\n    </span><span class="s1">return fallbackRect(view);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function fallbackRect(view) {</span><span class="s3">\n    </span><span class="s1">let last = view.dom.lastChild;</span><span class="s3">\n    </span><span class="s1">if (!last)</span><span class="s3">\n        </span><span class="s1">return view.dom.getBoundingClientRect();</span><span class="s3">\n    </span><span class="s1">let rects = clientRectsFor(last);</span><span class="s3">\n    </span><span class="s1">return rects[rects.length - 1] || null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function combineAttrs(source, target) {</span><span class="s3">\n    </span><span class="s1">for (let name in source) {</span><span class="s3">\n        </span><span class="s1">if (name == </span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; target.class)</span><span class="s3">\n            </span><span class="s1">target.class += </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ source.class;</span><span class="s3">\n        </span><span class="s1">else if (name == </span><span class="s3">\&quot;</span><span class="s1">style</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; target.style)</span><span class="s3">\n            </span><span class="s1">target.style += </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot; </span><span class="s1">+ source.style;</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">target[name] = source[name];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return target;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const noAttrs = /*@__PURE__*/Object.create(null);</span><span class="s3">\n</span><span class="s1">function attrsEq(a, b, ignore) {</span><span class="s3">\n    </span><span class="s1">if (a == b)</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">if (!a)</span><span class="s3">\n        </span><span class="s1">a = noAttrs;</span><span class="s3">\n    </span><span class="s1">if (!b)</span><span class="s3">\n        </span><span class="s1">b = noAttrs;</span><span class="s3">\n    </span><span class="s1">let keysA = Object.keys(a), keysB = Object.keys(b);</span><span class="s3">\n    </span><span class="s1">if (keysA.length - (ignore &amp;&amp; keysA.indexOf(ignore) &gt; -1 ? 1 : 0) !=</span><span class="s3">\n        </span><span class="s1">keysB.length - (ignore &amp;&amp; keysB.indexOf(ignore) &gt; -1 ? 1 : 0))</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">for (let key of keysA) {</span><span class="s3">\n        </span><span class="s1">if (key != ignore &amp;&amp; (keysB.indexOf(key) == -1 || a[key] !== b[key]))</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function updateAttrs(dom, prev, attrs) {</span><span class="s3">\n    </span><span class="s1">let changed = false;</span><span class="s3">\n    </span><span class="s1">if (prev)</span><span class="s3">\n        </span><span class="s1">for (let name in prev)</span><span class="s3">\n            </span><span class="s1">if (!(attrs &amp;&amp; name in attrs)) {</span><span class="s3">\n                </span><span class="s1">changed = true;</span><span class="s3">\n                </span><span class="s1">if (name == </span><span class="s3">\&quot;</span><span class="s1">style</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                    </span><span class="s1">dom.style.cssText = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">dom.removeAttribute(name);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (attrs)</span><span class="s3">\n        </span><span class="s1">for (let name in attrs)</span><span class="s3">\n            </span><span class="s1">if (!(prev &amp;&amp; prev[name] == attrs[name])) {</span><span class="s3">\n                </span><span class="s1">changed = true;</span><span class="s3">\n                </span><span class="s1">if (name == </span><span class="s3">\&quot;</span><span class="s1">style</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                    </span><span class="s1">dom.style.cssText = attrs[name];</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">dom.setAttribute(name, attrs[name]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return changed;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getAttrs(dom) {</span><span class="s3">\n    </span><span class="s1">let attrs = Object.create(null);</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; dom.attributes.length; i++) {</span><span class="s3">\n        </span><span class="s1">let attr = dom.attributes[i];</span><span class="s3">\n        </span><span class="s1">attrs[attr.name] = attr.value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return attrs;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Widgets added to the content are described by subclasses of this</span><span class="s3">\n</span><span class="s1">class. Using a description object like that makes it possible to</span><span class="s3">\n</span><span class="s1">delay creating of the DOM structure for a widget until it is</span><span class="s3">\n</span><span class="s1">needed, and to avoid redrawing widgets even if the decorations</span><span class="s3">\n</span><span class="s1">that define them are recreated.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class WidgetType {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Compare this instance to another instance of the same type.</span><span class="s3">\n    </span><span class="s1">(TypeScript can't express this, but only instances of the same</span><span class="s3">\n    </span><span class="s1">specific class will be passed to this method.) This is used to</span><span class="s3">\n    </span><span class="s1">avoid redrawing widgets when they are replaced by a new</span><span class="s3">\n    </span><span class="s1">decoration of the same type. The default implementation just</span><span class="s3">\n    </span><span class="s1">returns `false`, which will cause new instances of the widget to</span><span class="s3">\n    </span><span class="s1">always be redrawn.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">eq(widget) { return false; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Update a DOM element created by a widget of the same type (but</span><span class="s3">\n    </span><span class="s1">different, non-`eq` content) to reflect this widget. May return</span><span class="s3">\n    </span><span class="s1">true to indicate that it could update, false to indicate it</span><span class="s3">\n    </span><span class="s1">couldn't (in which case the widget will be redrawn). The default</span><span class="s3">\n    </span><span class="s1">implementation just returns false.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">updateDOM(dom, view) { return false; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">compare(other) {</span><span class="s3">\n        </span><span class="s1">return this == other || this.constructor == other.constructor &amp;&amp; this.eq(other);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The estimated height this widget will have, to be used when</span><span class="s3">\n    </span><span class="s1">estimating the height of content that hasn't been drawn. May</span><span class="s3">\n    </span><span class="s1">return -1 to indicate you don't know. The default implementation</span><span class="s3">\n    </span><span class="s1">returns -1.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get estimatedHeight() { return -1; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">For inline widgets that are displayed inline (as opposed to</span><span class="s3">\n    </span><span class="s1">`inline-block`) and introduce line breaks (through `&lt;br&gt;` tags</span><span class="s3">\n    </span><span class="s1">or textual newlines), this must indicate the amount of line</span><span class="s3">\n    </span><span class="s1">breaks they introduce. Defaults to 0.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get lineBreaks() { return 0; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Can be used to configure which kinds of events inside the widget</span><span class="s3">\n    </span><span class="s1">should be ignored by the editor. The default is to ignore all</span><span class="s3">\n    </span><span class="s1">events.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">ignoreEvent(event) { return true; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Override the way screen coordinates for positions at/in the</span><span class="s3">\n    </span><span class="s1">widget are found. `pos` will be the offset into the widget, and</span><span class="s3">\n    </span><span class="s1">`side` the side of the position that is being queriedless than</span><span class="s3">\n    </span><span class="s1">zero for before, greater than zero for after, and zero for</span><span class="s3">\n    </span><span class="s1">directly at that position.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">coordsAt(dom, pos, side) { return null; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get isHidden() { return false; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get editable() { return false; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">This is called when the an instance of the widget is removed</span><span class="s3">\n    </span><span class="s1">from the editor view.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">destroy(dom) { }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The different types of blocks that can occur in an editor view.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var BlockType = /*@__PURE__*/(function (BlockType) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A line of text.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">BlockType[BlockType[</span><span class="s3">\&quot;</span><span class="s1">Text</span><span class="s3">\&quot;</span><span class="s1">] = 0] = </span><span class="s3">\&quot;</span><span class="s1">Text</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A block widget associated with the position after it.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">BlockType[BlockType[</span><span class="s3">\&quot;</span><span class="s1">WidgetBefore</span><span class="s3">\&quot;</span><span class="s1">] = 1] = </span><span class="s3">\&quot;</span><span class="s1">WidgetBefore</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A block widget associated with the position before it.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">BlockType[BlockType[</span><span class="s3">\&quot;</span><span class="s1">WidgetAfter</span><span class="s3">\&quot;</span><span class="s1">] = 2] = </span><span class="s3">\&quot;</span><span class="s1">WidgetAfter</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">BlockType[BlockType[</span><span class="s3">\&quot;</span><span class="s1">WidgetRange</span><span class="s3">\&quot;</span><span class="s1">] = 3] = </span><span class="s3">\&quot;</span><span class="s1">WidgetRange</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">return BlockType})(BlockType || (BlockType = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A decoration provides information on how to draw or style a piece</span><span class="s3">\n</span><span class="s1">of content. You'll usually use it wrapped in a</span><span class="s3">\n</span><span class="s1">[`Range`](https://codemirror.net/6/docs/ref/#state.Range), which adds a start and end position.</span><span class="s3">\n</span><span class="s1">@nonabstract</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class Decoration extends RangeValue {</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">startSide, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">endSide, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">widget, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The config object used to create this decoration. You can</span><span class="s3">\n    </span><span class="s1">include additional properties in there to store metadata about</span><span class="s3">\n    </span><span class="s1">your decoration.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">spec) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.startSide = startSide;</span><span class="s3">\n        </span><span class="s1">this.endSide = endSide;</span><span class="s3">\n        </span><span class="s1">this.widget = widget;</span><span class="s3">\n        </span><span class="s1">this.spec = spec;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get heightRelevant() { return false; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a mark decoration, which influences the styling of the</span><span class="s3">\n    </span><span class="s1">content in its range. Nested mark decorations will cause nested</span><span class="s3">\n    </span><span class="s1">DOM elements to be created. Nesting order is determined by</span><span class="s3">\n    </span><span class="s1">precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with</span><span class="s3">\n    </span><span class="s1">the higher-precedence decorations creating the inner DOM nodes.</span><span class="s3">\n    </span><span class="s1">Such elements are split on line boundaries and on the boundaries</span><span class="s3">\n    </span><span class="s1">of lower-precedence decorations.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static mark(spec) {</span><span class="s3">\n        </span><span class="s1">return new MarkDecoration(spec);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a widget decoration, which displays a DOM element at the</span><span class="s3">\n    </span><span class="s1">given position.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static widget(spec) {</span><span class="s3">\n        </span><span class="s1">let side = Math.max(-10000, Math.min(10000, spec.side || 0)), block = !!spec.block;</span><span class="s3">\n        </span><span class="s1">side += (block &amp;&amp; !spec.inlineOrder)</span><span class="s3">\n            </span><span class="s1">? (side &gt; 0 ? 300000000 /* Side.BlockAfter */ : -400000000 /* Side.BlockBefore */)</span><span class="s3">\n            </span><span class="s1">: (side &gt; 0 ? 100000000 /* Side.InlineAfter */ : -100000000 /* Side.InlineBefore */);</span><span class="s3">\n        </span><span class="s1">return new PointDecoration(spec, side, side, block, spec.widget || null, false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a replace decoration which replaces the given range with</span><span class="s3">\n    </span><span class="s1">a widget, or simply hides it.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static replace(spec) {</span><span class="s3">\n        </span><span class="s1">let block = !!spec.block, startSide, endSide;</span><span class="s3">\n        </span><span class="s1">if (spec.isBlockGap) {</span><span class="s3">\n            </span><span class="s1">startSide = -500000000 /* Side.GapStart */;</span><span class="s3">\n            </span><span class="s1">endSide = 400000000 /* Side.GapEnd */;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let { start, end } = getInclusive(spec, block);</span><span class="s3">\n            </span><span class="s1">startSide = (start ? (block ? -300000000 /* Side.BlockIncStart */ : -1 /* Side.InlineIncStart */) : 500000000 /* Side.NonIncStart */) - 1;</span><span class="s3">\n            </span><span class="s1">endSide = (end ? (block ? 200000000 /* Side.BlockIncEnd */ : 1 /* Side.InlineIncEnd */) : -600000000 /* Side.NonIncEnd */) + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a line decoration, which can add DOM attributes to the</span><span class="s3">\n    </span><span class="s1">line starting at the given position.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static line(spec) {</span><span class="s3">\n        </span><span class="s1">return new LineDecoration(spec);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given</span><span class="s3">\n    </span><span class="s1">decorated range or ranges. If the ranges aren't already sorted,</span><span class="s3">\n    </span><span class="s1">pass `true` for `sort` to make the library sort them for you.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static set(of, sort = false) {</span><span class="s3">\n        </span><span class="s1">return RangeSet.of(of, sort);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">hasHeight() { return this.widget ? this.widget.estimatedHeight &gt; -1 : false; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The empty set of decorations.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Decoration.none = RangeSet.empty;</span><span class="s3">\n</span><span class="s1">class MarkDecoration extends Decoration {</span><span class="s3">\n    </span><span class="s1">constructor(spec) {</span><span class="s3">\n        </span><span class="s1">let { start, end } = getInclusive(spec);</span><span class="s3">\n        </span><span class="s1">super(start ? -1 /* Side.InlineIncStart */ : 500000000 /* Side.NonIncStart */, end ? 1 /* Side.InlineIncEnd */ : -600000000 /* Side.NonIncEnd */, null, spec);</span><span class="s3">\n        </span><span class="s1">this.tagName = spec.tagName || </span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.class = spec.class || </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.attrs = spec.attributes || null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(other) {</span><span class="s3">\n        </span><span class="s1">var _a, _b;</span><span class="s3">\n        </span><span class="s1">return this == other ||</span><span class="s3">\n            </span><span class="s1">other instanceof MarkDecoration &amp;&amp;</span><span class="s3">\n                </span><span class="s1">this.tagName == other.tagName &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(this.class || ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">attrsEq(this.attrs, other.attrs, </span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">range(from, to = from) {</span><span class="s3">\n        </span><span class="s1">if (from &gt;= to)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Mark decorations may not be empty</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return super.range(from, to);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">MarkDecoration.prototype.point = false;</span><span class="s3">\n</span><span class="s1">class LineDecoration extends Decoration {</span><span class="s3">\n    </span><span class="s1">constructor(spec) {</span><span class="s3">\n        </span><span class="s1">super(-200000000 /* Side.Line */, -200000000 /* Side.Line */, null, spec);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(other) {</span><span class="s3">\n        </span><span class="s1">return other instanceof LineDecoration &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.spec.class == other.spec.class &amp;&amp;</span><span class="s3">\n            </span><span class="s1">attrsEq(this.spec.attributes, other.spec.attributes);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">range(from, to = from) {</span><span class="s3">\n        </span><span class="s1">if (to != from)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Line decoration ranges must be zero-length</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return super.range(from, to);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">LineDecoration.prototype.mapMode = MapMode.TrackBefore;</span><span class="s3">\n</span><span class="s1">LineDecoration.prototype.point = true;</span><span class="s3">\n</span><span class="s1">class PointDecoration extends Decoration {</span><span class="s3">\n    </span><span class="s1">constructor(spec, startSide, endSide, block, widget, isReplace) {</span><span class="s3">\n        </span><span class="s1">super(startSide, endSide, widget, spec);</span><span class="s3">\n        </span><span class="s1">this.block = block;</span><span class="s3">\n        </span><span class="s1">this.isReplace = isReplace;</span><span class="s3">\n        </span><span class="s1">this.mapMode = !block ? MapMode.TrackDel : startSide &lt;= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Only relevant when this.block == true</span><span class="s3">\n    </span><span class="s1">get type() {</span><span class="s3">\n        </span><span class="s1">return this.startSide != this.endSide ? BlockType.WidgetRange</span><span class="s3">\n            </span><span class="s1">: this.startSide &lt;= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get heightRelevant() {</span><span class="s3">\n        </span><span class="s1">return this.block || !!this.widget &amp;&amp; (this.widget.estimatedHeight &gt;= 5 || this.widget.lineBreaks &gt; 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(other) {</span><span class="s3">\n        </span><span class="s1">return other instanceof PointDecoration &amp;&amp;</span><span class="s3">\n            </span><span class="s1">widgetsEq(this.widget, other.widget) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.block == other.block &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.startSide == other.startSide &amp;&amp; this.endSide == other.endSide;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">range(from, to = from) {</span><span class="s3">\n        </span><span class="s1">if (this.isReplace &amp;&amp; (from &gt; to || (from == to &amp;&amp; this.startSide &gt; 0 &amp;&amp; this.endSide &lt;= 0)))</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Invalid range for replacement decoration</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (!this.isReplace &amp;&amp; to != from)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Widget decorations can only have zero-length ranges</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return super.range(from, to);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">PointDecoration.prototype.point = true;</span><span class="s3">\n</span><span class="s1">function getInclusive(spec, block = false) {</span><span class="s3">\n    </span><span class="s1">let { inclusiveStart: start, inclusiveEnd: end } = spec;</span><span class="s3">\n    </span><span class="s1">if (start == null)</span><span class="s3">\n        </span><span class="s1">start = spec.inclusive;</span><span class="s3">\n    </span><span class="s1">if (end == null)</span><span class="s3">\n        </span><span class="s1">end = spec.inclusive;</span><span class="s3">\n    </span><span class="s1">return { start: start !== null &amp;&amp; start !== void 0 ? start : block, end: end !== null &amp;&amp; end !== void 0 ? end : block };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function widgetsEq(a, b) {</span><span class="s3">\n    </span><span class="s1">return a == b || !!(a &amp;&amp; b &amp;&amp; a.compare(b));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addRange(from, to, ranges, margin = 0) {</span><span class="s3">\n    </span><span class="s1">let last = ranges.length - 1;</span><span class="s3">\n    </span><span class="s1">if (last &gt;= 0 &amp;&amp; ranges[last] + margin &gt;= from)</span><span class="s3">\n        </span><span class="s1">ranges[last] = Math.max(ranges[last], to);</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">ranges.push(from, to);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class LineView extends ContentView {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.children = [];</span><span class="s3">\n        </span><span class="s1">this.length = 0;</span><span class="s3">\n        </span><span class="s1">this.prevAttrs = undefined;</span><span class="s3">\n        </span><span class="s1">this.attrs = null;</span><span class="s3">\n        </span><span class="s1">this.breakAfter = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Consumes source</span><span class="s3">\n    </span><span class="s1">merge(from, to, source, hasStart, openStart, openEnd) {</span><span class="s3">\n        </span><span class="s1">if (source) {</span><span class="s3">\n            </span><span class="s1">if (!(source instanceof LineView))</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">if (!this.dom)</span><span class="s3">\n                </span><span class="s1">source.transferDOM(this); // Reuse source.dom when appropriate</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (hasStart)</span><span class="s3">\n            </span><span class="s1">this.setDeco(source ? source.attrs : null);</span><span class="s3">\n        </span><span class="s1">mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart, openEnd);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">split(at) {</span><span class="s3">\n        </span><span class="s1">let end = new LineView;</span><span class="s3">\n        </span><span class="s1">end.breakAfter = this.breakAfter;</span><span class="s3">\n        </span><span class="s1">if (this.length == 0)</span><span class="s3">\n            </span><span class="s1">return end;</span><span class="s3">\n        </span><span class="s1">let { i, off } = this.childPos(at);</span><span class="s3">\n        </span><span class="s1">if (off) {</span><span class="s3">\n            </span><span class="s1">end.append(this.children[i].split(off), 0);</span><span class="s3">\n            </span><span class="s1">this.children[i].merge(off, this.children[i].length, null, false, 0, 0);</span><span class="s3">\n            </span><span class="s1">i++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let j = i; j &lt; this.children.length; j++)</span><span class="s3">\n            </span><span class="s1">end.append(this.children[j], 0);</span><span class="s3">\n        </span><span class="s1">while (i &gt; 0 &amp;&amp; this.children[i - 1].length == 0)</span><span class="s3">\n            </span><span class="s1">this.children[--i].destroy();</span><span class="s3">\n        </span><span class="s1">this.children.length = i;</span><span class="s3">\n        </span><span class="s1">this.markDirty();</span><span class="s3">\n        </span><span class="s1">this.length = at;</span><span class="s3">\n        </span><span class="s1">return end;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">transferDOM(other) {</span><span class="s3">\n        </span><span class="s1">if (!this.dom)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">this.markDirty();</span><span class="s3">\n        </span><span class="s1">other.setDOM(this.dom);</span><span class="s3">\n        </span><span class="s1">other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;</span><span class="s3">\n        </span><span class="s1">this.prevAttrs = undefined;</span><span class="s3">\n        </span><span class="s1">this.dom = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setDeco(attrs) {</span><span class="s3">\n        </span><span class="s1">if (!attrsEq(this.attrs, attrs)) {</span><span class="s3">\n            </span><span class="s1">if (this.dom) {</span><span class="s3">\n                </span><span class="s1">this.prevAttrs = this.attrs;</span><span class="s3">\n                </span><span class="s1">this.markDirty();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.attrs = attrs;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">append(child, openStart) {</span><span class="s3">\n        </span><span class="s1">joinInlineInto(this, child, openStart);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Only called when building a line view in ContentBuilder</span><span class="s3">\n    </span><span class="s1">addLineDeco(deco) {</span><span class="s3">\n        </span><span class="s1">let attrs = deco.spec.attributes, cls = deco.spec.class;</span><span class="s3">\n        </span><span class="s1">if (attrs)</span><span class="s3">\n            </span><span class="s1">this.attrs = combineAttrs(attrs, this.attrs || {});</span><span class="s3">\n        </span><span class="s1">if (cls)</span><span class="s3">\n            </span><span class="s1">this.attrs = combineAttrs({ class: cls }, this.attrs || {});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">domAtPos(pos) {</span><span class="s3">\n        </span><span class="s1">return inlineDOMAtPos(this, pos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">reuseDOM(node) {</span><span class="s3">\n        </span><span class="s1">if (node.nodeName == </span><span class="s3">\&quot;</span><span class="s1">DIV</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">this.setDOM(node);</span><span class="s3">\n            </span><span class="s1">this.flags |= 4 /* ViewFlag.AttrsDirty */ | 2 /* ViewFlag.NodeDirty */;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">sync(view, track) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">if (!this.dom) {</span><span class="s3">\n            </span><span class="s1">this.setDOM(document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n            </span><span class="s1">this.dom.className = </span><span class="s3">\&quot;</span><span class="s1">cm-line</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">this.prevAttrs = this.attrs ? null : undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (this.flags &amp; 4 /* ViewFlag.AttrsDirty */) {</span><span class="s3">\n            </span><span class="s1">clearAttributes(this.dom);</span><span class="s3">\n            </span><span class="s1">this.dom.className = </span><span class="s3">\&quot;</span><span class="s1">cm-line</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">this.prevAttrs = this.attrs ? null : undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.prevAttrs !== undefined) {</span><span class="s3">\n            </span><span class="s1">updateAttrs(this.dom, this.prevAttrs, this.attrs);</span><span class="s3">\n            </span><span class="s1">this.dom.classList.add(</span><span class="s3">\&quot;</span><span class="s1">cm-line</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">this.prevAttrs = undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">super.sync(view, track);</span><span class="s3">\n        </span><span class="s1">let last = this.dom.lastChild;</span><span class="s3">\n        </span><span class="s1">while (last &amp;&amp; ContentView.get(last) instanceof MarkView)</span><span class="s3">\n            </span><span class="s1">last = last.lastChild;</span><span class="s3">\n        </span><span class="s1">if (!last || !this.length ||</span><span class="s3">\n            </span><span class="s1">last.nodeName != </span><span class="s3">\&quot;</span><span class="s1">BR</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(!browser.ios || !this.children.some(ch =&gt; ch instanceof TextView))) {</span><span class="s3">\n            </span><span class="s1">let hack = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">BR</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">hack.cmIgnore = true;</span><span class="s3">\n            </span><span class="s1">this.dom.appendChild(hack);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">measureTextSize() {</span><span class="s3">\n        </span><span class="s1">if (this.children.length == 0 || this.length &gt; 20)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">let totalWidth = 0, textHeight;</span><span class="s3">\n        </span><span class="s1">for (let child of this.children) {</span><span class="s3">\n            </span><span class="s1">if (!(child instanceof TextView) || /[^ -~]/.test(child.text))</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">let rects = clientRectsFor(child.dom);</span><span class="s3">\n            </span><span class="s1">if (rects.length != 1)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">totalWidth += rects[0].width;</span><span class="s3">\n            </span><span class="s1">textHeight = rects[0].height;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return !totalWidth ? null : {</span><span class="s3">\n            </span><span class="s1">lineHeight: this.dom.getBoundingClientRect().height,</span><span class="s3">\n            </span><span class="s1">charWidth: totalWidth / this.length,</span><span class="s3">\n            </span><span class="s1">textHeight</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">coordsAt(pos, side) {</span><span class="s3">\n        </span><span class="s1">let rect = coordsInChildren(this, pos, side);</span><span class="s3">\n        </span><span class="s1">// Correct rectangle height for empty lines when the returned</span><span class="s3">\n        </span><span class="s1">// height is larger than the text height.</span><span class="s3">\n        </span><span class="s1">if (!this.children.length &amp;&amp; rect &amp;&amp; this.parent) {</span><span class="s3">\n            </span><span class="s1">let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;</span><span class="s3">\n            </span><span class="s1">if (Math.abs(height - heightOracle.lineHeight) &lt; 2 &amp;&amp; heightOracle.textHeight &lt; height) {</span><span class="s3">\n                </span><span class="s1">let dist = (height - heightOracle.textHeight) / 2;</span><span class="s3">\n                </span><span class="s1">return { top: rect.top + dist, bottom: rect.bottom - dist, left: rect.left, right: rect.left };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return rect;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">become(other) {</span><span class="s3">\n        </span><span class="s1">return other instanceof LineView &amp;&amp; this.children.length == 0 &amp;&amp; other.children.length == 0 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">attrsEq(this.attrs, other.attrs) &amp;&amp; this.breakAfter == other.breakAfter;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">covers() { return true; }</span><span class="s3">\n    </span><span class="s1">static find(docView, pos) {</span><span class="s3">\n        </span><span class="s1">for (let i = 0, off = 0; i &lt; docView.children.length; i++) {</span><span class="s3">\n            </span><span class="s1">let block = docView.children[i], end = off + block.length;</span><span class="s3">\n            </span><span class="s1">if (end &gt;= pos) {</span><span class="s3">\n                </span><span class="s1">if (block instanceof LineView)</span><span class="s3">\n                    </span><span class="s1">return block;</span><span class="s3">\n                </span><span class="s1">if (end &gt; pos)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">off = end + block.breakAfter;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class BlockWidgetView extends ContentView {</span><span class="s3">\n    </span><span class="s1">constructor(widget, length, deco) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.widget = widget;</span><span class="s3">\n        </span><span class="s1">this.length = length;</span><span class="s3">\n        </span><span class="s1">this.deco = deco;</span><span class="s3">\n        </span><span class="s1">this.breakAfter = 0;</span><span class="s3">\n        </span><span class="s1">this.prevWidget = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">merge(from, to, source, _takeDeco, openStart, openEnd) {</span><span class="s3">\n        </span><span class="s1">if (source &amp;&amp; (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) ||</span><span class="s3">\n            </span><span class="s1">from &gt; 0 &amp;&amp; openStart &lt;= 0 || to &lt; this.length &amp;&amp; openEnd &lt;= 0))</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">this.length = from + (source ? source.length : 0) + (this.length - to);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">domAtPos(pos) {</span><span class="s3">\n        </span><span class="s1">return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">split(at) {</span><span class="s3">\n        </span><span class="s1">let len = this.length - at;</span><span class="s3">\n        </span><span class="s1">this.length = at;</span><span class="s3">\n        </span><span class="s1">let end = new BlockWidgetView(this.widget, len, this.deco);</span><span class="s3">\n        </span><span class="s1">end.breakAfter = this.breakAfter;</span><span class="s3">\n        </span><span class="s1">return end;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get children() { return noChildren; }</span><span class="s3">\n    </span><span class="s1">sync(view) {</span><span class="s3">\n        </span><span class="s1">if (!this.dom || !this.widget.updateDOM(this.dom, view)) {</span><span class="s3">\n            </span><span class="s1">if (this.dom &amp;&amp; this.prevWidget)</span><span class="s3">\n                </span><span class="s1">this.prevWidget.destroy(this.dom);</span><span class="s3">\n            </span><span class="s1">this.prevWidget = null;</span><span class="s3">\n            </span><span class="s1">this.setDOM(this.widget.toDOM(view));</span><span class="s3">\n            </span><span class="s1">if (!this.widget.editable)</span><span class="s3">\n                </span><span class="s1">this.dom.contentEditable = </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get overrideDOMText() {</span><span class="s3">\n        </span><span class="s1">return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">domBoundsAround() { return null; }</span><span class="s3">\n    </span><span class="s1">become(other) {</span><span class="s3">\n        </span><span class="s1">if (other instanceof BlockWidgetView &amp;&amp;</span><span class="s3">\n            </span><span class="s1">other.widget.constructor == this.widget.constructor) {</span><span class="s3">\n            </span><span class="s1">if (!other.widget.compare(this.widget))</span><span class="s3">\n                </span><span class="s1">this.markDirty(true);</span><span class="s3">\n            </span><span class="s1">if (this.dom &amp;&amp; !this.prevWidget)</span><span class="s3">\n                </span><span class="s1">this.prevWidget = this.widget;</span><span class="s3">\n            </span><span class="s1">this.widget = other.widget;</span><span class="s3">\n            </span><span class="s1">this.length = other.length;</span><span class="s3">\n            </span><span class="s1">this.deco = other.deco;</span><span class="s3">\n            </span><span class="s1">this.breakAfter = other.breakAfter;</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ignoreMutation() { return true; }</span><span class="s3">\n    </span><span class="s1">ignoreEvent(event) { return this.widget.ignoreEvent(event); }</span><span class="s3">\n    </span><span class="s1">get isEditable() { return false; }</span><span class="s3">\n    </span><span class="s1">get isWidget() { return true; }</span><span class="s3">\n    </span><span class="s1">coordsAt(pos, side) {</span><span class="s3">\n        </span><span class="s1">let custom = this.widget.coordsAt(this.dom, pos, side);</span><span class="s3">\n        </span><span class="s1">if (custom)</span><span class="s3">\n            </span><span class="s1">return custom;</span><span class="s3">\n        </span><span class="s1">if (this.widget instanceof BlockGapWidget)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side &lt;= 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">destroy() {</span><span class="s3">\n        </span><span class="s1">super.destroy();</span><span class="s3">\n        </span><span class="s1">if (this.dom)</span><span class="s3">\n            </span><span class="s1">this.widget.destroy(this.dom);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">covers(side) {</span><span class="s3">\n        </span><span class="s1">let { startSide, endSide } = this.deco;</span><span class="s3">\n        </span><span class="s1">return startSide == endSide ? false : side &lt; 0 ? startSide &lt; 0 : endSide &gt; 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class BlockGapWidget extends WidgetType {</span><span class="s3">\n    </span><span class="s1">constructor(height) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.height = height;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toDOM() {</span><span class="s3">\n        </span><span class="s1">let elt = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">elt.className = </span><span class="s3">\&quot;</span><span class="s1">cm-gap</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.updateDOM(elt);</span><span class="s3">\n        </span><span class="s1">return elt;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(other) { return other.height == this.height; }</span><span class="s3">\n    </span><span class="s1">updateDOM(elt) {</span><span class="s3">\n        </span><span class="s1">elt.style.height = this.height + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get editable() { return true; }</span><span class="s3">\n    </span><span class="s1">get estimatedHeight() { return this.height; }</span><span class="s3">\n    </span><span class="s1">ignoreEvent() { return false; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class ContentBuilder {</span><span class="s3">\n    </span><span class="s1">constructor(doc, pos, end, disallowBlockEffectsFor) {</span><span class="s3">\n        </span><span class="s1">this.doc = doc;</span><span class="s3">\n        </span><span class="s1">this.pos = pos;</span><span class="s3">\n        </span><span class="s1">this.end = end;</span><span class="s3">\n        </span><span class="s1">this.disallowBlockEffectsFor = disallowBlockEffectsFor;</span><span class="s3">\n        </span><span class="s1">this.content = [];</span><span class="s3">\n        </span><span class="s1">this.curLine = null;</span><span class="s3">\n        </span><span class="s1">this.breakAtStart = 0;</span><span class="s3">\n        </span><span class="s1">this.pendingBuffer = 0 /* Buf.No */;</span><span class="s3">\n        </span><span class="s1">this.bufferMarks = [];</span><span class="s3">\n        </span><span class="s1">// Set to false directly after a widget that covers the position after it</span><span class="s3">\n        </span><span class="s1">this.atCursorPos = true;</span><span class="s3">\n        </span><span class="s1">this.openStart = -1;</span><span class="s3">\n        </span><span class="s1">this.openEnd = -1;</span><span class="s3">\n        </span><span class="s1">this.text = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.textOff = 0;</span><span class="s3">\n        </span><span class="s1">this.cursor = doc.iter();</span><span class="s3">\n        </span><span class="s1">this.skip = pos;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">posCovered() {</span><span class="s3">\n        </span><span class="s1">if (this.content.length == 0)</span><span class="s3">\n            </span><span class="s1">return !this.breakAtStart &amp;&amp; this.doc.lineAt(this.pos).from != this.pos;</span><span class="s3">\n        </span><span class="s1">let last = this.content[this.content.length - 1];</span><span class="s3">\n        </span><span class="s1">return !(last.breakAfter || last instanceof BlockWidgetView &amp;&amp; last.deco.endSide &lt; 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getLine() {</span><span class="s3">\n        </span><span class="s1">if (!this.curLine) {</span><span class="s3">\n            </span><span class="s1">this.content.push(this.curLine = new LineView);</span><span class="s3">\n            </span><span class="s1">this.atCursorPos = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.curLine;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">flushBuffer(active = this.bufferMarks) {</span><span class="s3">\n        </span><span class="s1">if (this.pendingBuffer) {</span><span class="s3">\n            </span><span class="s1">this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);</span><span class="s3">\n            </span><span class="s1">this.pendingBuffer = 0 /* Buf.No */;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addBlockWidget(view) {</span><span class="s3">\n        </span><span class="s1">this.flushBuffer();</span><span class="s3">\n        </span><span class="s1">this.curLine = null;</span><span class="s3">\n        </span><span class="s1">this.content.push(view);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">finish(openEnd) {</span><span class="s3">\n        </span><span class="s1">if (this.pendingBuffer &amp;&amp; openEnd &lt;= this.bufferMarks.length)</span><span class="s3">\n            </span><span class="s1">this.flushBuffer();</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">this.pendingBuffer = 0 /* Buf.No */;</span><span class="s3">\n        </span><span class="s1">if (!this.posCovered() &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!(openEnd &amp;&amp; this.content.length &amp;&amp; this.content[this.content.length - 1] instanceof BlockWidgetView))</span><span class="s3">\n            </span><span class="s1">this.getLine();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildText(length, active, openStart) {</span><span class="s3">\n        </span><span class="s1">while (length &gt; 0) {</span><span class="s3">\n            </span><span class="s1">if (this.textOff == this.text.length) {</span><span class="s3">\n                </span><span class="s1">let { value, lineBreak, done } = this.cursor.next(this.skip);</span><span class="s3">\n                </span><span class="s1">this.skip = 0;</span><span class="s3">\n                </span><span class="s1">if (done)</span><span class="s3">\n                    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Ran out of text content when drawing inline views</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">if (lineBreak) {</span><span class="s3">\n                    </span><span class="s1">if (!this.posCovered())</span><span class="s3">\n                        </span><span class="s1">this.getLine();</span><span class="s3">\n                    </span><span class="s1">if (this.content.length)</span><span class="s3">\n                        </span><span class="s1">this.content[this.content.length - 1].breakAfter = 1;</span><span class="s3">\n                    </span><span class="s1">else</span><span class="s3">\n                        </span><span class="s1">this.breakAtStart = 1;</span><span class="s3">\n                    </span><span class="s1">this.flushBuffer();</span><span class="s3">\n                    </span><span class="s1">this.curLine = null;</span><span class="s3">\n                    </span><span class="s1">this.atCursorPos = true;</span><span class="s3">\n                    </span><span class="s1">length--;</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">this.text = value;</span><span class="s3">\n                    </span><span class="s1">this.textOff = 0;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let take = Math.min(this.text.length - this.textOff, length, 512 /* T.Chunk */);</span><span class="s3">\n            </span><span class="s1">this.flushBuffer(active.slice(active.length - openStart));</span><span class="s3">\n            </span><span class="s1">this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);</span><span class="s3">\n            </span><span class="s1">this.atCursorPos = true;</span><span class="s3">\n            </span><span class="s1">this.textOff += take;</span><span class="s3">\n            </span><span class="s1">length -= take;</span><span class="s3">\n            </span><span class="s1">openStart = 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">span(from, to, active, openStart) {</span><span class="s3">\n        </span><span class="s1">this.buildText(to - from, active, openStart);</span><span class="s3">\n        </span><span class="s1">this.pos = to;</span><span class="s3">\n        </span><span class="s1">if (this.openStart &lt; 0)</span><span class="s3">\n            </span><span class="s1">this.openStart = openStart;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">point(from, to, deco, active, openStart, index) {</span><span class="s3">\n        </span><span class="s1">if (this.disallowBlockEffectsFor[index] &amp;&amp; deco instanceof PointDecoration) {</span><span class="s3">\n            </span><span class="s1">if (deco.block)</span><span class="s3">\n                </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Block decorations may not be specified via plugins</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">if (to &gt; this.doc.lineAt(this.pos).to)</span><span class="s3">\n                </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Decorations that replace line breaks may not be specified via plugins</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let len = to - from;</span><span class="s3">\n        </span><span class="s1">if (deco instanceof PointDecoration) {</span><span class="s3">\n            </span><span class="s1">if (deco.block) {</span><span class="s3">\n                </span><span class="s1">if (deco.startSide &gt; 0 &amp;&amp; !this.posCovered())</span><span class="s3">\n                    </span><span class="s1">this.getLine();</span><span class="s3">\n                </span><span class="s1">this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let view = WidgetView.create(deco.widget || NullWidget.inline, len, len ? 0 : deco.startSide);</span><span class="s3">\n                </span><span class="s1">let cursorBefore = this.atCursorPos &amp;&amp; !view.isEditable &amp;&amp; openStart &lt;= active.length &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">(from &lt; to || deco.startSide &gt; 0);</span><span class="s3">\n                </span><span class="s1">let cursorAfter = !view.isEditable &amp;&amp; (from &lt; to || openStart &gt; active.length || deco.startSide &lt;= 0);</span><span class="s3">\n                </span><span class="s1">let line = this.getLine();</span><span class="s3">\n                </span><span class="s1">if (this.pendingBuffer == 2 /* Buf.IfCursor */ &amp;&amp; !cursorBefore &amp;&amp; !view.isEditable)</span><span class="s3">\n                    </span><span class="s1">this.pendingBuffer = 0 /* Buf.No */;</span><span class="s3">\n                </span><span class="s1">this.flushBuffer(active);</span><span class="s3">\n                </span><span class="s1">if (cursorBefore) {</span><span class="s3">\n                    </span><span class="s1">line.append(wrapMarks(new WidgetBufferView(1), active), openStart);</span><span class="s3">\n                    </span><span class="s1">openStart = active.length + Math.max(0, openStart - active.length);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">line.append(wrapMarks(view, active), openStart);</span><span class="s3">\n                </span><span class="s1">this.atCursorPos = cursorAfter;</span><span class="s3">\n                </span><span class="s1">this.pendingBuffer = !cursorAfter ? 0 /* Buf.No */ : from &lt; to || openStart &gt; active.length ? 1 /* Buf.Yes */ : 2 /* Buf.IfCursor */;</span><span class="s3">\n                </span><span class="s1">if (this.pendingBuffer)</span><span class="s3">\n                    </span><span class="s1">this.bufferMarks = active.slice();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (this.doc.lineAt(this.pos).from == this.pos) { // Line decoration</span><span class="s3">\n            </span><span class="s1">this.getLine().addLineDeco(deco);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (len) {</span><span class="s3">\n            </span><span class="s1">// Advance the iterator past the replaced content</span><span class="s3">\n            </span><span class="s1">if (this.textOff + len &lt;= this.text.length) {</span><span class="s3">\n                </span><span class="s1">this.textOff += len;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this.skip += len - (this.text.length - this.textOff);</span><span class="s3">\n                </span><span class="s1">this.text = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">this.textOff = 0;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.pos = to;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.openStart &lt; 0)</span><span class="s3">\n            </span><span class="s1">this.openStart = openStart;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static build(text, from, to, decorations, dynamicDecorationMap) {</span><span class="s3">\n        </span><span class="s1">let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);</span><span class="s3">\n        </span><span class="s1">builder.openEnd = RangeSet.spans(decorations, from, to, builder);</span><span class="s3">\n        </span><span class="s1">if (builder.openStart &lt; 0)</span><span class="s3">\n            </span><span class="s1">builder.openStart = builder.openEnd;</span><span class="s3">\n        </span><span class="s1">builder.finish(builder.openEnd);</span><span class="s3">\n        </span><span class="s1">return builder;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function wrapMarks(view, active) {</span><span class="s3">\n    </span><span class="s1">for (let mark of active)</span><span class="s3">\n        </span><span class="s1">view = new MarkView(mark, [view], view.length);</span><span class="s3">\n    </span><span class="s1">return view;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class NullWidget extends WidgetType {</span><span class="s3">\n    </span><span class="s1">constructor(tag) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.tag = tag;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(other) { return other.tag == this.tag; }</span><span class="s3">\n    </span><span class="s1">toDOM() { return document.createElement(this.tag); }</span><span class="s3">\n    </span><span class="s1">updateDOM(elt) { return elt.nodeName.toLowerCase() == this.tag; }</span><span class="s3">\n    </span><span class="s1">get isHidden() { return true; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">NullWidget.inline = /*@__PURE__*/new NullWidget(</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">NullWidget.block = /*@__PURE__*/new NullWidget(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Used to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var Direction = /*@__PURE__*/(function (Direction) {</span><span class="s3">\n    </span><span class="s1">// (These are chosen to match the base levels, in bidi algorithm</span><span class="s3">\n    </span><span class="s1">// terms, of spans in that direction.)</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Left-to-right.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">Direction[Direction[</span><span class="s3">\&quot;</span><span class="s1">LTR</span><span class="s3">\&quot;</span><span class="s1">] = 0] = </span><span class="s3">\&quot;</span><span class="s1">LTR</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Right-to-left.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">Direction[Direction[</span><span class="s3">\&quot;</span><span class="s1">RTL</span><span class="s3">\&quot;</span><span class="s1">] = 1] = </span><span class="s3">\&quot;</span><span class="s1">RTL</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">return Direction})(Direction || (Direction = {}));</span><span class="s3">\n</span><span class="s1">const LTR = Direction.LTR, RTL = Direction.RTL;</span><span class="s3">\n</span><span class="s1">// Decode a string with each type encoded as log2(type)</span><span class="s3">\n</span><span class="s1">function dec(str) {</span><span class="s3">\n    </span><span class="s1">let result = [];</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; str.length; i++)</span><span class="s3">\n        </span><span class="s1">result.push(1 &lt;&lt; +str[i]);</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Character types for codepoints 0 to 0xf8</span><span class="s3">\n</span><span class="s1">const LowTypes = /*@__PURE__*/dec(</span><span class="s3">\&quot;</span><span class="s1">88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">// Character types for codepoints 0x600 to 0x6f9</span><span class="s3">\n</span><span class="s1">const ArabicTypes = /*@__PURE__*/dec(</span><span class="s3">\&quot;</span><span class="s1">4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const Brackets = /*@__PURE__*/Object.create(null), BracketStack = [];</span><span class="s3">\n</span><span class="s1">// There's a lot more in</span><span class="s3">\n</span><span class="s1">// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,</span><span class="s3">\n</span><span class="s1">// which are left out to keep code size down.</span><span class="s3">\n</span><span class="s1">for (let p of [</span><span class="s3">\&quot;</span><span class="s1">()</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">[]</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">{}</span><span class="s3">\&quot;</span><span class="s1">]) {</span><span class="s3">\n    </span><span class="s1">let l = /*@__PURE__*/p.charCodeAt(0), r = /*@__PURE__*/p.charCodeAt(1);</span><span class="s3">\n    </span><span class="s1">Brackets[l] = r;</span><span class="s3">\n    </span><span class="s1">Brackets[r] = -l;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function charType(ch) {</span><span class="s3">\n    </span><span class="s1">return ch &lt;= 0xf7 ? LowTypes[ch] :</span><span class="s3">\n        </span><span class="s1">0x590 &lt;= ch &amp;&amp; ch &lt;= 0x5f4 ? 2 /* T.R */ :</span><span class="s3">\n            </span><span class="s1">0x600 &lt;= ch &amp;&amp; ch &lt;= 0x6f9 ? ArabicTypes[ch - 0x600] :</span><span class="s3">\n                </span><span class="s1">0x6ee &lt;= ch &amp;&amp; ch &lt;= 0x8ac ? 4 /* T.AL */ :</span><span class="s3">\n                    </span><span class="s1">0x2000 &lt;= ch &amp;&amp; ch &lt;= 0x200c ? 256 /* T.NI */ :</span><span class="s3">\n                        </span><span class="s1">0xfb50 &lt;= ch &amp;&amp; ch &lt;= 0xfdff ? 4 /* T.AL */ : 1 /* T.L */;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const BidiRE = /[</span><span class="s3">\\</span><span class="s1">u0590-</span><span class="s3">\\</span><span class="s1">u05f4</span><span class="s3">\\</span><span class="s1">u0600-</span><span class="s3">\\</span><span class="s1">u06ff</span><span class="s3">\\</span><span class="s1">u0700-</span><span class="s3">\\</span><span class="s1">u08ac</span><span class="s3">\\</span><span class="s1">ufb50-</span><span class="s3">\\</span><span class="s1">ufdff]/;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Represents a contiguous range of text that has a single direction</span><span class="s3">\n</span><span class="s1">(as in left-to-right or right-to-left).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class BidiSpan {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The direction of this span.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get dir() { return this.level % 2 ? RTL : LTR; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The start of the span (relative to the start of the line).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">from, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The end of the span.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">to, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The [</span><span class="s3">\&quot;</span><span class="s1">bidi</span><span class="s3">\n    </span><span class="s1">level</span><span class="s3">\&quot;</span><span class="s1">](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)</span><span class="s3">\n    </span><span class="s1">of the span (in this context, 0 means</span><span class="s3">\n    </span><span class="s1">left-to-right, 1 means right-to-left, 2 means left-to-right</span><span class="s3">\n    </span><span class="s1">number inside right-to-left text).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">level) {</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n        </span><span class="s1">this.level = level;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">side(end, dir) { return (this.dir == dir) == end ? this.to : this.from; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">forward(forward, dir) { return forward == (this.dir == dir); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static find(order, index, level, assoc) {</span><span class="s3">\n        </span><span class="s1">let maybe = -1;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; order.length; i++) {</span><span class="s3">\n            </span><span class="s1">let span = order[i];</span><span class="s3">\n            </span><span class="s1">if (span.from &lt;= index &amp;&amp; span.to &gt;= index) {</span><span class="s3">\n                </span><span class="s1">if (span.level == level)</span><span class="s3">\n                    </span><span class="s1">return i;</span><span class="s3">\n                </span><span class="s1">// When multiple spans match, if assoc != 0, take the one that</span><span class="s3">\n                </span><span class="s1">// covers that side, otherwise take the one with the minimum</span><span class="s3">\n                </span><span class="s1">// level.</span><span class="s3">\n                </span><span class="s1">if (maybe &lt; 0 || (assoc != 0 ? (assoc &lt; 0 ? span.from &lt; index : span.to &gt; index) : order[maybe].level &gt; span.level))</span><span class="s3">\n                    </span><span class="s1">maybe = i;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (maybe &lt; 0)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Index out of range</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return maybe;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isolatesEq(a, b) {</span><span class="s3">\n    </span><span class="s1">if (a.length != b.length)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; a.length; i++) {</span><span class="s3">\n        </span><span class="s1">let iA = a[i], iB = b[i];</span><span class="s3">\n        </span><span class="s1">if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Reused array of character types</span><span class="s3">\n</span><span class="s1">const types = [];</span><span class="s3">\n</span><span class="s1">// Fill in the character types (in `types`) from `from` to `to` and</span><span class="s3">\n</span><span class="s1">// apply W normalization rules.</span><span class="s3">\n</span><span class="s1">function computeCharTypes(line, rFrom, rTo, isolates, outerType) {</span><span class="s3">\n    </span><span class="s1">for (let iI = 0; iI &lt;= isolates.length; iI++) {</span><span class="s3">\n        </span><span class="s1">let from = iI ? isolates[iI - 1].to : rFrom, to = iI &lt; isolates.length ? isolates[iI].from : rTo;</span><span class="s3">\n        </span><span class="s1">let prevType = iI ? 256 /* T.NI */ : outerType;</span><span class="s3">\n        </span><span class="s1">// W1. Examine each non-spacing mark (NSM) in the level run, and</span><span class="s3">\n        </span><span class="s1">// change the type of the NSM to the type of the previous</span><span class="s3">\n        </span><span class="s1">// character. If the NSM is at the start of the level run, it will</span><span class="s3">\n        </span><span class="s1">// get the type of sor.</span><span class="s3">\n        </span><span class="s1">// W2. Search backwards from each instance of a European number</span><span class="s3">\n        </span><span class="s1">// until the first strong type (R, L, AL, or sor) is found. If an</span><span class="s3">\n        </span><span class="s1">// AL is found, change the type of the European number to Arabic</span><span class="s3">\n        </span><span class="s1">// number.</span><span class="s3">\n        </span><span class="s1">// W3. Change all ALs to R.</span><span class="s3">\n        </span><span class="s1">// (Left after this: L, R, EN, AN, ET, CS, NI)</span><span class="s3">\n        </span><span class="s1">for (let i = from, prev = prevType, prevStrong = prevType; i &lt; to; i++) {</span><span class="s3">\n            </span><span class="s1">let type = charType(line.charCodeAt(i));</span><span class="s3">\n            </span><span class="s1">if (type == 512 /* T.NSM */)</span><span class="s3">\n                </span><span class="s1">type = prev;</span><span class="s3">\n            </span><span class="s1">else if (type == 8 /* T.EN */ &amp;&amp; prevStrong == 4 /* T.AL */)</span><span class="s3">\n                </span><span class="s1">type = 16 /* T.AN */;</span><span class="s3">\n            </span><span class="s1">types[i] = type == 4 /* T.AL */ ? 2 /* T.R */ : type;</span><span class="s3">\n            </span><span class="s1">if (type &amp; 7 /* T.Strong */)</span><span class="s3">\n                </span><span class="s1">prevStrong = type;</span><span class="s3">\n            </span><span class="s1">prev = type;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// W5. A sequence of European terminators adjacent to European</span><span class="s3">\n        </span><span class="s1">// numbers changes to all European numbers.</span><span class="s3">\n        </span><span class="s1">// W6. Otherwise, separators and terminators change to Other</span><span class="s3">\n        </span><span class="s1">// Neutral.</span><span class="s3">\n        </span><span class="s1">// W7. Search backwards from each instance of a European number</span><span class="s3">\n        </span><span class="s1">// until the first strong type (R, L, or sor) is found. If an L is</span><span class="s3">\n        </span><span class="s1">// found, then change the type of the European number to L.</span><span class="s3">\n        </span><span class="s1">// (Left after this: L, R, EN+AN, NI)</span><span class="s3">\n        </span><span class="s1">for (let i = from, prev = prevType, prevStrong = prevType; i &lt; to; i++) {</span><span class="s3">\n            </span><span class="s1">let type = types[i];</span><span class="s3">\n            </span><span class="s1">if (type == 128 /* T.CS */) {</span><span class="s3">\n                </span><span class="s1">if (i &lt; to - 1 &amp;&amp; prev == types[i + 1] &amp;&amp; (prev &amp; 24 /* T.Num */))</span><span class="s3">\n                    </span><span class="s1">type = types[i] = prev;</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">types[i] = 256 /* T.NI */;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (type == 64 /* T.ET */) {</span><span class="s3">\n                </span><span class="s1">let end = i + 1;</span><span class="s3">\n                </span><span class="s1">while (end &lt; to &amp;&amp; types[end] == 64 /* T.ET */)</span><span class="s3">\n                    </span><span class="s1">end++;</span><span class="s3">\n                </span><span class="s1">let replace = (i &amp;&amp; prev == 8 /* T.EN */) || (end &lt; rTo &amp;&amp; types[end] == 8 /* T.EN */) ? (prevStrong == 1 /* T.L */ ? 1 /* T.L */ : 8 /* T.EN */) : 256 /* T.NI */;</span><span class="s3">\n                </span><span class="s1">for (let j = i; j &lt; end; j++)</span><span class="s3">\n                    </span><span class="s1">types[j] = replace;</span><span class="s3">\n                </span><span class="s1">i = end - 1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (type == 8 /* T.EN */ &amp;&amp; prevStrong == 1 /* T.L */) {</span><span class="s3">\n                </span><span class="s1">types[i] = 1 /* T.L */;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">prev = type;</span><span class="s3">\n            </span><span class="s1">if (type &amp; 7 /* T.Strong */)</span><span class="s3">\n                </span><span class="s1">prevStrong = type;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Process brackets throughout a run sequence.</span><span class="s3">\n</span><span class="s1">function processBracketPairs(line, rFrom, rTo, isolates, outerType) {</span><span class="s3">\n    </span><span class="s1">let oppositeType = outerType == 1 /* T.L */ ? 2 /* T.R */ : 1 /* T.L */;</span><span class="s3">\n    </span><span class="s1">for (let iI = 0, sI = 0, context = 0; iI &lt;= isolates.length; iI++) {</span><span class="s3">\n        </span><span class="s1">let from = iI ? isolates[iI - 1].to : rFrom, to = iI &lt; isolates.length ? isolates[iI].from : rTo;</span><span class="s3">\n        </span><span class="s1">// N0. Process bracket pairs in an isolating run sequence</span><span class="s3">\n        </span><span class="s1">// sequentially in the logical order of the text positions of the</span><span class="s3">\n        </span><span class="s1">// opening paired brackets using the logic given below. Within this</span><span class="s3">\n        </span><span class="s1">// scope, bidirectional types EN and AN are treated as R.</span><span class="s3">\n        </span><span class="s1">for (let i = from, ch, br, type; i &lt; to; i++) {</span><span class="s3">\n            </span><span class="s1">// Keeps [startIndex, type, strongSeen] triples for each open</span><span class="s3">\n            </span><span class="s1">// bracket on BracketStack.</span><span class="s3">\n            </span><span class="s1">if (br = Brackets[ch = line.charCodeAt(i)]) {</span><span class="s3">\n                </span><span class="s1">if (br &lt; 0) { // Closing bracket</span><span class="s3">\n                    </span><span class="s1">for (let sJ = sI - 3; sJ &gt;= 0; sJ -= 3) {</span><span class="s3">\n                        </span><span class="s1">if (BracketStack[sJ + 1] == -br) {</span><span class="s3">\n                            </span><span class="s1">let flags = BracketStack[sJ + 2];</span><span class="s3">\n                            </span><span class="s1">let type = (flags &amp; 2 /* Bracketed.EmbedInside */) ? outerType :</span><span class="s3">\n                                </span><span class="s1">!(flags &amp; 4 /* Bracketed.OppositeInside */) ? 0 :</span><span class="s3">\n                                    </span><span class="s1">(flags &amp; 1 /* Bracketed.OppositeBefore */) ? oppositeType : outerType;</span><span class="s3">\n                            </span><span class="s1">if (type)</span><span class="s3">\n                                </span><span class="s1">types[i] = types[BracketStack[sJ]] = type;</span><span class="s3">\n                            </span><span class="s1">sI = sJ;</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (BracketStack.length == 189 /* Bracketed.MaxDepth */) {</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">BracketStack[sI++] = i;</span><span class="s3">\n                    </span><span class="s1">BracketStack[sI++] = ch;</span><span class="s3">\n                    </span><span class="s1">BracketStack[sI++] = context;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if ((type = types[i]) == 2 /* T.R */ || type == 1 /* T.L */) {</span><span class="s3">\n                </span><span class="s1">let embed = type == outerType;</span><span class="s3">\n                </span><span class="s1">context = embed ? 0 : 1 /* Bracketed.OppositeBefore */;</span><span class="s3">\n                </span><span class="s1">for (let sJ = sI - 3; sJ &gt;= 0; sJ -= 3) {</span><span class="s3">\n                    </span><span class="s1">let cur = BracketStack[sJ + 2];</span><span class="s3">\n                    </span><span class="s1">if (cur &amp; 2 /* Bracketed.EmbedInside */)</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">if (embed) {</span><span class="s3">\n                        </span><span class="s1">BracketStack[sJ + 2] |= 2 /* Bracketed.EmbedInside */;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">if (cur &amp; 4 /* Bracketed.OppositeInside */)</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">BracketStack[sJ + 2] |= 4 /* Bracketed.OppositeInside */;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function processNeutrals(rFrom, rTo, isolates, outerType) {</span><span class="s3">\n    </span><span class="s1">for (let iI = 0, prev = outerType; iI &lt;= isolates.length; iI++) {</span><span class="s3">\n        </span><span class="s1">let from = iI ? isolates[iI - 1].to : rFrom, to = iI &lt; isolates.length ? isolates[iI].from : rTo;</span><span class="s3">\n        </span><span class="s1">// N1. A sequence of neutrals takes the direction of the</span><span class="s3">\n        </span><span class="s1">// surrounding strong text if the text on both sides has the same</span><span class="s3">\n        </span><span class="s1">// direction. European and Arabic numbers act as if they were R in</span><span class="s3">\n        </span><span class="s1">// terms of their influence on neutrals. Start-of-level-run (sor)</span><span class="s3">\n        </span><span class="s1">// and end-of-level-run (eor) are used at level run boundaries.</span><span class="s3">\n        </span><span class="s1">// N2. Any remaining neutrals take the embedding direction.</span><span class="s3">\n        </span><span class="s1">// (Left after this: L, R, EN+AN)</span><span class="s3">\n        </span><span class="s1">for (let i = from; i &lt; to;) {</span><span class="s3">\n            </span><span class="s1">let type = types[i];</span><span class="s3">\n            </span><span class="s1">if (type == 256 /* T.NI */) {</span><span class="s3">\n                </span><span class="s1">let end = i + 1;</span><span class="s3">\n                </span><span class="s1">for (;;) {</span><span class="s3">\n                    </span><span class="s1">if (end == to) {</span><span class="s3">\n                        </span><span class="s1">if (iI == isolates.length)</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">end = isolates[iI++].to;</span><span class="s3">\n                        </span><span class="s1">to = iI &lt; isolates.length ? isolates[iI].from : rTo;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else if (types[end] == 256 /* T.NI */) {</span><span class="s3">\n                        </span><span class="s1">end++;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">let beforeL = prev == 1 /* T.L */;</span><span class="s3">\n                </span><span class="s1">let afterL = (end &lt; rTo ? types[end] : outerType) == 1 /* T.L */;</span><span class="s3">\n                </span><span class="s1">let replace = beforeL == afterL ? (beforeL ? 1 /* T.L */ : 2 /* T.R */) : outerType;</span><span class="s3">\n                </span><span class="s1">for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j &gt; i;) {</span><span class="s3">\n                    </span><span class="s1">if (j == fromJ) {</span><span class="s3">\n                        </span><span class="s1">j = isolates[--jI].from;</span><span class="s3">\n                        </span><span class="s1">fromJ = jI ? isolates[jI - 1].to : rFrom;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">types[--j] = replace;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">i = end;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">prev = type;</span><span class="s3">\n                </span><span class="s1">i++;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Find the contiguous ranges of character types in a given range, and</span><span class="s3">\n</span><span class="s1">// emit spans for them. Flip the order of the spans as appropriate</span><span class="s3">\n</span><span class="s1">// based on the level, and call through to compute the spans for</span><span class="s3">\n</span><span class="s1">// isolates at the proper point.</span><span class="s3">\n</span><span class="s1">function emitSpans(line, from, to, level, baseLevel, isolates, order) {</span><span class="s3">\n    </span><span class="s1">let ourType = level % 2 ? 2 /* T.R */ : 1 /* T.L */;</span><span class="s3">\n    </span><span class="s1">if ((level % 2) == (baseLevel % 2)) { // Same dir as base direction, don't flip</span><span class="s3">\n        </span><span class="s1">for (let iCh = from, iI = 0; iCh &lt; to;) {</span><span class="s3">\n            </span><span class="s1">// Scan a section of characters in direction ourType, unless</span><span class="s3">\n            </span><span class="s1">// there's another type of char right after iCh, in which case</span><span class="s3">\n            </span><span class="s1">// we scan a section of other characters (which, if ourType ==</span><span class="s3">\n            </span><span class="s1">// T.L, may contain both T.R and T.AN chars).</span><span class="s3">\n            </span><span class="s1">let sameDir = true, isNum = false;</span><span class="s3">\n            </span><span class="s1">if (iI == isolates.length || iCh &lt; isolates[iI].from) {</span><span class="s3">\n                </span><span class="s1">let next = types[iCh];</span><span class="s3">\n                </span><span class="s1">if (next != ourType) {</span><span class="s3">\n                    </span><span class="s1">sameDir = false;</span><span class="s3">\n                    </span><span class="s1">isNum = next == 16 /* T.AN */;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Holds an array of isolates to pass to a recursive call if we</span><span class="s3">\n            </span><span class="s1">// must recurse (to distinguish T.AN inside an RTL section in</span><span class="s3">\n            </span><span class="s1">// LTR text), null if we can emit directly</span><span class="s3">\n            </span><span class="s1">let recurse = !sameDir &amp;&amp; ourType == 1 /* T.L */ ? [] : null;</span><span class="s3">\n            </span><span class="s1">let localLevel = sameDir ? level : level + 1;</span><span class="s3">\n            </span><span class="s1">let iScan = iCh;</span><span class="s3">\n            </span><span class="s1">run: for (;;) {</span><span class="s3">\n                </span><span class="s1">if (iI &lt; isolates.length &amp;&amp; iScan == isolates[iI].from) {</span><span class="s3">\n                    </span><span class="s1">if (isNum)</span><span class="s3">\n                        </span><span class="s1">break run;</span><span class="s3">\n                    </span><span class="s1">let iso = isolates[iI];</span><span class="s3">\n                    </span><span class="s1">// Scan ahead to verify that there is another char in this dir after the isolate(s)</span><span class="s3">\n                    </span><span class="s1">if (!sameDir)</span><span class="s3">\n                        </span><span class="s1">for (let upto = iso.to, jI = iI + 1;;) {</span><span class="s3">\n                            </span><span class="s1">if (upto == to)</span><span class="s3">\n                                </span><span class="s1">break run;</span><span class="s3">\n                            </span><span class="s1">if (jI &lt; isolates.length &amp;&amp; isolates[jI].from == upto)</span><span class="s3">\n                                </span><span class="s1">upto = isolates[jI++].to;</span><span class="s3">\n                            </span><span class="s1">else if (types[upto] == ourType)</span><span class="s3">\n                                </span><span class="s1">break run;</span><span class="s3">\n                            </span><span class="s1">else</span><span class="s3">\n                                </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">iI++;</span><span class="s3">\n                    </span><span class="s1">if (recurse) {</span><span class="s3">\n                        </span><span class="s1">recurse.push(iso);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">if (iso.from &gt; iCh)</span><span class="s3">\n                            </span><span class="s1">order.push(new BidiSpan(iCh, iso.from, localLevel));</span><span class="s3">\n                        </span><span class="s1">let dirSwap = (iso.direction == LTR) != !(localLevel % 2);</span><span class="s3">\n                        </span><span class="s1">computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);</span><span class="s3">\n                        </span><span class="s1">iCh = iso.to;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">iScan = iso.to;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">iScan++;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (recurse)</span><span class="s3">\n                </span><span class="s1">emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);</span><span class="s3">\n            </span><span class="s1">else if (iCh &lt; iScan)</span><span class="s3">\n                </span><span class="s1">order.push(new BidiSpan(iCh, iScan, localLevel));</span><span class="s3">\n            </span><span class="s1">iCh = iScan;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">// Iterate in reverse to flip the span order. Same code again, but</span><span class="s3">\n        </span><span class="s1">// going from the back of the section to the front</span><span class="s3">\n        </span><span class="s1">for (let iCh = to, iI = isolates.length; iCh &gt; from;) {</span><span class="s3">\n            </span><span class="s1">let sameDir = true, isNum = false;</span><span class="s3">\n            </span><span class="s1">if (!iI || iCh &gt; isolates[iI - 1].to) {</span><span class="s3">\n                </span><span class="s1">let next = types[iCh - 1];</span><span class="s3">\n                </span><span class="s1">if (next != ourType) {</span><span class="s3">\n                    </span><span class="s1">sameDir = false;</span><span class="s3">\n                    </span><span class="s1">isNum = next == 16 /* T.AN */;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let recurse = !sameDir &amp;&amp; ourType == 1 /* T.L */ ? [] : null;</span><span class="s3">\n            </span><span class="s1">let localLevel = sameDir ? level : level + 1;</span><span class="s3">\n            </span><span class="s1">let iScan = iCh;</span><span class="s3">\n            </span><span class="s1">run: for (;;) {</span><span class="s3">\n                </span><span class="s1">if (iI &amp;&amp; iScan == isolates[iI - 1].to) {</span><span class="s3">\n                    </span><span class="s1">if (isNum)</span><span class="s3">\n                        </span><span class="s1">break run;</span><span class="s3">\n                    </span><span class="s1">let iso = isolates[--iI];</span><span class="s3">\n                    </span><span class="s1">// Scan ahead to verify that there is another char in this dir after the isolate(s)</span><span class="s3">\n                    </span><span class="s1">if (!sameDir)</span><span class="s3">\n                        </span><span class="s1">for (let upto = iso.from, jI = iI;;) {</span><span class="s3">\n                            </span><span class="s1">if (upto == from)</span><span class="s3">\n                                </span><span class="s1">break run;</span><span class="s3">\n                            </span><span class="s1">if (jI &amp;&amp; isolates[jI - 1].to == upto)</span><span class="s3">\n                                </span><span class="s1">upto = isolates[--jI].from;</span><span class="s3">\n                            </span><span class="s1">else if (types[upto - 1] == ourType)</span><span class="s3">\n                                </span><span class="s1">break run;</span><span class="s3">\n                            </span><span class="s1">else</span><span class="s3">\n                                </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (recurse) {</span><span class="s3">\n                        </span><span class="s1">recurse.push(iso);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">if (iso.to &lt; iCh)</span><span class="s3">\n                            </span><span class="s1">order.push(new BidiSpan(iso.to, iCh, localLevel));</span><span class="s3">\n                        </span><span class="s1">let dirSwap = (iso.direction == LTR) != !(localLevel % 2);</span><span class="s3">\n                        </span><span class="s1">computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);</span><span class="s3">\n                        </span><span class="s1">iCh = iso.from;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">iScan = iso.from;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">iScan--;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (recurse)</span><span class="s3">\n                </span><span class="s1">emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);</span><span class="s3">\n            </span><span class="s1">else if (iScan &lt; iCh)</span><span class="s3">\n                </span><span class="s1">order.push(new BidiSpan(iScan, iCh, localLevel));</span><span class="s3">\n            </span><span class="s1">iCh = iScan;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {</span><span class="s3">\n    </span><span class="s1">let outerType = (level % 2 ? 2 /* T.R */ : 1 /* T.L */);</span><span class="s3">\n    </span><span class="s1">computeCharTypes(line, from, to, isolates, outerType);</span><span class="s3">\n    </span><span class="s1">processBracketPairs(line, from, to, isolates, outerType);</span><span class="s3">\n    </span><span class="s1">processNeutrals(from, to, isolates, outerType);</span><span class="s3">\n    </span><span class="s1">emitSpans(line, from, to, level, baseLevel, isolates, order);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function computeOrder(line, direction, isolates) {</span><span class="s3">\n    </span><span class="s1">if (!line)</span><span class="s3">\n        </span><span class="s1">return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];</span><span class="s3">\n    </span><span class="s1">if (direction == LTR &amp;&amp; !isolates.length &amp;&amp; !BidiRE.test(line))</span><span class="s3">\n        </span><span class="s1">return trivialOrder(line.length);</span><span class="s3">\n    </span><span class="s1">if (isolates.length)</span><span class="s3">\n        </span><span class="s1">while (line.length &gt; types.length)</span><span class="s3">\n            </span><span class="s1">types[types.length] = 256 /* T.NI */; // Make sure types array has no gaps</span><span class="s3">\n    </span><span class="s1">let order = [], level = direction == LTR ? 0 : 1;</span><span class="s3">\n    </span><span class="s1">computeSectionOrder(line, level, level, isolates, 0, line.length, order);</span><span class="s3">\n    </span><span class="s1">return order;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function trivialOrder(length) {</span><span class="s3">\n    </span><span class="s1">return [new BidiSpan(0, length, 0)];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">let movedOver = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">// This implementation moves strictly visually, without concern for a</span><span class="s3">\n</span><span class="s1">// traversal visiting every logical position in the string. It will</span><span class="s3">\n</span><span class="s1">// still do so for simple input, but situations like multiple isolates</span><span class="s3">\n</span><span class="s1">// with the same level next to each other, or text going against the</span><span class="s3">\n</span><span class="s1">// main dir at the end of the line, will make some positions</span><span class="s3">\n</span><span class="s1">// unreachable with this motion. Each visible cursor position will</span><span class="s3">\n</span><span class="s1">// correspond to the lower-level bidi span that touches it.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// The alternative would be to solve an order globally for a given</span><span class="s3">\n</span><span class="s1">// line, making sure that it includes every position, but that would</span><span class="s3">\n</span><span class="s1">// require associating non-canonical (higher bidi span level)</span><span class="s3">\n</span><span class="s1">// positions with a given visual position, which is likely to confuse</span><span class="s3">\n</span><span class="s1">// people. (And would generally be a lot more complicated.)</span><span class="s3">\n</span><span class="s1">function moveVisually(line, order, dir, start, forward) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">let startIndex = start.head - line.from;</span><span class="s3">\n    </span><span class="s1">let spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null &amp;&amp; _a !== void 0 ? _a : -1, start.assoc);</span><span class="s3">\n    </span><span class="s1">let span = order[spanI], spanEnd = span.side(forward, dir);</span><span class="s3">\n    </span><span class="s1">// End of span</span><span class="s3">\n    </span><span class="s1">if (startIndex == spanEnd) {</span><span class="s3">\n        </span><span class="s1">let nextI = spanI += forward ? 1 : -1;</span><span class="s3">\n        </span><span class="s1">if (nextI &lt; 0 || nextI &gt;= order.length)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">span = order[spanI = nextI];</span><span class="s3">\n        </span><span class="s1">startIndex = span.side(!forward, dir);</span><span class="s3">\n        </span><span class="s1">spanEnd = span.side(forward, dir);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let nextIndex = findClusterBreak(line.text, startIndex, span.forward(forward, dir));</span><span class="s3">\n    </span><span class="s1">if (nextIndex &lt; span.from || nextIndex &gt; span.to)</span><span class="s3">\n        </span><span class="s1">nextIndex = spanEnd;</span><span class="s3">\n    </span><span class="s1">movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));</span><span class="s3">\n    </span><span class="s1">let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];</span><span class="s3">\n    </span><span class="s1">if (nextSpan &amp;&amp; nextIndex == spanEnd &amp;&amp; nextSpan.level + (forward ? 0 : 1) &lt; span.level)</span><span class="s3">\n        </span><span class="s1">return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);</span><span class="s3">\n    </span><span class="s1">return EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function autoDirection(text, from, to) {</span><span class="s3">\n    </span><span class="s1">for (let i = from; i &lt; to; i++) {</span><span class="s3">\n        </span><span class="s1">let type = charType(text.charCodeAt(i));</span><span class="s3">\n        </span><span class="s1">if (type == 1 /* T.L */)</span><span class="s3">\n            </span><span class="s1">return LTR;</span><span class="s3">\n        </span><span class="s1">if (type == 2 /* T.R */ || type == 4 /* T.AL */)</span><span class="s3">\n            </span><span class="s1">return RTL;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return LTR;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const clickAddsSelectionRange = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const dragMovesSelection$1 = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const mouseSelectionStyle = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const exceptionSink = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const updateListener = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const inputHandler = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const focusChangeEffect = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const clipboardInputFilter = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const clipboardOutputFilter = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const perLineTextDirection = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine: values =&gt; values.some(x =&gt; x)</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const nativeSelectionHidden = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine: values =&gt; values.some(x =&gt; x)</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const scrollHandler = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">class ScrollTarget {</span><span class="s3">\n    </span><span class="s1">constructor(range, y = </span><span class="s3">\&quot;</span><span class="s1">nearest</span><span class="s3">\&quot;</span><span class="s1">, x = </span><span class="s3">\&quot;</span><span class="s1">nearest</span><span class="s3">\&quot;</span><span class="s1">, yMargin = 5, xMargin = 5, </span><span class="s3">\n    </span><span class="s1">// This data structure is abused to also store precise scroll</span><span class="s3">\n    </span><span class="s1">// snapshots, instead of a `scrollIntoView` request. When this</span><span class="s3">\n    </span><span class="s1">// flag is `true`, `range` points at a position in the reference</span><span class="s3">\n    </span><span class="s1">// line, `yMargin` holds the difference between the top of that</span><span class="s3">\n    </span><span class="s1">// line and the top of the editor, and `xMargin` holds the</span><span class="s3">\n    </span><span class="s1">// editor's `scrollLeft`.</span><span class="s3">\n    </span><span class="s1">isSnapshot = false) {</span><span class="s3">\n        </span><span class="s1">this.range = range;</span><span class="s3">\n        </span><span class="s1">this.y = y;</span><span class="s3">\n        </span><span class="s1">this.x = x;</span><span class="s3">\n        </span><span class="s1">this.yMargin = yMargin;</span><span class="s3">\n        </span><span class="s1">this.xMargin = xMargin;</span><span class="s3">\n        </span><span class="s1">this.isSnapshot = isSnapshot;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">map(changes) {</span><span class="s3">\n        </span><span class="s1">return changes.empty ? this :</span><span class="s3">\n            </span><span class="s1">new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">clip(state) {</span><span class="s3">\n        </span><span class="s1">return this.range.to &lt;= state.doc.length ? this :</span><span class="s3">\n            </span><span class="s1">new ScrollTarget(EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const scrollIntoView = /*@__PURE__*/StateEffect.define({ map: (t, ch) =&gt; t.map(ch) });</span><span class="s3">\n</span><span class="s1">const setEditContextFormatting = /*@__PURE__*/StateEffect.define();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Log or report an unhandled exception in client code. Should</span><span class="s3">\n</span><span class="s1">probably only be used by extension code that allows client code to</span><span class="s3">\n</span><span class="s1">provide functions, and calls those functions in a context where an</span><span class="s3">\n</span><span class="s1">exception can't be propagated to calling code in a reasonable way</span><span class="s3">\n</span><span class="s1">(for example when in an event handler).</span><span class="s3">\n\n</span><span class="s1">Either calls a handler registered with</span><span class="s3">\n</span><span class="s1">[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),</span><span class="s3">\n</span><span class="s1">`window.onerror`, if defined, or `console.error` (in which case</span><span class="s3">\n</span><span class="s1">it'll pass `context`, when given, as first argument).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function logException(state, exception, context) {</span><span class="s3">\n    </span><span class="s1">let handler = state.facet(exceptionSink);</span><span class="s3">\n    </span><span class="s1">if (handler.length)</span><span class="s3">\n        </span><span class="s1">handler[0](exception);</span><span class="s3">\n    </span><span class="s1">else if (window.onerror)</span><span class="s3">\n        </span><span class="s1">window.onerror(String(exception), context, undefined, undefined, exception);</span><span class="s3">\n    </span><span class="s1">else if (context)</span><span class="s3">\n        </span><span class="s1">console.error(context + </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">, exception);</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">console.error(exception);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const editable = /*@__PURE__*/Facet.define({ combine: values =&gt; values.length ? values[0] : true });</span><span class="s3">\n</span><span class="s1">let nextPluginID = 0;</span><span class="s3">\n</span><span class="s1">const viewPlugin = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">View plugins associate stateful values with a view. They can</span><span class="s3">\n</span><span class="s1">influence the way the content is drawn, and are notified of things</span><span class="s3">\n</span><span class="s1">that happen in the view.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class ViewPlugin {</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">id, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">create, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">domEventHandlers, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">domEventObservers, buildExtensions) {</span><span class="s3">\n        </span><span class="s1">this.id = id;</span><span class="s3">\n        </span><span class="s1">this.create = create;</span><span class="s3">\n        </span><span class="s1">this.domEventHandlers = domEventHandlers;</span><span class="s3">\n        </span><span class="s1">this.domEventObservers = domEventObservers;</span><span class="s3">\n        </span><span class="s1">this.extension = buildExtensions(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Define a plugin from a constructor function that creates the</span><span class="s3">\n    </span><span class="s1">plugin's value, given an editor view.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static define(create, spec) {</span><span class="s3">\n        </span><span class="s1">const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};</span><span class="s3">\n        </span><span class="s1">return new ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, plugin =&gt; {</span><span class="s3">\n            </span><span class="s1">let ext = [viewPlugin.of(plugin)];</span><span class="s3">\n            </span><span class="s1">if (deco)</span><span class="s3">\n                </span><span class="s1">ext.push(decorations.of(view =&gt; {</span><span class="s3">\n                    </span><span class="s1">let pluginInst = view.plugin(plugin);</span><span class="s3">\n                    </span><span class="s1">return pluginInst ? deco(pluginInst) : Decoration.none;</span><span class="s3">\n                </span><span class="s1">}));</span><span class="s3">\n            </span><span class="s1">if (provide)</span><span class="s3">\n                </span><span class="s1">ext.push(provide(plugin));</span><span class="s3">\n            </span><span class="s1">return ext;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a plugin for a class whose constructor takes a single</span><span class="s3">\n    </span><span class="s1">editor view as argument.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static fromClass(cls, spec) {</span><span class="s3">\n        </span><span class="s1">return ViewPlugin.define(view =&gt; new cls(view), spec);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class PluginInstance {</span><span class="s3">\n    </span><span class="s1">constructor(spec) {</span><span class="s3">\n        </span><span class="s1">this.spec = spec;</span><span class="s3">\n        </span><span class="s1">// When starting an update, all plugins have this field set to the</span><span class="s3">\n        </span><span class="s1">// update object, indicating they need to be updated. When finished</span><span class="s3">\n        </span><span class="s1">// updating, it is set to `false`. Retrieving a plugin that needs to</span><span class="s3">\n        </span><span class="s1">// be updated with `view.plugin` forces an eager update.</span><span class="s3">\n        </span><span class="s1">this.mustUpdate = null;</span><span class="s3">\n        </span><span class="s1">// This is null when the plugin is initially created, but</span><span class="s3">\n        </span><span class="s1">// initialized on the first update.</span><span class="s3">\n        </span><span class="s1">this.value = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(view) {</span><span class="s3">\n        </span><span class="s1">if (!this.value) {</span><span class="s3">\n            </span><span class="s1">if (this.spec) {</span><span class="s3">\n                </span><span class="s1">try {</span><span class="s3">\n                    </span><span class="s1">this.value = this.spec.create(view);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">catch (e) {</span><span class="s3">\n                    </span><span class="s1">logException(view.state, e, </span><span class="s3">\&quot;</span><span class="s1">CodeMirror plugin crashed</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                    </span><span class="s1">this.deactivate();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (this.mustUpdate) {</span><span class="s3">\n            </span><span class="s1">let update = this.mustUpdate;</span><span class="s3">\n            </span><span class="s1">this.mustUpdate = null;</span><span class="s3">\n            </span><span class="s1">if (this.value.update) {</span><span class="s3">\n                </span><span class="s1">try {</span><span class="s3">\n                    </span><span class="s1">this.value.update(update);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">catch (e) {</span><span class="s3">\n                    </span><span class="s1">logException(update.state, e, </span><span class="s3">\&quot;</span><span class="s1">CodeMirror plugin crashed</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                    </span><span class="s1">if (this.value.destroy)</span><span class="s3">\n                        </span><span class="s1">try {</span><span class="s3">\n                            </span><span class="s1">this.value.destroy();</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">catch (_) { }</span><span class="s3">\n                    </span><span class="s1">this.deactivate();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">destroy(view) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">this.value.destroy();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">catch (e) {</span><span class="s3">\n                </span><span class="s1">logException(view.state, e, </span><span class="s3">\&quot;</span><span class="s1">CodeMirror plugin crashed</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">deactivate() {</span><span class="s3">\n        </span><span class="s1">this.spec = this.value = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const editorAttributes = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const contentAttributes = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">// Provide decorations</span><span class="s3">\n</span><span class="s1">const decorations = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const outerDecorations = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const atomicRanges = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const bidiIsolatedRanges = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">function getIsolatedRanges(view, line) {</span><span class="s3">\n    </span><span class="s1">let isolates = view.state.facet(bidiIsolatedRanges);</span><span class="s3">\n    </span><span class="s1">if (!isolates.length)</span><span class="s3">\n        </span><span class="s1">return isolates;</span><span class="s3">\n    </span><span class="s1">let sets = isolates.map(i =&gt; i instanceof Function ? i(view) : i);</span><span class="s3">\n    </span><span class="s1">let result = [];</span><span class="s3">\n    </span><span class="s1">RangeSet.spans(sets, line.from, line.to, {</span><span class="s3">\n        </span><span class="s1">point() { },</span><span class="s3">\n        </span><span class="s1">span(fromDoc, toDoc, active, open) {</span><span class="s3">\n            </span><span class="s1">let from = fromDoc - line.from, to = toDoc - line.from;</span><span class="s3">\n            </span><span class="s1">let level = result;</span><span class="s3">\n            </span><span class="s1">for (let i = active.length - 1; i &gt;= 0; i--, open--) {</span><span class="s3">\n                </span><span class="s1">let direction = active[i].spec.bidiIsolate, update;</span><span class="s3">\n                </span><span class="s1">if (direction == null)</span><span class="s3">\n                    </span><span class="s1">direction = autoDirection(line.text, from, to);</span><span class="s3">\n                </span><span class="s1">if (open &gt; 0 &amp;&amp; level.length &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">(update = level[level.length - 1]).to == from &amp;&amp; update.direction == direction) {</span><span class="s3">\n                    </span><span class="s1">update.to = to;</span><span class="s3">\n                    </span><span class="s1">level = update.inner;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">let add = { from, to, direction, inner: [] };</span><span class="s3">\n                    </span><span class="s1">level.push(add);</span><span class="s3">\n                    </span><span class="s1">level = add.inner;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const scrollMargins = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">function getScrollMargins(view) {</span><span class="s3">\n    </span><span class="s1">let left = 0, right = 0, top = 0, bottom = 0;</span><span class="s3">\n    </span><span class="s1">for (let source of view.state.facet(scrollMargins)) {</span><span class="s3">\n        </span><span class="s1">let m = source(view);</span><span class="s3">\n        </span><span class="s1">if (m) {</span><span class="s3">\n            </span><span class="s1">if (m.left != null)</span><span class="s3">\n                </span><span class="s1">left = Math.max(left, m.left);</span><span class="s3">\n            </span><span class="s1">if (m.right != null)</span><span class="s3">\n                </span><span class="s1">right = Math.max(right, m.right);</span><span class="s3">\n            </span><span class="s1">if (m.top != null)</span><span class="s3">\n                </span><span class="s1">top = Math.max(top, m.top);</span><span class="s3">\n            </span><span class="s1">if (m.bottom != null)</span><span class="s3">\n                </span><span class="s1">bottom = Math.max(bottom, m.bottom);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return { left, right, top, bottom };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const styleModule = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">class ChangedRange {</span><span class="s3">\n    </span><span class="s1">constructor(fromA, toA, fromB, toB) {</span><span class="s3">\n        </span><span class="s1">this.fromA = fromA;</span><span class="s3">\n        </span><span class="s1">this.toA = toA;</span><span class="s3">\n        </span><span class="s1">this.fromB = fromB;</span><span class="s3">\n        </span><span class="s1">this.toB = toB;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">join(other) {</span><span class="s3">\n        </span><span class="s1">return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addToSet(set) {</span><span class="s3">\n        </span><span class="s1">let i = set.length, me = this;</span><span class="s3">\n        </span><span class="s1">for (; i &gt; 0; i--) {</span><span class="s3">\n            </span><span class="s1">let range = set[i - 1];</span><span class="s3">\n            </span><span class="s1">if (range.fromA &gt; me.toA)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">if (range.toA &lt; me.fromA)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">me = me.join(range);</span><span class="s3">\n            </span><span class="s1">set.splice(i - 1, 1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">set.splice(i, 0, me);</span><span class="s3">\n        </span><span class="s1">return set;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static extendWithRanges(diff, ranges) {</span><span class="s3">\n        </span><span class="s1">if (ranges.length == 0)</span><span class="s3">\n            </span><span class="s1">return diff;</span><span class="s3">\n        </span><span class="s1">let result = [];</span><span class="s3">\n        </span><span class="s1">for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {</span><span class="s3">\n            </span><span class="s1">let next = dI == diff.length ? null : diff[dI], off = posA - posB;</span><span class="s3">\n            </span><span class="s1">let end = next ? next.fromB : 1e9;</span><span class="s3">\n            </span><span class="s1">while (rI &lt; ranges.length &amp;&amp; ranges[rI] &lt; end) {</span><span class="s3">\n                </span><span class="s1">let from = ranges[rI], to = ranges[rI + 1];</span><span class="s3">\n                </span><span class="s1">let fromB = Math.max(posB, from), toB = Math.min(end, to);</span><span class="s3">\n                </span><span class="s1">if (fromB &lt;= toB)</span><span class="s3">\n                    </span><span class="s1">new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);</span><span class="s3">\n                </span><span class="s1">if (to &gt; end)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">rI += 2;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!next)</span><span class="s3">\n                </span><span class="s1">return result;</span><span class="s3">\n            </span><span class="s1">new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);</span><span class="s3">\n            </span><span class="s1">posA = next.toA;</span><span class="s3">\n            </span><span class="s1">posB = next.toB;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">View [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this</span><span class="s3">\n</span><span class="s1">class, which describe what happened, whenever the view is updated.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class ViewUpdate {</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The editor view that the update is associated with.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">view, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The new editor state.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">state, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The transactions involved in the update. May be empty.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">transactions) {</span><span class="s3">\n        </span><span class="s1">this.view = view;</span><span class="s3">\n        </span><span class="s1">this.state = state;</span><span class="s3">\n        </span><span class="s1">this.transactions = transactions;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">@internal</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.flags = 0;</span><span class="s3">\n        </span><span class="s1">this.startState = view.state;</span><span class="s3">\n        </span><span class="s1">this.changes = ChangeSet.empty(this.startState.doc.length);</span><span class="s3">\n        </span><span class="s1">for (let tr of transactions)</span><span class="s3">\n            </span><span class="s1">this.changes = this.changes.compose(tr.changes);</span><span class="s3">\n        </span><span class="s1">let changedRanges = [];</span><span class="s3">\n        </span><span class="s1">this.changes.iterChangedRanges((fromA, toA, fromB, toB) =&gt; changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));</span><span class="s3">\n        </span><span class="s1">this.changedRanges = changedRanges;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static create(view, state, transactions) {</span><span class="s3">\n        </span><span class="s1">return new ViewUpdate(view, state, transactions);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or</span><span class="s3">\n    </span><span class="s1">[visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this</span><span class="s3">\n    </span><span class="s1">update.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get viewportChanged() {</span><span class="s3">\n        </span><span class="s1">return (this.flags &amp; 4 /* UpdateFlag.Viewport */) &gt; 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Returns true when</span><span class="s3">\n    </span><span class="s1">[`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true</span><span class="s3">\n    </span><span class="s1">and the viewport change is not just the result of mapping it in</span><span class="s3">\n    </span><span class="s1">response to document changes.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get viewportMoved() {</span><span class="s3">\n        </span><span class="s1">return (this.flags &amp; 8 /* UpdateFlag.ViewportMoved */) &gt; 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Indicates whether the height of a block element in the editor</span><span class="s3">\n    </span><span class="s1">changed in this update.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get heightChanged() {</span><span class="s3">\n        </span><span class="s1">return (this.flags &amp; 2 /* UpdateFlag.Height */) &gt; 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Returns true when the document was modified or the size of the</span><span class="s3">\n    </span><span class="s1">editor, or elements within the editor, changed.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get geometryChanged() {</span><span class="s3">\n        </span><span class="s1">return this.docChanged || (this.flags &amp; (16 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */)) &gt; 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">True when this update indicates a focus change.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get focusChanged() {</span><span class="s3">\n        </span><span class="s1">return (this.flags &amp; 1 /* UpdateFlag.Focus */) &gt; 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Whether the document changed in this update.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get docChanged() {</span><span class="s3">\n        </span><span class="s1">return !this.changes.empty;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Whether the selection was explicitly set in this update.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get selectionSet() {</span><span class="s3">\n        </span><span class="s1">return this.transactions.some(tr =&gt; tr.selection);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get empty() { return this.flags == 0 &amp;&amp; this.transactions.length == 0; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class DocView extends ContentView {</span><span class="s3">\n    </span><span class="s1">get length() { return this.view.state.doc.length; }</span><span class="s3">\n    </span><span class="s1">constructor(view) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.view = view;</span><span class="s3">\n        </span><span class="s1">this.decorations = [];</span><span class="s3">\n        </span><span class="s1">this.dynamicDecorationMap = [false];</span><span class="s3">\n        </span><span class="s1">this.domChanged = null;</span><span class="s3">\n        </span><span class="s1">this.hasComposition = null;</span><span class="s3">\n        </span><span class="s1">this.markedForComposition = new Set;</span><span class="s3">\n        </span><span class="s1">this.editContextFormatting = Decoration.none;</span><span class="s3">\n        </span><span class="s1">this.lastCompositionAfterCursor = false;</span><span class="s3">\n        </span><span class="s1">// Track a minimum width for the editor. When measuring sizes in</span><span class="s3">\n        </span><span class="s1">// measureVisibleLineHeights, this is updated to point at the width</span><span class="s3">\n        </span><span class="s1">// of a given element and its extent in the document. When a change</span><span class="s3">\n        </span><span class="s1">// happens in that range, these are reset. That way, once we've seen</span><span class="s3">\n        </span><span class="s1">// a line/element of a given length, we keep the editor wide enough</span><span class="s3">\n        </span><span class="s1">// to fit at least that element, until it is changed, at which point</span><span class="s3">\n        </span><span class="s1">// we forget it again.</span><span class="s3">\n        </span><span class="s1">this.minWidth = 0;</span><span class="s3">\n        </span><span class="s1">this.minWidthFrom = 0;</span><span class="s3">\n        </span><span class="s1">this.minWidthTo = 0;</span><span class="s3">\n        </span><span class="s1">// Track whether the DOM selection was set in a lossy way, so that</span><span class="s3">\n        </span><span class="s1">// we don't mess it up when reading it back it</span><span class="s3">\n        </span><span class="s1">this.impreciseAnchor = null;</span><span class="s3">\n        </span><span class="s1">this.impreciseHead = null;</span><span class="s3">\n        </span><span class="s1">this.forceSelection = false;</span><span class="s3">\n        </span><span class="s1">// Used by the resize observer to ignore resizes that we caused</span><span class="s3">\n        </span><span class="s1">// ourselves</span><span class="s3">\n        </span><span class="s1">this.lastUpdate = Date.now();</span><span class="s3">\n        </span><span class="s1">this.setDOM(view.contentDOM);</span><span class="s3">\n        </span><span class="s1">this.children = [new LineView];</span><span class="s3">\n        </span><span class="s1">this.children[0].setParent(this);</span><span class="s3">\n        </span><span class="s1">this.updateDeco();</span><span class="s3">\n        </span><span class="s1">this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Update the document view to a given state.</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">let changedRanges = update.changedRanges;</span><span class="s3">\n        </span><span class="s1">if (this.minWidth &gt; 0 &amp;&amp; changedRanges.length) {</span><span class="s3">\n            </span><span class="s1">if (!changedRanges.every(({ fromA, toA }) =&gt; toA &lt; this.minWidthFrom || fromA &gt; this.minWidthTo)) {</span><span class="s3">\n                </span><span class="s1">this.minWidth = this.minWidthFrom = this.minWidthTo = 0;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);</span><span class="s3">\n                </span><span class="s1">this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.updateEditContextFormatting(update);</span><span class="s3">\n        </span><span class="s1">let readCompositionAt = -1;</span><span class="s3">\n        </span><span class="s1">if (this.view.inputState.composing &gt;= 0 &amp;&amp; !this.view.observer.editContext) {</span><span class="s3">\n            </span><span class="s1">if ((_a = this.domChanged) === null || _a === void 0 ? void 0 : _a.newSel)</span><span class="s3">\n                </span><span class="s1">readCompositionAt = this.domChanged.newSel.head;</span><span class="s3">\n            </span><span class="s1">else if (!touchesComposition(update.changes, this.hasComposition) &amp;&amp; !update.selectionSet)</span><span class="s3">\n                </span><span class="s1">readCompositionAt = update.state.selection.main.head;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let composition = readCompositionAt &gt; -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;</span><span class="s3">\n        </span><span class="s1">this.domChanged = null;</span><span class="s3">\n        </span><span class="s1">if (this.hasComposition) {</span><span class="s3">\n            </span><span class="s1">this.markedForComposition.clear();</span><span class="s3">\n            </span><span class="s1">let { from, to } = this.hasComposition;</span><span class="s3">\n            </span><span class="s1">changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1))</span><span class="s3">\n                </span><span class="s1">.addToSet(changedRanges.slice());</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;</span><span class="s3">\n        </span><span class="s1">// When the DOM nodes around the selection are moved to another</span><span class="s3">\n        </span><span class="s1">// parent, Chrome sometimes reports a different selection through</span><span class="s3">\n        </span><span class="s1">// getSelection than the one that it actually shows to the user.</span><span class="s3">\n        </span><span class="s1">// This forces a selection update when lines are joined to work</span><span class="s3">\n        </span><span class="s1">// around that. Issue #54</span><span class="s3">\n        </span><span class="s1">if ((browser.ie || browser.chrome) &amp;&amp; !composition &amp;&amp; update &amp;&amp;</span><span class="s3">\n            </span><span class="s1">update.state.doc.lines != update.startState.doc.lines)</span><span class="s3">\n            </span><span class="s1">this.forceSelection = true;</span><span class="s3">\n        </span><span class="s1">let prevDeco = this.decorations, deco = this.updateDeco();</span><span class="s3">\n        </span><span class="s1">let decoDiff = findChangedDeco(prevDeco, deco, update.changes);</span><span class="s3">\n        </span><span class="s1">changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);</span><span class="s3">\n        </span><span class="s1">if (!(this.flags &amp; 7 /* ViewFlag.Dirty */) &amp;&amp; changedRanges.length == 0) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.updateInner(changedRanges, update.startState.doc.length, composition);</span><span class="s3">\n            </span><span class="s1">if (update.transactions.length)</span><span class="s3">\n                </span><span class="s1">this.lastUpdate = Date.now();</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Used by update and the constructor do perform the actual DOM</span><span class="s3">\n    </span><span class="s1">// update</span><span class="s3">\n    </span><span class="s1">updateInner(changes, oldLength, composition) {</span><span class="s3">\n        </span><span class="s1">this.view.viewState.mustMeasureContent = true;</span><span class="s3">\n        </span><span class="s1">this.updateChildren(changes, oldLength, composition);</span><span class="s3">\n        </span><span class="s1">let { observer } = this.view;</span><span class="s3">\n        </span><span class="s1">observer.ignore(() =&gt; {</span><span class="s3">\n            </span><span class="s1">// Lock the height during redrawing, since Chrome sometimes</span><span class="s3">\n            </span><span class="s1">// messes with the scroll position during DOM mutation (though</span><span class="s3">\n            </span><span class="s1">// no relayout is triggered and I cannot imagine how it can</span><span class="s3">\n            </span><span class="s1">// recompute the scroll position without a layout)</span><span class="s3">\n            </span><span class="s1">this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">this.dom.style.flexBasis = this.minWidth ? this.minWidth + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">// Chrome will sometimes, when DOM mutations occur directly</span><span class="s3">\n            </span><span class="s1">// around the selection, get confused and report a different</span><span class="s3">\n            </span><span class="s1">// selection from the one it displays (issue #218). This tries</span><span class="s3">\n            </span><span class="s1">// to detect that situation.</span><span class="s3">\n            </span><span class="s1">let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : undefined;</span><span class="s3">\n            </span><span class="s1">this.sync(this.view, track);</span><span class="s3">\n            </span><span class="s1">this.flags &amp;= ~7 /* ViewFlag.Dirty */;</span><span class="s3">\n            </span><span class="s1">if (track &amp;&amp; (track.written || observer.selectionRange.focusNode != track.node))</span><span class="s3">\n                </span><span class="s1">this.forceSelection = true;</span><span class="s3">\n            </span><span class="s1">this.dom.style.height = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.markedForComposition.forEach(cView =&gt; cView.flags &amp;= ~8 /* ViewFlag.Composition */);</span><span class="s3">\n        </span><span class="s1">let gaps = [];</span><span class="s3">\n        </span><span class="s1">if (this.view.viewport.from || this.view.viewport.to &lt; this.view.state.doc.length)</span><span class="s3">\n            </span><span class="s1">for (let child of this.children)</span><span class="s3">\n                </span><span class="s1">if (child instanceof BlockWidgetView &amp;&amp; child.widget instanceof BlockGapWidget)</span><span class="s3">\n                    </span><span class="s1">gaps.push(child.dom);</span><span class="s3">\n        </span><span class="s1">observer.updateGaps(gaps);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateChildren(changes, oldLength, composition) {</span><span class="s3">\n        </span><span class="s1">let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;</span><span class="s3">\n        </span><span class="s1">let cursor = this.childCursor(oldLength);</span><span class="s3">\n        </span><span class="s1">for (let i = ranges.length - 1;; i--) {</span><span class="s3">\n            </span><span class="s1">let next = i &gt;= 0 ? ranges[i] : null;</span><span class="s3">\n            </span><span class="s1">if (!next)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">let { fromA, toA, fromB, toB } = next, content, breakAtStart, openStart, openEnd;</span><span class="s3">\n            </span><span class="s1">if (composition &amp;&amp; composition.range.fromB &lt; toB &amp;&amp; composition.range.toB &gt; fromB) {</span><span class="s3">\n                </span><span class="s1">let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);</span><span class="s3">\n                </span><span class="s1">let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);</span><span class="s3">\n                </span><span class="s1">breakAtStart = before.breakAtStart;</span><span class="s3">\n                </span><span class="s1">openStart = before.openStart;</span><span class="s3">\n                </span><span class="s1">openEnd = after.openEnd;</span><span class="s3">\n                </span><span class="s1">let compLine = this.compositionView(composition);</span><span class="s3">\n                </span><span class="s1">if (after.breakAtStart) {</span><span class="s3">\n                    </span><span class="s1">compLine.breakAfter = 1;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (after.content.length &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {</span><span class="s3">\n                    </span><span class="s1">compLine.breakAfter = after.content[0].breakAfter;</span><span class="s3">\n                    </span><span class="s1">after.content.shift();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (before.content.length &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {</span><span class="s3">\n                    </span><span class="s1">before.content.pop();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">content = before.content.concat(compLine).concat(after.content);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">({ content, breakAtStart, openStart, openEnd } =</span><span class="s3">\n                    </span><span class="s1">ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let { i: toI, off: toOff } = cursor.findPos(toA, 1);</span><span class="s3">\n            </span><span class="s1">let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);</span><span class="s3">\n            </span><span class="s1">replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (composition)</span><span class="s3">\n            </span><span class="s1">this.fixCompositionDOM(composition);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateEditContextFormatting(update) {</span><span class="s3">\n        </span><span class="s1">this.editContextFormatting = this.editContextFormatting.map(update.changes);</span><span class="s3">\n        </span><span class="s1">for (let tr of update.transactions)</span><span class="s3">\n            </span><span class="s1">for (let effect of tr.effects)</span><span class="s3">\n                </span><span class="s1">if (effect.is(setEditContextFormatting)) {</span><span class="s3">\n                    </span><span class="s1">this.editContextFormatting = effect.value;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">compositionView(composition) {</span><span class="s3">\n        </span><span class="s1">let cur = new TextView(composition.text.nodeValue);</span><span class="s3">\n        </span><span class="s1">cur.flags |= 8 /* ViewFlag.Composition */;</span><span class="s3">\n        </span><span class="s1">for (let { deco } of composition.marks)</span><span class="s3">\n            </span><span class="s1">cur = new MarkView(deco, [cur], cur.length);</span><span class="s3">\n        </span><span class="s1">let line = new LineView;</span><span class="s3">\n        </span><span class="s1">line.append(cur, 0);</span><span class="s3">\n        </span><span class="s1">return line;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fixCompositionDOM(composition) {</span><span class="s3">\n        </span><span class="s1">let fix = (dom, cView) =&gt; {</span><span class="s3">\n            </span><span class="s1">cView.flags |= 8 /* ViewFlag.Composition */ | (cView.children.some(c =&gt; c.flags &amp; 7 /* ViewFlag.Dirty */) ? 1 /* ViewFlag.ChildDirty */ : 0);</span><span class="s3">\n            </span><span class="s1">this.markedForComposition.add(cView);</span><span class="s3">\n            </span><span class="s1">let prev = ContentView.get(dom);</span><span class="s3">\n            </span><span class="s1">if (prev &amp;&amp; prev != cView)</span><span class="s3">\n                </span><span class="s1">prev.dom = null;</span><span class="s3">\n            </span><span class="s1">cView.setDOM(dom);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">let pos = this.childPos(composition.range.fromB, 1);</span><span class="s3">\n        </span><span class="s1">let cView = this.children[pos.i];</span><span class="s3">\n        </span><span class="s1">fix(composition.line, cView);</span><span class="s3">\n        </span><span class="s1">for (let i = composition.marks.length - 1; i &gt;= -1; i--) {</span><span class="s3">\n            </span><span class="s1">pos = cView.childPos(pos.off, 1);</span><span class="s3">\n            </span><span class="s1">cView = cView.children[pos.i];</span><span class="s3">\n            </span><span class="s1">fix(i &gt;= 0 ? composition.marks[i].node : composition.text, cView);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Sync the DOM selection to this.state.selection</span><span class="s3">\n    </span><span class="s1">updateSelection(mustRead = false, fromPointer = false) {</span><span class="s3">\n        </span><span class="s1">if (mustRead || !this.view.observer.selectionRange.focusNode)</span><span class="s3">\n            </span><span class="s1">this.view.observer.readSelectionRange();</span><span class="s3">\n        </span><span class="s1">let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;</span><span class="s3">\n        </span><span class="s1">let selectionNotFocus = !focused &amp;&amp; !(this.view.state.facet(editable) || this.dom.tabIndex &gt; -1) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">hasSelection(this.dom, this.view.observer.selectionRange) &amp;&amp; !(activeElt &amp;&amp; this.dom.contains(activeElt));</span><span class="s3">\n        </span><span class="s1">if (!(focused || fromPointer || selectionNotFocus))</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">let force = this.forceSelection;</span><span class="s3">\n        </span><span class="s1">this.forceSelection = false;</span><span class="s3">\n        </span><span class="s1">let main = this.view.state.selection.main;</span><span class="s3">\n        </span><span class="s1">let anchor = this.moveToLine(this.domAtPos(main.anchor));</span><span class="s3">\n        </span><span class="s1">let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));</span><span class="s3">\n        </span><span class="s1">// Always reset on Firefox when next to an uneditable node to</span><span class="s3">\n        </span><span class="s1">// avoid invisible cursor bugs (#111)</span><span class="s3">\n        </span><span class="s1">if (browser.gecko &amp;&amp; main.empty &amp;&amp; !this.hasComposition &amp;&amp; betweenUneditable(anchor)) {</span><span class="s3">\n            </span><span class="s1">let dummy = document.createTextNode(</span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">this.view.observer.ignore(() =&gt; anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));</span><span class="s3">\n            </span><span class="s1">anchor = head = new DOMPos(dummy, 0);</span><span class="s3">\n            </span><span class="s1">force = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let domSel = this.view.observer.selectionRange;</span><span class="s3">\n        </span><span class="s1">// If the selection is already here, or in an equivalent position, don't touch it</span><span class="s3">\n        </span><span class="s1">if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) ||</span><span class="s3">\n            </span><span class="s1">!isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) &amp;&amp; !this.suppressWidgetCursorChange(domSel, main)) {</span><span class="s3">\n            </span><span class="s1">this.view.observer.ignore(() =&gt; {</span><span class="s3">\n                </span><span class="s1">// Chrome Android will hide the virtual keyboard when tapping</span><span class="s3">\n                </span><span class="s1">// inside an uneditable node, and not bring it back when we</span><span class="s3">\n                </span><span class="s1">// move the cursor to its proper position. This tries to</span><span class="s3">\n                </span><span class="s1">// restore the keyboard by cycling focus.</span><span class="s3">\n                </span><span class="s1">if (browser.android &amp;&amp; browser.chrome &amp;&amp; this.dom.contains(domSel.focusNode) &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">inUneditable(domSel.focusNode, this.dom)) {</span><span class="s3">\n                    </span><span class="s1">this.dom.blur();</span><span class="s3">\n                    </span><span class="s1">this.dom.focus({ preventScroll: true });</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">let rawSel = getSelection(this.view.root);</span><span class="s3">\n                </span><span class="s1">if (!rawSel) ;</span><span class="s3">\n                </span><span class="s1">else if (main.empty) {</span><span class="s3">\n                    </span><span class="s1">// Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076</span><span class="s3">\n                    </span><span class="s1">if (browser.gecko) {</span><span class="s3">\n                        </span><span class="s1">let nextTo = nextToUneditable(anchor.node, anchor.offset);</span><span class="s3">\n                        </span><span class="s1">if (nextTo &amp;&amp; nextTo != (1 /* NextTo.Before */ | 2 /* NextTo.After */)) {</span><span class="s3">\n                            </span><span class="s1">let text = (nextTo == 1 /* NextTo.Before */ ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);</span><span class="s3">\n                            </span><span class="s1">if (text)</span><span class="s3">\n                                </span><span class="s1">anchor = new DOMPos(text.node, text.offset);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">rawSel.collapse(anchor.node, anchor.offset);</span><span class="s3">\n                    </span><span class="s1">if (main.bidiLevel != null &amp;&amp; rawSel.caretBidiLevel !== undefined)</span><span class="s3">\n                        </span><span class="s1">rawSel.caretBidiLevel = main.bidiLevel;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (rawSel.extend) {</span><span class="s3">\n                    </span><span class="s1">// Selection.extend can be used to create an 'inverted' selection</span><span class="s3">\n                    </span><span class="s1">// (one where the focus is before the anchor), but not all</span><span class="s3">\n                    </span><span class="s1">// browsers support it yet.</span><span class="s3">\n                    </span><span class="s1">rawSel.collapse(anchor.node, anchor.offset);</span><span class="s3">\n                    </span><span class="s1">// Safari will ignore the call above when the editor is</span><span class="s3">\n                    </span><span class="s1">// hidden, and then raise an error on the call to extend</span><span class="s3">\n                    </span><span class="s1">// (#940).</span><span class="s3">\n                    </span><span class="s1">try {</span><span class="s3">\n                        </span><span class="s1">rawSel.extend(head.node, head.offset);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">catch (_) { }</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">// Primitive (IE) way</span><span class="s3">\n                    </span><span class="s1">let range = document.createRange();</span><span class="s3">\n                    </span><span class="s1">if (main.anchor &gt; main.head)</span><span class="s3">\n                        </span><span class="s1">[anchor, head] = [head, anchor];</span><span class="s3">\n                    </span><span class="s1">range.setEnd(head.node, head.offset);</span><span class="s3">\n                    </span><span class="s1">range.setStart(anchor.node, anchor.offset);</span><span class="s3">\n                    </span><span class="s1">rawSel.removeAllRanges();</span><span class="s3">\n                    </span><span class="s1">rawSel.addRange(range);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (selectionNotFocus &amp;&amp; this.view.root.activeElement == this.dom) {</span><span class="s3">\n                    </span><span class="s1">this.dom.blur();</span><span class="s3">\n                    </span><span class="s1">if (activeElt)</span><span class="s3">\n                        </span><span class="s1">activeElt.focus();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">this.view.observer.setSelectionRange(anchor, head);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);</span><span class="s3">\n        </span><span class="s1">this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// If a zero-length widget is inserted next to the cursor during</span><span class="s3">\n    </span><span class="s1">// composition, avoid moving it across it and disrupting the</span><span class="s3">\n    </span><span class="s1">// composition.</span><span class="s3">\n    </span><span class="s1">suppressWidgetCursorChange(sel, cursor) {</span><span class="s3">\n        </span><span class="s1">return this.hasComposition &amp;&amp; cursor.empty &amp;&amp;</span><span class="s3">\n            </span><span class="s1">isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor.head;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">enforceCursorAssoc() {</span><span class="s3">\n        </span><span class="s1">if (this.hasComposition)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">let { view } = this, cursor = view.state.selection.main;</span><span class="s3">\n        </span><span class="s1">let sel = getSelection(view.root);</span><span class="s3">\n        </span><span class="s1">let { anchorNode, anchorOffset } = view.observer.selectionRange;</span><span class="s3">\n        </span><span class="s1">if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">let line = LineView.find(this, cursor.head);</span><span class="s3">\n        </span><span class="s1">if (!line)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">let lineStart = line.posAtStart;</span><span class="s3">\n        </span><span class="s1">if (cursor.head == lineStart || cursor.head == lineStart + line.length)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);</span><span class="s3">\n        </span><span class="s1">if (!before || !after || before.bottom &gt; after.top)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">let dom = this.domAtPos(cursor.head + cursor.assoc);</span><span class="s3">\n        </span><span class="s1">sel.collapse(dom.node, dom.offset);</span><span class="s3">\n        </span><span class="s1">sel.modify(</span><span class="s3">\&quot;</span><span class="s1">move</span><span class="s3">\&quot;</span><span class="s1">, cursor.assoc &lt; 0 ? </span><span class="s3">\&quot;</span><span class="s1">forward</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">backward</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">lineboundary</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">// This can go wrong in corner cases like single-character lines,</span><span class="s3">\n        </span><span class="s1">// so check and reset if necessary.</span><span class="s3">\n        </span><span class="s1">view.observer.readSelectionRange();</span><span class="s3">\n        </span><span class="s1">let newRange = view.observer.selectionRange;</span><span class="s3">\n        </span><span class="s1">if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)</span><span class="s3">\n            </span><span class="s1">sel.collapse(anchorNode, anchorOffset);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// If a position is in/near a block widget, move it to a nearby text</span><span class="s3">\n    </span><span class="s1">// line, since we don't want the cursor inside a block widget.</span><span class="s3">\n    </span><span class="s1">moveToLine(pos) {</span><span class="s3">\n        </span><span class="s1">// Block widgets will return positions before/after them, which</span><span class="s3">\n        </span><span class="s1">// are thus directly in the document DOM element.</span><span class="s3">\n        </span><span class="s1">let dom = this.dom, newPos;</span><span class="s3">\n        </span><span class="s1">if (pos.node != dom)</span><span class="s3">\n            </span><span class="s1">return pos;</span><span class="s3">\n        </span><span class="s1">for (let i = pos.offset; !newPos &amp;&amp; i &lt; dom.childNodes.length; i++) {</span><span class="s3">\n            </span><span class="s1">let view = ContentView.get(dom.childNodes[i]);</span><span class="s3">\n            </span><span class="s1">if (view instanceof LineView)</span><span class="s3">\n                </span><span class="s1">newPos = view.domAtPos(0);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let i = pos.offset - 1; !newPos &amp;&amp; i &gt;= 0; i--) {</span><span class="s3">\n            </span><span class="s1">let view = ContentView.get(dom.childNodes[i]);</span><span class="s3">\n            </span><span class="s1">if (view instanceof LineView)</span><span class="s3">\n                </span><span class="s1">newPos = view.domAtPos(view.length);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nearest(dom) {</span><span class="s3">\n        </span><span class="s1">for (let cur = dom; cur;) {</span><span class="s3">\n            </span><span class="s1">let domView = ContentView.get(cur);</span><span class="s3">\n            </span><span class="s1">if (domView &amp;&amp; domView.rootView == this)</span><span class="s3">\n                </span><span class="s1">return domView;</span><span class="s3">\n            </span><span class="s1">cur = cur.parentNode;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">posFromDOM(node, offset) {</span><span class="s3">\n        </span><span class="s1">let view = this.nearest(node);</span><span class="s3">\n        </span><span class="s1">if (!view)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Trying to find position for a DOM position outside of the document</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return view.localPosFromDOM(node, offset) + view.posAtStart;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">domAtPos(pos) {</span><span class="s3">\n        </span><span class="s1">let { i, off } = this.childCursor().findPos(pos, -1);</span><span class="s3">\n        </span><span class="s1">for (; i &lt; this.children.length - 1;) {</span><span class="s3">\n            </span><span class="s1">let child = this.children[i];</span><span class="s3">\n            </span><span class="s1">if (off &lt; child.length || child instanceof LineView)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">i++;</span><span class="s3">\n            </span><span class="s1">off = 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.children[i].domAtPos(off);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">coordsAt(pos, side) {</span><span class="s3">\n        </span><span class="s1">let best = null, bestPos = 0;</span><span class="s3">\n        </span><span class="s1">for (let off = this.length, i = this.children.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n            </span><span class="s1">let child = this.children[i], end = off - child.breakAfter, start = end - child.length;</span><span class="s3">\n            </span><span class="s1">if (end &lt; pos)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">if (start &lt;= pos &amp;&amp; (start &lt; pos || child.covers(-1)) &amp;&amp; (end &gt; pos || child.covers(1)) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(!best || child instanceof LineView &amp;&amp; !(best instanceof LineView &amp;&amp; side &gt;= 0))) {</span><span class="s3">\n                </span><span class="s1">best = child;</span><span class="s3">\n                </span><span class="s1">bestPos = start;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (best &amp;&amp; start == pos &amp;&amp; end == pos &amp;&amp; child instanceof BlockWidgetView &amp;&amp; Math.abs(side) &lt; 2) {</span><span class="s3">\n                </span><span class="s1">if (child.deco.startSide &lt; 0)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">else if (i)</span><span class="s3">\n                    </span><span class="s1">best = null;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">off = start;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return best ? best.coordsAt(pos - bestPos, side) : null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">coordsForChar(pos) {</span><span class="s3">\n        </span><span class="s1">let { i, off } = this.childPos(pos, 1), child = this.children[i];</span><span class="s3">\n        </span><span class="s1">if (!(child instanceof LineView))</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">while (child.children.length) {</span><span class="s3">\n            </span><span class="s1">let { i, off: childOff } = child.childPos(off, 1);</span><span class="s3">\n            </span><span class="s1">for (;; i++) {</span><span class="s3">\n                </span><span class="s1">if (i == child.children.length)</span><span class="s3">\n                    </span><span class="s1">return null;</span><span class="s3">\n                </span><span class="s1">if ((child = child.children[i]).length)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">off = childOff;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!(child instanceof TextView))</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">let end = findClusterBreak(child.text, off);</span><span class="s3">\n        </span><span class="s1">if (end == off)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">let rects = textRange(child.dom, off, end).getClientRects();</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; rects.length; i++) {</span><span class="s3">\n            </span><span class="s1">let rect = rects[i];</span><span class="s3">\n            </span><span class="s1">if (i == rects.length - 1 || rect.top &lt; rect.bottom &amp;&amp; rect.left &lt; rect.right)</span><span class="s3">\n                </span><span class="s1">return rect;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">measureVisibleLineHeights(viewport) {</span><span class="s3">\n        </span><span class="s1">let result = [], { from, to } = viewport;</span><span class="s3">\n        </span><span class="s1">let contentWidth = this.view.contentDOM.clientWidth;</span><span class="s3">\n        </span><span class="s1">let isWider = contentWidth &gt; Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;</span><span class="s3">\n        </span><span class="s1">let widest = -1, ltr = this.view.textDirection == Direction.LTR;</span><span class="s3">\n        </span><span class="s1">for (let pos = 0, i = 0; i &lt; this.children.length; i++) {</span><span class="s3">\n            </span><span class="s1">let child = this.children[i], end = pos + child.length;</span><span class="s3">\n            </span><span class="s1">if (end &gt; to)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">if (pos &gt;= from) {</span><span class="s3">\n                </span><span class="s1">let childRect = child.dom.getBoundingClientRect();</span><span class="s3">\n                </span><span class="s1">result.push(childRect.height);</span><span class="s3">\n                </span><span class="s1">if (isWider) {</span><span class="s3">\n                    </span><span class="s1">let last = child.dom.lastChild;</span><span class="s3">\n                    </span><span class="s1">let rects = last ? clientRectsFor(last) : [];</span><span class="s3">\n                    </span><span class="s1">if (rects.length) {</span><span class="s3">\n                        </span><span class="s1">let rect = rects[rects.length - 1];</span><span class="s3">\n                        </span><span class="s1">let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;</span><span class="s3">\n                        </span><span class="s1">if (width &gt; widest) {</span><span class="s3">\n                            </span><span class="s1">widest = width;</span><span class="s3">\n                            </span><span class="s1">this.minWidth = contentWidth;</span><span class="s3">\n                            </span><span class="s1">this.minWidthFrom = pos;</span><span class="s3">\n                            </span><span class="s1">this.minWidthTo = end;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">pos = end + child.breakAfter;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">textDirectionAt(pos) {</span><span class="s3">\n        </span><span class="s1">let { i } = this.childPos(pos, 1);</span><span class="s3">\n        </span><span class="s1">return getComputedStyle(this.children[i].dom).direction == </span><span class="s3">\&quot;</span><span class="s1">rtl</span><span class="s3">\&quot; </span><span class="s1">? Direction.RTL : Direction.LTR;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">measureTextSize() {</span><span class="s3">\n        </span><span class="s1">for (let child of this.children) {</span><span class="s3">\n            </span><span class="s1">if (child instanceof LineView) {</span><span class="s3">\n                </span><span class="s1">let measure = child.measureTextSize();</span><span class="s3">\n                </span><span class="s1">if (measure)</span><span class="s3">\n                    </span><span class="s1">return measure;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// If no workable line exists, force a layout of a measurable element</span><span class="s3">\n        </span><span class="s1">let dummy = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">), lineHeight, charWidth, textHeight;</span><span class="s3">\n        </span><span class="s1">dummy.className = </span><span class="s3">\&quot;</span><span class="s1">cm-line</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">dummy.style.width = </span><span class="s3">\&quot;</span><span class="s1">99999px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">dummy.style.position = </span><span class="s3">\&quot;</span><span class="s1">absolute</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">dummy.textContent = </span><span class="s3">\&quot;</span><span class="s1">abc def ghi jkl mno pqr stu</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.view.observer.ignore(() =&gt; {</span><span class="s3">\n            </span><span class="s1">this.dom.appendChild(dummy);</span><span class="s3">\n            </span><span class="s1">let rect = clientRectsFor(dummy.firstChild)[0];</span><span class="s3">\n            </span><span class="s1">lineHeight = dummy.getBoundingClientRect().height;</span><span class="s3">\n            </span><span class="s1">charWidth = rect ? rect.width / 27 : 7;</span><span class="s3">\n            </span><span class="s1">textHeight = rect ? rect.height : lineHeight;</span><span class="s3">\n            </span><span class="s1">dummy.remove();</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return { lineHeight, charWidth, textHeight };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">childCursor(pos = this.length) {</span><span class="s3">\n        </span><span class="s1">// Move back to start of last element when possible, so that</span><span class="s3">\n        </span><span class="s1">// `ChildCursor.findPos` doesn't have to deal with the edge case</span><span class="s3">\n        </span><span class="s1">// of being after the last element.</span><span class="s3">\n        </span><span class="s1">let i = this.children.length;</span><span class="s3">\n        </span><span class="s1">if (i)</span><span class="s3">\n            </span><span class="s1">pos -= this.children[--i].length;</span><span class="s3">\n        </span><span class="s1">return new ChildCursor(this.children, pos, i);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">computeBlockGapDeco() {</span><span class="s3">\n        </span><span class="s1">let deco = [], vs = this.view.viewState;</span><span class="s3">\n        </span><span class="s1">for (let pos = 0, i = 0;; i++) {</span><span class="s3">\n            </span><span class="s1">let next = i == vs.viewports.length ? null : vs.viewports[i];</span><span class="s3">\n            </span><span class="s1">let end = next ? next.from - 1 : this.length;</span><span class="s3">\n            </span><span class="s1">if (end &gt; pos) {</span><span class="s3">\n                </span><span class="s1">let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;</span><span class="s3">\n                </span><span class="s1">deco.push(Decoration.replace({</span><span class="s3">\n                    </span><span class="s1">widget: new BlockGapWidget(height),</span><span class="s3">\n                    </span><span class="s1">block: true,</span><span class="s3">\n                    </span><span class="s1">inclusive: true,</span><span class="s3">\n                    </span><span class="s1">isBlockGap: true,</span><span class="s3">\n                </span><span class="s1">}).range(pos, end));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!next)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">pos = next.to + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return Decoration.set(deco);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateDeco() {</span><span class="s3">\n        </span><span class="s1">let i = 1;</span><span class="s3">\n        </span><span class="s1">let allDeco = this.view.state.facet(decorations).map(d =&gt; {</span><span class="s3">\n            </span><span class="s1">let dynamic = this.dynamicDecorationMap[i++] = typeof d == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">return dynamic ? d(this.view) : d;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d, i) =&gt; {</span><span class="s3">\n            </span><span class="s1">let dynamic = typeof d == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">if (dynamic)</span><span class="s3">\n                </span><span class="s1">dynamicOuter = true;</span><span class="s3">\n            </span><span class="s1">return dynamic ? d(this.view) : d;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">if (outerDeco.length) {</span><span class="s3">\n            </span><span class="s1">this.dynamicDecorationMap[i++] = dynamicOuter;</span><span class="s3">\n            </span><span class="s1">allDeco.push(RangeSet.join(outerDeco));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.decorations = [</span><span class="s3">\n            </span><span class="s1">this.editContextFormatting,</span><span class="s3">\n            </span><span class="s1">...allDeco,</span><span class="s3">\n            </span><span class="s1">this.computeBlockGapDeco(),</span><span class="s3">\n            </span><span class="s1">this.view.viewState.lineGapDeco</span><span class="s3">\n        </span><span class="s1">];</span><span class="s3">\n        </span><span class="s1">while (i &lt; this.decorations.length)</span><span class="s3">\n            </span><span class="s1">this.dynamicDecorationMap[i++] = false;</span><span class="s3">\n        </span><span class="s1">return this.decorations;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scrollIntoView(target) {</span><span class="s3">\n        </span><span class="s1">if (target.isSnapshot) {</span><span class="s3">\n            </span><span class="s1">let ref = this.view.viewState.lineBlockAt(target.range.head);</span><span class="s3">\n            </span><span class="s1">this.view.scrollDOM.scrollTop = ref.top - target.yMargin;</span><span class="s3">\n            </span><span class="s1">this.view.scrollDOM.scrollLeft = target.xMargin;</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let handler of this.view.state.facet(scrollHandler)) {</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">if (handler(this.view, target.range, target))</span><span class="s3">\n                    </span><span class="s1">return true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">catch (e) {</span><span class="s3">\n                </span><span class="s1">logException(this.view.state, e, </span><span class="s3">\&quot;</span><span class="s1">scroll handler</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let { range } = target;</span><span class="s3">\n        </span><span class="s1">let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head &gt; range.anchor ? -1 : 1), other;</span><span class="s3">\n        </span><span class="s1">if (!rect)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">if (!range.empty &amp;&amp; (other = this.coordsAt(range.anchor, range.anchor &gt; range.head ? -1 : 1)))</span><span class="s3">\n            </span><span class="s1">rect = { left: Math.min(rect.left, other.left), top: Math.min(rect.top, other.top),</span><span class="s3">\n                </span><span class="s1">right: Math.max(rect.right, other.right), bottom: Math.max(rect.bottom, other.bottom) };</span><span class="s3">\n        </span><span class="s1">let margins = getScrollMargins(this.view);</span><span class="s3">\n        </span><span class="s1">let targetRect = {</span><span class="s3">\n            </span><span class="s1">left: rect.left - margins.left, top: rect.top - margins.top,</span><span class="s3">\n            </span><span class="s1">right: rect.right + margins.right, bottom: rect.bottom + margins.bottom</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">let { offsetWidth, offsetHeight } = this.view.scrollDOM;</span><span class="s3">\n        </span><span class="s1">scrollRectIntoView(this.view.scrollDOM, targetRect, range.head &lt; range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function betweenUneditable(pos) {</span><span class="s3">\n    </span><span class="s1">return pos.node.nodeType == 1 &amp;&amp; pos.node.firstChild &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findCompositionNode(view, headPos) {</span><span class="s3">\n    </span><span class="s1">let sel = view.observer.selectionRange;</span><span class="s3">\n    </span><span class="s1">if (!sel.focusNode)</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);</span><span class="s3">\n    </span><span class="s1">let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);</span><span class="s3">\n    </span><span class="s1">let textNode = textBefore || textAfter;</span><span class="s3">\n    </span><span class="s1">if (textAfter &amp;&amp; textBefore &amp;&amp; textAfter.node != textBefore.node) {</span><span class="s3">\n        </span><span class="s1">let descAfter = ContentView.get(textAfter.node);</span><span class="s3">\n        </span><span class="s1">if (!descAfter || descAfter instanceof TextView &amp;&amp; descAfter.text != textAfter.node.nodeValue) {</span><span class="s3">\n            </span><span class="s1">textNode = textAfter;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (view.docView.lastCompositionAfterCursor) {</span><span class="s3">\n            </span><span class="s1">let descBefore = ContentView.get(textBefore.node);</span><span class="s3">\n            </span><span class="s1">if (!(!descBefore || descBefore instanceof TextView &amp;&amp; descBefore.text != textBefore.node.nodeValue))</span><span class="s3">\n                </span><span class="s1">textNode = textAfter;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">view.docView.lastCompositionAfterCursor = textNode != textBefore;</span><span class="s3">\n    </span><span class="s1">if (!textNode)</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">let from = headPos - textNode.offset;</span><span class="s3">\n    </span><span class="s1">return { from, to: from + textNode.node.nodeValue.length, node: textNode.node };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findCompositionRange(view, changes, headPos) {</span><span class="s3">\n    </span><span class="s1">let found = findCompositionNode(view, headPos);</span><span class="s3">\n    </span><span class="s1">if (!found)</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">let { node: textNode, from, to } = found, text = textNode.nodeValue;</span><span class="s3">\n    </span><span class="s1">// Don't try to preserve multi-line compositions</span><span class="s3">\n    </span><span class="s1">if (/[</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">r]/.test(text))</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">if (view.state.doc.sliceString(found.from, found.to) != text)</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">let inv = changes.invertedDesc;</span><span class="s3">\n    </span><span class="s1">let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);</span><span class="s3">\n    </span><span class="s1">let marks = [];</span><span class="s3">\n    </span><span class="s1">for (let parent = textNode.parentNode;; parent = parent.parentNode) {</span><span class="s3">\n        </span><span class="s1">let parentView = ContentView.get(parent);</span><span class="s3">\n        </span><span class="s1">if (parentView instanceof MarkView)</span><span class="s3">\n            </span><span class="s1">marks.push({ node: parent, deco: parentView.mark });</span><span class="s3">\n        </span><span class="s1">else if (parentView instanceof LineView || parent.nodeName == </span><span class="s3">\&quot;</span><span class="s1">DIV</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; parent.parentNode == view.contentDOM)</span><span class="s3">\n            </span><span class="s1">return { range, text: textNode, marks, line: parent };</span><span class="s3">\n        </span><span class="s1">else if (parent != view.contentDOM)</span><span class="s3">\n            </span><span class="s1">marks.push({ node: parent, deco: new MarkDecoration({</span><span class="s3">\n                    </span><span class="s1">inclusive: true,</span><span class="s3">\n                    </span><span class="s1">attributes: getAttrs(parent),</span><span class="s3">\n                    </span><span class="s1">tagName: parent.tagName.toLowerCase()</span><span class="s3">\n                </span><span class="s1">}) });</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function nextToUneditable(node, offset) {</span><span class="s3">\n    </span><span class="s1">if (node.nodeType != 1)</span><span class="s3">\n        </span><span class="s1">return 0;</span><span class="s3">\n    </span><span class="s1">return (offset &amp;&amp; node.childNodes[offset - 1].contentEditable == </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot; </span><span class="s1">? 1 /* NextTo.Before */ : 0) |</span><span class="s3">\n        </span><span class="s1">(offset &lt; node.childNodes.length &amp;&amp; node.childNodes[offset].contentEditable == </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot; </span><span class="s1">? 2 /* NextTo.After */ : 0);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">let DecorationComparator$1 = class DecorationComparator {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.changes = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">compareRange(from, to) { addRange(from, to, this.changes); }</span><span class="s3">\n    </span><span class="s1">comparePoint(from, to) { addRange(from, to, this.changes); }</span><span class="s3">\n    </span><span class="s1">boundChange(pos) { addRange(pos, pos, this.changes); }</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function findChangedDeco(a, b, diff) {</span><span class="s3">\n    </span><span class="s1">let comp = new DecorationComparator$1;</span><span class="s3">\n    </span><span class="s1">RangeSet.compare(a, b, diff, comp);</span><span class="s3">\n    </span><span class="s1">return comp.changes;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function inUneditable(node, inside) {</span><span class="s3">\n    </span><span class="s1">for (let cur = node; cur &amp;&amp; cur != inside; cur = cur.assignedSlot || cur.parentNode) {</span><span class="s3">\n        </span><span class="s1">if (cur.nodeType == 1 &amp;&amp; cur.contentEditable == 'false') {</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function touchesComposition(changes, composition) {</span><span class="s3">\n    </span><span class="s1">let touched = false;</span><span class="s3">\n    </span><span class="s1">if (composition)</span><span class="s3">\n        </span><span class="s1">changes.iterChangedRanges((from, to) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (from &lt; composition.to &amp;&amp; to &gt; composition.from)</span><span class="s3">\n                </span><span class="s1">touched = true;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return touched;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function groupAt(state, pos, bias = 1) {</span><span class="s3">\n    </span><span class="s1">let categorize = state.charCategorizer(pos);</span><span class="s3">\n    </span><span class="s1">let line = state.doc.lineAt(pos), linePos = pos - line.from;</span><span class="s3">\n    </span><span class="s1">if (line.length == 0)</span><span class="s3">\n        </span><span class="s1">return EditorSelection.cursor(pos);</span><span class="s3">\n    </span><span class="s1">if (linePos == 0)</span><span class="s3">\n        </span><span class="s1">bias = 1;</span><span class="s3">\n    </span><span class="s1">else if (linePos == line.length)</span><span class="s3">\n        </span><span class="s1">bias = -1;</span><span class="s3">\n    </span><span class="s1">let from = linePos, to = linePos;</span><span class="s3">\n    </span><span class="s1">if (bias &lt; 0)</span><span class="s3">\n        </span><span class="s1">from = findClusterBreak(line.text, linePos, false);</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">to = findClusterBreak(line.text, linePos);</span><span class="s3">\n    </span><span class="s1">let cat = categorize(line.text.slice(from, to));</span><span class="s3">\n    </span><span class="s1">while (from &gt; 0) {</span><span class="s3">\n        </span><span class="s1">let prev = findClusterBreak(line.text, from, false);</span><span class="s3">\n        </span><span class="s1">if (categorize(line.text.slice(prev, from)) != cat)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">from = prev;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">while (to &lt; line.length) {</span><span class="s3">\n        </span><span class="s1">let next = findClusterBreak(line.text, to);</span><span class="s3">\n        </span><span class="s1">if (categorize(line.text.slice(to, next)) != cat)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">to = next;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return EditorSelection.range(from + line.from, to + line.from);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Search the DOM for the {node, offset} position closest to the given</span><span class="s3">\n</span><span class="s1">// coordinates. Very inefficient and crude, but can usually be avoided</span><span class="s3">\n</span><span class="s1">// by calling caret(Position|Range)FromPoint instead.</span><span class="s3">\n</span><span class="s1">function getdx(x, rect) {</span><span class="s3">\n    </span><span class="s1">return rect.left &gt; x ? rect.left - x : Math.max(0, x - rect.right);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getdy(y, rect) {</span><span class="s3">\n    </span><span class="s1">return rect.top &gt; y ? rect.top - y : Math.max(0, y - rect.bottom);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function yOverlap(a, b) {</span><span class="s3">\n    </span><span class="s1">return a.top &lt; b.bottom - 1 &amp;&amp; a.bottom &gt; b.top + 1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function upTop(rect, top) {</span><span class="s3">\n    </span><span class="s1">return top &lt; rect.top ? { top, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function upBot(rect, bottom) {</span><span class="s3">\n    </span><span class="s1">return bottom &gt; rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function domPosAtCoords(parent, x, y) {</span><span class="s3">\n    </span><span class="s1">let closest, closestRect, closestX, closestY, closestOverlap = false;</span><span class="s3">\n    </span><span class="s1">let above, below, aboveRect, belowRect;</span><span class="s3">\n    </span><span class="s1">for (let child = parent.firstChild; child; child = child.nextSibling) {</span><span class="s3">\n        </span><span class="s1">let rects = clientRectsFor(child);</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; rects.length; i++) {</span><span class="s3">\n            </span><span class="s1">let rect = rects[i];</span><span class="s3">\n            </span><span class="s1">if (closestRect &amp;&amp; yOverlap(closestRect, rect))</span><span class="s3">\n                </span><span class="s1">rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);</span><span class="s3">\n            </span><span class="s1">let dx = getdx(x, rect), dy = getdy(y, rect);</span><span class="s3">\n            </span><span class="s1">if (dx == 0 &amp;&amp; dy == 0)</span><span class="s3">\n                </span><span class="s1">return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);</span><span class="s3">\n            </span><span class="s1">if (!closest || closestY &gt; dy || closestY == dy &amp;&amp; closestX &gt; dx) {</span><span class="s3">\n                </span><span class="s1">closest = child;</span><span class="s3">\n                </span><span class="s1">closestRect = rect;</span><span class="s3">\n                </span><span class="s1">closestX = dx;</span><span class="s3">\n                </span><span class="s1">closestY = dy;</span><span class="s3">\n                </span><span class="s1">let side = dy ? (y &lt; rect.top ? -1 : 1) : dx ? (x &lt; rect.left ? -1 : 1) : 0;</span><span class="s3">\n                </span><span class="s1">closestOverlap = !side || (side &gt; 0 ? i &lt; rects.length - 1 : i &gt; 0);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (dx == 0) {</span><span class="s3">\n                </span><span class="s1">if (y &gt; rect.bottom &amp;&amp; (!aboveRect || aboveRect.bottom &lt; rect.bottom)) {</span><span class="s3">\n                    </span><span class="s1">above = child;</span><span class="s3">\n                    </span><span class="s1">aboveRect = rect;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (y &lt; rect.top &amp;&amp; (!belowRect || belowRect.top &gt; rect.top)) {</span><span class="s3">\n                    </span><span class="s1">below = child;</span><span class="s3">\n                    </span><span class="s1">belowRect = rect;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (aboveRect &amp;&amp; yOverlap(aboveRect, rect)) {</span><span class="s3">\n                </span><span class="s1">aboveRect = upBot(aboveRect, rect.bottom);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (belowRect &amp;&amp; yOverlap(belowRect, rect)) {</span><span class="s3">\n                </span><span class="s1">belowRect = upTop(belowRect, rect.top);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (aboveRect &amp;&amp; aboveRect.bottom &gt;= y) {</span><span class="s3">\n        </span><span class="s1">closest = above;</span><span class="s3">\n        </span><span class="s1">closestRect = aboveRect;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (belowRect &amp;&amp; belowRect.top &lt;= y) {</span><span class="s3">\n        </span><span class="s1">closest = below;</span><span class="s3">\n        </span><span class="s1">closestRect = belowRect;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!closest)</span><span class="s3">\n        </span><span class="s1">return { node: parent, offset: 0 };</span><span class="s3">\n    </span><span class="s1">let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));</span><span class="s3">\n    </span><span class="s1">if (closest.nodeType == 3)</span><span class="s3">\n        </span><span class="s1">return domPosInText(closest, clipX, y);</span><span class="s3">\n    </span><span class="s1">if (closestOverlap &amp;&amp; closest.contentEditable != </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return domPosAtCoords(closest, clipX, y);</span><span class="s3">\n    </span><span class="s1">let offset = Array.prototype.indexOf.call(parent.childNodes, closest) +</span><span class="s3">\n        </span><span class="s1">(x &gt;= (closestRect.left + closestRect.right) / 2 ? 1 : 0);</span><span class="s3">\n    </span><span class="s1">return { node: parent, offset };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function domPosInText(node, x, y) {</span><span class="s3">\n    </span><span class="s1">let len = node.nodeValue.length;</span><span class="s3">\n    </span><span class="s1">let closestOffset = -1, closestDY = 1e9, generalSide = 0;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; len; i++) {</span><span class="s3">\n        </span><span class="s1">let rects = textRange(node, i, i + 1).getClientRects();</span><span class="s3">\n        </span><span class="s1">for (let j = 0; j &lt; rects.length; j++) {</span><span class="s3">\n            </span><span class="s1">let rect = rects[j];</span><span class="s3">\n            </span><span class="s1">if (rect.top == rect.bottom)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">if (!generalSide)</span><span class="s3">\n                </span><span class="s1">generalSide = x - rect.left;</span><span class="s3">\n            </span><span class="s1">let dy = (rect.top &gt; y ? rect.top - y : y - rect.bottom) - 1;</span><span class="s3">\n            </span><span class="s1">if (rect.left - 1 &lt;= x &amp;&amp; rect.right + 1 &gt;= x &amp;&amp; dy &lt; closestDY) {</span><span class="s3">\n                </span><span class="s1">let right = x &gt;= (rect.left + rect.right) / 2, after = right;</span><span class="s3">\n                </span><span class="s1">if (browser.chrome || browser.gecko) {</span><span class="s3">\n                    </span><span class="s1">// Check for RTL on browsers that support getting client</span><span class="s3">\n                    </span><span class="s1">// rects for empty ranges.</span><span class="s3">\n                    </span><span class="s1">let rectBefore = textRange(node, i).getBoundingClientRect();</span><span class="s3">\n                    </span><span class="s1">if (rectBefore.left == rect.right)</span><span class="s3">\n                        </span><span class="s1">after = !right;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (dy &lt;= 0)</span><span class="s3">\n                    </span><span class="s1">return { node, offset: i + (after ? 1 : 0) };</span><span class="s3">\n                </span><span class="s1">closestOffset = i + (after ? 1 : 0);</span><span class="s3">\n                </span><span class="s1">closestDY = dy;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return { node, offset: closestOffset &gt; -1 ? closestOffset : generalSide &gt; 0 ? node.nodeValue.length : 0 };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function posAtCoords(view, coords, precise, bias = -1) {</span><span class="s3">\n    </span><span class="s1">var _a, _b;</span><span class="s3">\n    </span><span class="s1">let content = view.contentDOM.getBoundingClientRect(), docTop = content.top + view.viewState.paddingTop;</span><span class="s3">\n    </span><span class="s1">let block, { docHeight } = view.viewState;</span><span class="s3">\n    </span><span class="s1">let { x, y } = coords, yOffset = y - docTop;</span><span class="s3">\n    </span><span class="s1">if (yOffset &lt; 0)</span><span class="s3">\n        </span><span class="s1">return 0;</span><span class="s3">\n    </span><span class="s1">if (yOffset &gt; docHeight)</span><span class="s3">\n        </span><span class="s1">return view.state.doc.length;</span><span class="s3">\n    </span><span class="s1">// Scan for a text block near the queried y position</span><span class="s3">\n    </span><span class="s1">for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false;;) {</span><span class="s3">\n        </span><span class="s1">block = view.elementAtHeight(yOffset);</span><span class="s3">\n        </span><span class="s1">if (block.type == BlockType.Text)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">// Move the y position out of this block</span><span class="s3">\n            </span><span class="s1">yOffset = bias &gt; 0 ? block.bottom + halfLine : block.top - halfLine;</span><span class="s3">\n            </span><span class="s1">if (yOffset &gt;= 0 &amp;&amp; yOffset &lt;= docHeight)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">// If the document consists entirely of replaced widgets, we</span><span class="s3">\n            </span><span class="s1">// won't find a text block, so return 0</span><span class="s3">\n            </span><span class="s1">if (bounced)</span><span class="s3">\n                </span><span class="s1">return precise ? null : 0;</span><span class="s3">\n            </span><span class="s1">bounced = true;</span><span class="s3">\n            </span><span class="s1">bias = -bias;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">y = docTop + yOffset;</span><span class="s3">\n    </span><span class="s1">let lineStart = block.from;</span><span class="s3">\n    </span><span class="s1">// If this is outside of the rendered viewport, we can't determine a position</span><span class="s3">\n    </span><span class="s1">if (lineStart &lt; view.viewport.from)</span><span class="s3">\n        </span><span class="s1">return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);</span><span class="s3">\n    </span><span class="s1">if (lineStart &gt; view.viewport.to)</span><span class="s3">\n        </span><span class="s1">return view.viewport.to == view.state.doc.length ? view.state.doc.length :</span><span class="s3">\n            </span><span class="s1">precise ? null : posAtCoordsImprecise(view, content, block, x, y);</span><span class="s3">\n    </span><span class="s1">// Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not</span><span class="s3">\n    </span><span class="s1">let doc = view.dom.ownerDocument;</span><span class="s3">\n    </span><span class="s1">let root = view.root.elementFromPoint ? view.root : doc;</span><span class="s3">\n    </span><span class="s1">let element = root.elementFromPoint(x, y);</span><span class="s3">\n    </span><span class="s1">if (element &amp;&amp; !view.contentDOM.contains(element))</span><span class="s3">\n        </span><span class="s1">element = null;</span><span class="s3">\n    </span><span class="s1">// If the element is unexpected, clip x at the sides of the content area and try again</span><span class="s3">\n    </span><span class="s1">if (!element) {</span><span class="s3">\n        </span><span class="s1">x = Math.max(content.left + 1, Math.min(content.right - 1, x));</span><span class="s3">\n        </span><span class="s1">element = root.elementFromPoint(x, y);</span><span class="s3">\n        </span><span class="s1">if (element &amp;&amp; !view.contentDOM.contains(element))</span><span class="s3">\n            </span><span class="s1">element = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// There's visible editor content under the point, so we can try</span><span class="s3">\n    </span><span class="s1">// using caret(Position|Range)FromPoint as a shortcut</span><span class="s3">\n    </span><span class="s1">let node, offset = -1;</span><span class="s3">\n    </span><span class="s1">if (element &amp;&amp; ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {</span><span class="s3">\n        </span><span class="s1">if (doc.caretPositionFromPoint) {</span><span class="s3">\n            </span><span class="s1">let pos = doc.caretPositionFromPoint(x, y);</span><span class="s3">\n            </span><span class="s1">if (pos)</span><span class="s3">\n                </span><span class="s1">({ offsetNode: node, offset } = pos);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (doc.caretRangeFromPoint) {</span><span class="s3">\n            </span><span class="s1">let range = doc.caretRangeFromPoint(x, y);</span><span class="s3">\n            </span><span class="s1">if (range) {</span><span class="s3">\n                </span><span class="s1">({ startContainer: node, startOffset: offset } = range);</span><span class="s3">\n                </span><span class="s1">if (!view.contentDOM.contains(node) ||</span><span class="s3">\n                    </span><span class="s1">browser.safari &amp;&amp; isSuspiciousSafariCaretResult(node, offset, x) ||</span><span class="s3">\n                    </span><span class="s1">browser.chrome &amp;&amp; isSuspiciousChromeCaretResult(node, offset, x))</span><span class="s3">\n                    </span><span class="s1">node = undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Chrome will return offsets into &lt;input&gt; elements without child</span><span class="s3">\n        </span><span class="s1">// nodes, which will lead to a null deref below, so clip the</span><span class="s3">\n        </span><span class="s1">// offset to the node size.</span><span class="s3">\n        </span><span class="s1">if (node)</span><span class="s3">\n            </span><span class="s1">offset = Math.min(maxOffset(node), offset);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// No luck, do our own (potentially expensive) search</span><span class="s3">\n    </span><span class="s1">if (!node || !view.docView.dom.contains(node)) {</span><span class="s3">\n        </span><span class="s1">let line = LineView.find(view.docView, lineStart);</span><span class="s3">\n        </span><span class="s1">if (!line)</span><span class="s3">\n            </span><span class="s1">return yOffset &gt; block.top + block.height / 2 ? block.to : block.from;</span><span class="s3">\n        </span><span class="s1">({ node, offset } = domPosAtCoords(line.dom, x, y));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let nearest = view.docView.nearest(node);</span><span class="s3">\n    </span><span class="s1">if (!nearest)</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">if (nearest.isWidget &amp;&amp; ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {</span><span class="s3">\n        </span><span class="s1">let rect = nearest.dom.getBoundingClientRect();</span><span class="s3">\n        </span><span class="s1">return coords.y &lt; rect.top || coords.y &lt;= rect.bottom &amp;&amp; coords.x &lt;= (rect.left + rect.right) / 2</span><span class="s3">\n            </span><span class="s1">? nearest.posAtStart : nearest.posAtEnd;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function posAtCoordsImprecise(view, contentRect, block, x, y) {</span><span class="s3">\n    </span><span class="s1">let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);</span><span class="s3">\n    </span><span class="s1">if (view.lineWrapping &amp;&amp; block.height &gt; view.defaultLineHeight * 1.5) {</span><span class="s3">\n        </span><span class="s1">let textHeight = view.viewState.heightOracle.textHeight;</span><span class="s3">\n        </span><span class="s1">let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);</span><span class="s3">\n        </span><span class="s1">into += line * view.viewState.heightOracle.lineLength;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let content = view.state.sliceDoc(block.from, block.to);</span><span class="s3">\n    </span><span class="s1">return block.from + findColumn(content, into, view.state.tabSize);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// In case of a high line height, Safari's caretRangeFromPoint treats</span><span class="s3">\n</span><span class="s1">// the space between lines as belonging to the last character of the</span><span class="s3">\n</span><span class="s1">// line before. This is used to detect such a result so that it can be</span><span class="s3">\n</span><span class="s1">// ignored (issue #401).</span><span class="s3">\n</span><span class="s1">function isSuspiciousSafariCaretResult(node, offset, x) {</span><span class="s3">\n    </span><span class="s1">let len;</span><span class="s3">\n    </span><span class="s1">if (node.nodeType != 3 || offset != (len = node.nodeValue.length))</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">for (let next = node.nextSibling; next; next = next.nextSibling)</span><span class="s3">\n        </span><span class="s1">if (next.nodeType != 1 || next.nodeName != </span><span class="s3">\&quot;</span><span class="s1">BR</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">return textRange(node, len - 1, len).getBoundingClientRect().left &gt; x;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Chrome will move positions between lines to the start of the next line</span><span class="s3">\n</span><span class="s1">function isSuspiciousChromeCaretResult(node, offset, x) {</span><span class="s3">\n    </span><span class="s1">if (offset != 0)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">for (let cur = node;;) {</span><span class="s3">\n        </span><span class="s1">let parent = cur.parentNode;</span><span class="s3">\n        </span><span class="s1">if (!parent || parent.nodeType != 1 || parent.firstChild != cur)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">if (parent.classList.contains(</span><span class="s3">\&quot;</span><span class="s1">cm-line</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">cur = parent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let rect = node.nodeType == 1 ? node.getBoundingClientRect()</span><span class="s3">\n        </span><span class="s1">: textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();</span><span class="s3">\n    </span><span class="s1">return x - rect.left &gt; 5;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function blockAt(view, pos) {</span><span class="s3">\n    </span><span class="s1">let line = view.lineBlockAt(pos);</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(line.type))</span><span class="s3">\n        </span><span class="s1">for (let l of line.type) {</span><span class="s3">\n            </span><span class="s1">if (l.to &gt; pos || l.to == pos &amp;&amp; (l.to == line.to || l.type == BlockType.Text))</span><span class="s3">\n                </span><span class="s1">return l;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return line;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function moveToLineBoundary(view, start, forward, includeWrap) {</span><span class="s3">\n    </span><span class="s1">let line = blockAt(view, start.head);</span><span class="s3">\n    </span><span class="s1">let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null</span><span class="s3">\n        </span><span class="s1">: view.coordsAtPos(start.assoc &lt; 0 &amp;&amp; start.head &gt; line.from ? start.head - 1 : start.head);</span><span class="s3">\n    </span><span class="s1">if (coords) {</span><span class="s3">\n        </span><span class="s1">let editorRect = view.dom.getBoundingClientRect();</span><span class="s3">\n        </span><span class="s1">let direction = view.textDirectionAt(line.from);</span><span class="s3">\n        </span><span class="s1">let pos = view.posAtCoords({ x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,</span><span class="s3">\n            </span><span class="s1">y: (coords.top + coords.bottom) / 2 });</span><span class="s3">\n        </span><span class="s1">if (pos != null)</span><span class="s3">\n            </span><span class="s1">return EditorSelection.cursor(pos, forward ? -1 : 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function moveByChar(view, start, forward, by) {</span><span class="s3">\n    </span><span class="s1">let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);</span><span class="s3">\n    </span><span class="s1">let direction = view.textDirectionAt(line.from);</span><span class="s3">\n    </span><span class="s1">for (let cur = start, check = null;;) {</span><span class="s3">\n        </span><span class="s1">let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;</span><span class="s3">\n        </span><span class="s1">if (!next) {</span><span class="s3">\n            </span><span class="s1">if (line.number == (forward ? view.state.doc.lines : 1))</span><span class="s3">\n                </span><span class="s1">return cur;</span><span class="s3">\n            </span><span class="s1">char = </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">line = view.state.doc.line(line.number + (forward ? 1 : -1));</span><span class="s3">\n            </span><span class="s1">spans = view.bidiSpans(line);</span><span class="s3">\n            </span><span class="s1">next = view.visualLineSide(line, !forward);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!check) {</span><span class="s3">\n            </span><span class="s1">if (!by)</span><span class="s3">\n                </span><span class="s1">return next;</span><span class="s3">\n            </span><span class="s1">check = by(char);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (!check(char)) {</span><span class="s3">\n            </span><span class="s1">return cur;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">cur = next;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function byGroup(view, pos, start) {</span><span class="s3">\n    </span><span class="s1">let categorize = view.state.charCategorizer(pos);</span><span class="s3">\n    </span><span class="s1">let cat = categorize(start);</span><span class="s3">\n    </span><span class="s1">return (next) =&gt; {</span><span class="s3">\n        </span><span class="s1">let nextCat = categorize(next);</span><span class="s3">\n        </span><span class="s1">if (cat == CharCategory.Space)</span><span class="s3">\n            </span><span class="s1">cat = nextCat;</span><span class="s3">\n        </span><span class="s1">return cat == nextCat;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function moveVertically(view, start, forward, distance) {</span><span class="s3">\n    </span><span class="s1">let startPos = start.head, dir = forward ? 1 : -1;</span><span class="s3">\n    </span><span class="s1">if (startPos == (forward ? view.state.doc.length : 0))</span><span class="s3">\n        </span><span class="s1">return EditorSelection.cursor(startPos, start.assoc);</span><span class="s3">\n    </span><span class="s1">let goal = start.goalColumn, startY;</span><span class="s3">\n    </span><span class="s1">let rect = view.contentDOM.getBoundingClientRect();</span><span class="s3">\n    </span><span class="s1">let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;</span><span class="s3">\n    </span><span class="s1">if (startCoords) {</span><span class="s3">\n        </span><span class="s1">if (goal == null)</span><span class="s3">\n            </span><span class="s1">goal = startCoords.left - rect.left;</span><span class="s3">\n        </span><span class="s1">startY = dir &lt; 0 ? startCoords.top : startCoords.bottom;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">let line = view.viewState.lineBlockAt(startPos);</span><span class="s3">\n        </span><span class="s1">if (goal == null)</span><span class="s3">\n            </span><span class="s1">goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));</span><span class="s3">\n        </span><span class="s1">startY = (dir &lt; 0 ? line.top : line.bottom) + docTop;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let resolvedGoal = rect.left + goal;</span><span class="s3">\n    </span><span class="s1">let dist = distance !== null &amp;&amp; distance !== void 0 ? distance : (view.viewState.heightOracle.textHeight &gt;&gt; 1);</span><span class="s3">\n    </span><span class="s1">for (let extra = 0;; extra += 10) {</span><span class="s3">\n        </span><span class="s1">let curY = startY + (dist + extra) * dir;</span><span class="s3">\n        </span><span class="s1">let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);</span><span class="s3">\n        </span><span class="s1">if (curY &lt; rect.top || curY &gt; rect.bottom || (dir &lt; 0 ? pos &lt; startPos : pos &gt; startPos)) {</span><span class="s3">\n            </span><span class="s1">let charRect = view.docView.coordsForChar(pos);</span><span class="s3">\n            </span><span class="s1">let assoc = !charRect || curY &lt; charRect.top ? -1 : 1;</span><span class="s3">\n            </span><span class="s1">return EditorSelection.cursor(pos, assoc, undefined, goal);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function skipAtomicRanges(atoms, pos, bias) {</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">let moved = 0;</span><span class="s3">\n        </span><span class="s1">for (let set of atoms) {</span><span class="s3">\n            </span><span class="s1">set.between(pos - 1, pos + 1, (from, to, value) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (pos &gt; from &amp;&amp; pos &lt; to) {</span><span class="s3">\n                    </span><span class="s1">let side = moved || bias || (pos - from &lt; to - pos ? -1 : 1);</span><span class="s3">\n                    </span><span class="s1">pos = side &lt; 0 ? from : to;</span><span class="s3">\n                    </span><span class="s1">moved = side;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!moved)</span><span class="s3">\n            </span><span class="s1">return pos;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function skipAtoms(view, oldPos, pos) {</span><span class="s3">\n    </span><span class="s1">let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map(f =&gt; f(view)), pos.from, oldPos.head &gt; pos.from ? -1 : 1);</span><span class="s3">\n    </span><span class="s1">return newPos == pos.from ? pos : EditorSelection.cursor(newPos, newPos &lt; pos.from ? 1 : -1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const LineBreakPlaceholder = </span><span class="s3">\&quot;\\</span><span class="s1">uffff</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">class DOMReader {</span><span class="s3">\n    </span><span class="s1">constructor(points, state) {</span><span class="s3">\n        </span><span class="s1">this.points = points;</span><span class="s3">\n        </span><span class="s1">this.text = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.lineSeparator = state.facet(EditorState.lineSeparator);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">append(text) {</span><span class="s3">\n        </span><span class="s1">this.text += text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">lineBreak() {</span><span class="s3">\n        </span><span class="s1">this.text += LineBreakPlaceholder;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">readRange(start, end) {</span><span class="s3">\n        </span><span class="s1">if (!start)</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">let parent = start.parentNode;</span><span class="s3">\n        </span><span class="s1">for (let cur = start;;) {</span><span class="s3">\n            </span><span class="s1">this.findPointBefore(parent, cur);</span><span class="s3">\n            </span><span class="s1">let oldLen = this.text.length;</span><span class="s3">\n            </span><span class="s1">this.readNode(cur);</span><span class="s3">\n            </span><span class="s1">let next = cur.nextSibling;</span><span class="s3">\n            </span><span class="s1">if (next == end)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">let view = ContentView.get(cur), nextView = ContentView.get(next);</span><span class="s3">\n            </span><span class="s1">if (view &amp;&amp; nextView ? view.breakAfter :</span><span class="s3">\n                </span><span class="s1">(view ? view.breakAfter : isBlockElement(cur)) ||</span><span class="s3">\n                    </span><span class="s1">(isBlockElement(next) &amp;&amp; (cur.nodeName != </span><span class="s3">\&quot;</span><span class="s1">BR</span><span class="s3">\&quot; </span><span class="s1">|| cur.cmIgnore) &amp;&amp; this.text.length &gt; oldLen))</span><span class="s3">\n                </span><span class="s1">this.lineBreak();</span><span class="s3">\n            </span><span class="s1">cur = next;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.findPointBefore(parent, end);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">readTextNode(node) {</span><span class="s3">\n        </span><span class="s1">let text = node.nodeValue;</span><span class="s3">\n        </span><span class="s1">for (let point of this.points)</span><span class="s3">\n            </span><span class="s1">if (point.node == node)</span><span class="s3">\n                </span><span class="s1">point.pos = this.text.length + Math.min(point.offset, text.length);</span><span class="s3">\n        </span><span class="s1">for (let off = 0, re = this.lineSeparator ? null : /</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n?|</span><span class="s3">\\</span><span class="s1">n/g;;) {</span><span class="s3">\n            </span><span class="s1">let nextBreak = -1, breakSize = 1, m;</span><span class="s3">\n            </span><span class="s1">if (this.lineSeparator) {</span><span class="s3">\n                </span><span class="s1">nextBreak = text.indexOf(this.lineSeparator, off);</span><span class="s3">\n                </span><span class="s1">breakSize = this.lineSeparator.length;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (m = re.exec(text)) {</span><span class="s3">\n                </span><span class="s1">nextBreak = m.index;</span><span class="s3">\n                </span><span class="s1">breakSize = m[0].length;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.append(text.slice(off, nextBreak &lt; 0 ? text.length : nextBreak));</span><span class="s3">\n            </span><span class="s1">if (nextBreak &lt; 0)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">this.lineBreak();</span><span class="s3">\n            </span><span class="s1">if (breakSize &gt; 1)</span><span class="s3">\n                </span><span class="s1">for (let point of this.points)</span><span class="s3">\n                    </span><span class="s1">if (point.node == node &amp;&amp; point.pos &gt; this.text.length)</span><span class="s3">\n                        </span><span class="s1">point.pos -= breakSize - 1;</span><span class="s3">\n            </span><span class="s1">off = nextBreak + breakSize;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">readNode(node) {</span><span class="s3">\n        </span><span class="s1">if (node.cmIgnore)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">let view = ContentView.get(node);</span><span class="s3">\n        </span><span class="s1">let fromView = view &amp;&amp; view.overrideDOMText;</span><span class="s3">\n        </span><span class="s1">if (fromView != null) {</span><span class="s3">\n            </span><span class="s1">this.findPointInside(node, fromView.length);</span><span class="s3">\n            </span><span class="s1">for (let i = fromView.iter(); !i.next().done;) {</span><span class="s3">\n                </span><span class="s1">if (i.lineBreak)</span><span class="s3">\n                    </span><span class="s1">this.lineBreak();</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">this.append(i.value);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (node.nodeType == 3) {</span><span class="s3">\n            </span><span class="s1">this.readTextNode(node);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (node.nodeName == </span><span class="s3">\&quot;</span><span class="s1">BR</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">if (node.nextSibling)</span><span class="s3">\n                </span><span class="s1">this.lineBreak();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (node.nodeType == 1) {</span><span class="s3">\n            </span><span class="s1">this.readRange(node.firstChild, null);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">findPointBefore(node, next) {</span><span class="s3">\n        </span><span class="s1">for (let point of this.points)</span><span class="s3">\n            </span><span class="s1">if (point.node == node &amp;&amp; node.childNodes[point.offset] == next)</span><span class="s3">\n                </span><span class="s1">point.pos = this.text.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">findPointInside(node, length) {</span><span class="s3">\n        </span><span class="s1">for (let point of this.points)</span><span class="s3">\n            </span><span class="s1">if (node.nodeType == 3 ? point.node == node : node.contains(point.node))</span><span class="s3">\n                </span><span class="s1">point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isAtEnd(parent, node, offset) {</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">if (!node || offset &lt; maxOffset(node))</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">if (node == parent)</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">offset = domIndex(node) + 1;</span><span class="s3">\n        </span><span class="s1">node = node.parentNode;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class DOMPoint {</span><span class="s3">\n    </span><span class="s1">constructor(node, offset) {</span><span class="s3">\n        </span><span class="s1">this.node = node;</span><span class="s3">\n        </span><span class="s1">this.offset = offset;</span><span class="s3">\n        </span><span class="s1">this.pos = -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class DOMChange {</span><span class="s3">\n    </span><span class="s1">constructor(view, start, end, typeOver) {</span><span class="s3">\n        </span><span class="s1">this.typeOver = typeOver;</span><span class="s3">\n        </span><span class="s1">this.bounds = null;</span><span class="s3">\n        </span><span class="s1">this.text = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.domChanged = start &gt; -1;</span><span class="s3">\n        </span><span class="s1">let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;</span><span class="s3">\n        </span><span class="s1">if (view.state.readOnly &amp;&amp; start &gt; -1) {</span><span class="s3">\n            </span><span class="s1">// Ignore changes when the editor is read-only</span><span class="s3">\n            </span><span class="s1">this.newSel = null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (start &gt; -1 &amp;&amp; (this.bounds = view.docView.domBoundsAround(start, end, 0))) {</span><span class="s3">\n            </span><span class="s1">let selPoints = iHead || iAnchor ? [] : selectionPoints(view);</span><span class="s3">\n            </span><span class="s1">let reader = new DOMReader(selPoints, view.state);</span><span class="s3">\n            </span><span class="s1">reader.readRange(this.bounds.startDOM, this.bounds.endDOM);</span><span class="s3">\n            </span><span class="s1">this.text = reader.text;</span><span class="s3">\n            </span><span class="s1">this.newSel = selectionFromPoints(selPoints, this.bounds.from);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let domSel = view.observer.selectionRange;</span><span class="s3">\n            </span><span class="s1">let head = iHead &amp;&amp; iHead.node == domSel.focusNode &amp;&amp; iHead.offset == domSel.focusOffset ||</span><span class="s3">\n                </span><span class="s1">!contains(view.contentDOM, domSel.focusNode)</span><span class="s3">\n                </span><span class="s1">? view.state.selection.main.head</span><span class="s3">\n                </span><span class="s1">: view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);</span><span class="s3">\n            </span><span class="s1">let anchor = iAnchor &amp;&amp; iAnchor.node == domSel.anchorNode &amp;&amp; iAnchor.offset == domSel.anchorOffset ||</span><span class="s3">\n                </span><span class="s1">!contains(view.contentDOM, domSel.anchorNode)</span><span class="s3">\n                </span><span class="s1">? view.state.selection.main.anchor</span><span class="s3">\n                </span><span class="s1">: view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);</span><span class="s3">\n            </span><span class="s1">// iOS will refuse to select the block gaps when doing</span><span class="s3">\n            </span><span class="s1">// select-all.</span><span class="s3">\n            </span><span class="s1">// Chrome will put the selection *inside* them, confusing</span><span class="s3">\n            </span><span class="s1">// posFromDOM</span><span class="s3">\n            </span><span class="s1">let vp = view.viewport;</span><span class="s3">\n            </span><span class="s1">if ((browser.ios || browser.chrome) &amp;&amp; view.state.selection.main.empty &amp;&amp; head != anchor &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(vp.from &gt; 0 || vp.to &lt; view.state.doc.length)) {</span><span class="s3">\n                </span><span class="s1">let from = Math.min(head, anchor), to = Math.max(head, anchor);</span><span class="s3">\n                </span><span class="s1">let offFrom = vp.from - from, offTo = vp.to - to;</span><span class="s3">\n                </span><span class="s1">if ((offFrom == 0 || offFrom == 1 || from == 0) &amp;&amp; (offTo == 0 || offTo == -1 || to == view.state.doc.length)) {</span><span class="s3">\n                    </span><span class="s1">head = 0;</span><span class="s3">\n                    </span><span class="s1">anchor = view.state.doc.length;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.newSel = EditorSelection.single(anchor, head);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function applyDOMChange(view, domChange) {</span><span class="s3">\n    </span><span class="s1">let change;</span><span class="s3">\n    </span><span class="s1">let { newSel } = domChange, sel = view.state.selection.main;</span><span class="s3">\n    </span><span class="s1">let lastKey = view.inputState.lastKeyTime &gt; Date.now() - 100 ? view.inputState.lastKeyCode : -1;</span><span class="s3">\n    </span><span class="s1">if (domChange.bounds) {</span><span class="s3">\n        </span><span class="s1">let { from, to } = domChange.bounds;</span><span class="s3">\n        </span><span class="s1">let preferredPos = sel.from, preferredSide = null;</span><span class="s3">\n        </span><span class="s1">// Prefer anchoring to end when Backspace is pressed (or, on</span><span class="s3">\n        </span><span class="s1">// Android, when something was deleted)</span><span class="s3">\n        </span><span class="s1">if (lastKey === 8 || browser.android &amp;&amp; domChange.text.length &lt; to - from) {</span><span class="s3">\n            </span><span class="s1">preferredPos = sel.to;</span><span class="s3">\n            </span><span class="s1">preferredSide = </span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);</span><span class="s3">\n        </span><span class="s1">if (diff) {</span><span class="s3">\n            </span><span class="s1">// Chrome inserts two newlines when pressing shift-enter at the</span><span class="s3">\n            </span><span class="s1">// end of a line. DomChange drops one of those.</span><span class="s3">\n            </span><span class="s1">if (browser.chrome &amp;&amp; lastKey == 13 &amp;&amp;</span><span class="s3">\n                </span><span class="s1">diff.toB == diff.from + 2 &amp;&amp; domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)</span><span class="s3">\n                </span><span class="s1">diff.toB--;</span><span class="s3">\n            </span><span class="s1">change = { from: from + diff.from, to: from + diff.toA,</span><span class="s3">\n                </span><span class="s1">insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder)) };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (newSel &amp;&amp; (!view.hasFocus &amp;&amp; view.state.facet(editable) || newSel.main.eq(sel))) {</span><span class="s3">\n        </span><span class="s1">newSel = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!change &amp;&amp; !newSel)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">if (!change &amp;&amp; domChange.typeOver &amp;&amp; !sel.empty &amp;&amp; newSel &amp;&amp; newSel.main.empty) {</span><span class="s3">\n        </span><span class="s1">// Heuristic to notice typing over a selected character</span><span class="s3">\n        </span><span class="s1">change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (change &amp;&amp; change.from &gt;= sel.from &amp;&amp; change.to &lt;= sel.to &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(change.from != sel.from || change.to != sel.to) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(sel.to - sel.from) - (change.to - change.from) &lt;= 4) {</span><span class="s3">\n        </span><span class="s1">// If the change is inside the selection and covers most of it,</span><span class="s3">\n        </span><span class="s1">// assume it is a selection replace (with identical characters at</span><span class="s3">\n        </span><span class="s1">// the start/end not included in the diff)</span><span class="s3">\n        </span><span class="s1">change = {</span><span class="s3">\n            </span><span class="s1">from: sel.from, to: sel.to,</span><span class="s3">\n            </span><span class="s1">insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if ((browser.mac || browser.android) &amp;&amp; change &amp;&amp; change.from == change.to &amp;&amp; change.from == sel.head - 1 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">/^</span><span class="s3">\\</span><span class="s1">. ?$/.test(change.insert.toString()) &amp;&amp; view.contentDOM.getAttribute(</span><span class="s3">\&quot;</span><span class="s1">autocorrect</span><span class="s3">\&quot;</span><span class="s1">) == </span><span class="s3">\&quot;</span><span class="s1">off</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// Detect insert-period-on-double-space Mac and Android behavior,</span><span class="s3">\n        </span><span class="s1">// and transform it into a regular space insert.</span><span class="s3">\n        </span><span class="s1">if (newSel &amp;&amp; change.insert.length == 2)</span><span class="s3">\n            </span><span class="s1">newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);</span><span class="s3">\n        </span><span class="s1">change = { from: sel.from, to: sel.to, insert: Text.of([</span><span class="s3">\&quot; \&quot;</span><span class="s1">]) };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (browser.chrome &amp;&amp; change &amp;&amp; change.from == change.to &amp;&amp; change.from == sel.head &amp;&amp;</span><span class="s3">\n        </span><span class="s1">change.insert.toString() == </span><span class="s3">\&quot;\\</span><span class="s1">n </span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; view.lineWrapping) {</span><span class="s3">\n        </span><span class="s1">// In Chrome, if you insert a space at the start of a wrapped</span><span class="s3">\n        </span><span class="s1">// line, it will actually insert a newline and a space, causing a</span><span class="s3">\n        </span><span class="s1">// bogus new line to be created in CodeMirror (#968)</span><span class="s3">\n        </span><span class="s1">if (newSel)</span><span class="s3">\n            </span><span class="s1">newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);</span><span class="s3">\n        </span><span class="s1">change = { from: sel.from, to: sel.to, insert: Text.of([</span><span class="s3">\&quot; \&quot;</span><span class="s1">]) };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (change) {</span><span class="s3">\n        </span><span class="s1">return applyDOMChangeInner(view, change, newSel, lastKey);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (newSel &amp;&amp; !newSel.main.eq(sel)) {</span><span class="s3">\n        </span><span class="s1">let scrollIntoView = false, userEvent = </span><span class="s3">\&quot;</span><span class="s1">select</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">if (view.inputState.lastSelectionTime &gt; Date.now() - 50) {</span><span class="s3">\n            </span><span class="s1">if (view.inputState.lastSelectionOrigin == </span><span class="s3">\&quot;</span><span class="s1">select</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">scrollIntoView = true;</span><span class="s3">\n            </span><span class="s1">userEvent = view.inputState.lastSelectionOrigin;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">view.dispatch({ selection: newSel, scrollIntoView, userEvent });</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function applyDOMChangeInner(view, change, newSel, lastKey = -1) {</span><span class="s3">\n    </span><span class="s1">if (browser.ios &amp;&amp; view.inputState.flushIOSKey(change))</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">let sel = view.state.selection.main;</span><span class="s3">\n    </span><span class="s1">// Android browsers don't fire reasonable key events for enter,</span><span class="s3">\n    </span><span class="s1">// backspace, or delete. So this detects changes that look like</span><span class="s3">\n    </span><span class="s1">// they're caused by those keys, and reinterprets them as key</span><span class="s3">\n    </span><span class="s1">// events. (Some of these keys are also handled by beforeinput</span><span class="s3">\n    </span><span class="s1">// events and the pendingAndroidKey mechanism, but that's not</span><span class="s3">\n    </span><span class="s1">// reliable in all situations.)</span><span class="s3">\n    </span><span class="s1">if (browser.android &amp;&amp;</span><span class="s3">\n        </span><span class="s1">((change.to == sel.to &amp;&amp;</span><span class="s3">\n            </span><span class="s1">// GBoard will sometimes remove a space it just inserted</span><span class="s3">\n            </span><span class="s1">// after a completion when you press enter</span><span class="s3">\n            </span><span class="s1">(change.from == sel.from || change.from == sel.from - 1 &amp;&amp; view.state.sliceDoc(change.from, sel.from) == </span><span class="s3">\&quot; \&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">change.insert.length == 1 &amp;&amp; change.insert.lines == 2 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">dispatchKey(view.contentDOM, </span><span class="s3">\&quot;</span><span class="s1">Enter</span><span class="s3">\&quot;</span><span class="s1">, 13)) ||</span><span class="s3">\n            </span><span class="s1">((change.from == sel.from - 1 &amp;&amp; change.to == sel.to &amp;&amp; change.insert.length == 0 ||</span><span class="s3">\n                </span><span class="s1">lastKey == 8 &amp;&amp; change.insert.length &lt; change.to - change.from &amp;&amp; change.to &gt; sel.head) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">dispatchKey(view.contentDOM, </span><span class="s3">\&quot;</span><span class="s1">Backspace</span><span class="s3">\&quot;</span><span class="s1">, 8)) ||</span><span class="s3">\n            </span><span class="s1">(change.from == sel.from &amp;&amp; change.to == sel.to + 1 &amp;&amp; change.insert.length == 0 &amp;&amp;</span><span class="s3">\n                </span><span class="s1">dispatchKey(view.contentDOM, </span><span class="s3">\&quot;</span><span class="s1">Delete</span><span class="s3">\&quot;</span><span class="s1">, 46))))</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">let text = change.insert.toString();</span><span class="s3">\n    </span><span class="s1">if (view.inputState.composing &gt;= 0)</span><span class="s3">\n        </span><span class="s1">view.inputState.composing++;</span><span class="s3">\n    </span><span class="s1">let defaultTr;</span><span class="s3">\n    </span><span class="s1">let defaultInsert = () =&gt; defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));</span><span class="s3">\n    </span><span class="s1">if (!view.state.facet(inputHandler).some(h =&gt; h(view, change.from, change.to, text, defaultInsert)))</span><span class="s3">\n        </span><span class="s1">view.dispatch(defaultInsert());</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function applyDefaultInsert(view, change, newSel) {</span><span class="s3">\n    </span><span class="s1">let tr, startState = view.state, sel = startState.selection.main;</span><span class="s3">\n    </span><span class="s1">if (change.from &gt;= sel.from &amp;&amp; change.to &lt;= sel.to &amp;&amp; change.to - change.from &gt;= (sel.to - sel.from) / 3 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(!newSel || newSel.main.empty &amp;&amp; newSel.main.from == change.from + change.insert.length) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">view.inputState.composing &lt; 0) {</span><span class="s3">\n        </span><span class="s1">let before = sel.from &lt; change.from ? startState.sliceDoc(sel.from, change.from) : </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">let after = sel.to &gt; change.to ? startState.sliceDoc(change.to, sel.to) : </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">let changes = startState.changes(change);</span><span class="s3">\n        </span><span class="s1">let mainSel = newSel &amp;&amp; newSel.main.to &lt;= changes.newLength ? newSel.main : undefined;</span><span class="s3">\n        </span><span class="s1">// Try to apply a composition change to all cursors</span><span class="s3">\n        </span><span class="s1">if (startState.selection.ranges.length &gt; 1 &amp;&amp; view.inputState.composing &gt;= 0 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">change.to &lt;= sel.to &amp;&amp; change.to &gt;= sel.to - 10) {</span><span class="s3">\n            </span><span class="s1">let replaced = view.state.sliceDoc(change.from, change.to);</span><span class="s3">\n            </span><span class="s1">let compositionRange, composition = newSel &amp;&amp; findCompositionNode(view, newSel.main.head);</span><span class="s3">\n            </span><span class="s1">if (composition) {</span><span class="s3">\n                </span><span class="s1">let dLen = change.insert.length - (change.to - change.from);</span><span class="s3">\n                </span><span class="s1">compositionRange = { from: composition.from, to: composition.to - dLen };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">compositionRange = view.state.doc.lineAt(sel.head);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let offset = sel.to - change.to, size = sel.to - sel.from;</span><span class="s3">\n            </span><span class="s1">tr = startState.changeByRange(range =&gt; {</span><span class="s3">\n                </span><span class="s1">if (range.from == sel.from &amp;&amp; range.to == sel.to)</span><span class="s3">\n                    </span><span class="s1">return { changes, range: mainSel || range.map(changes) };</span><span class="s3">\n                </span><span class="s1">let to = range.to - offset, from = to - replaced.length;</span><span class="s3">\n                </span><span class="s1">if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced ||</span><span class="s3">\n                    </span><span class="s1">// Unfortunately, there's no way to make multiple</span><span class="s3">\n                    </span><span class="s1">// changes in the same node work without aborting</span><span class="s3">\n                    </span><span class="s1">// composition, so cursors in the composition range are</span><span class="s3">\n                    </span><span class="s1">// ignored.</span><span class="s3">\n                    </span><span class="s1">range.to &gt;= compositionRange.from &amp;&amp; range.from &lt;= compositionRange.to)</span><span class="s3">\n                    </span><span class="s1">return { range };</span><span class="s3">\n                </span><span class="s1">let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range.to - sel.to;</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">changes: rangeChanges,</span><span class="s3">\n                    </span><span class="s1">range: !mainSel ? range.map(rangeChanges) :</span><span class="s3">\n                        </span><span class="s1">EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">tr = {</span><span class="s3">\n                </span><span class="s1">changes,</span><span class="s3">\n                </span><span class="s1">selection: mainSel &amp;&amp; startState.selection.replaceRange(mainSel)</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let userEvent = </span><span class="s3">\&quot;</span><span class="s1">input.type</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">if (view.composing ||</span><span class="s3">\n        </span><span class="s1">view.inputState.compositionPendingChange &amp;&amp; view.inputState.compositionEndedAt &gt; Date.now() - 50) {</span><span class="s3">\n        </span><span class="s1">view.inputState.compositionPendingChange = false;</span><span class="s3">\n        </span><span class="s1">userEvent += </span><span class="s3">\&quot;</span><span class="s1">.compose</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">if (view.inputState.compositionFirstChange) {</span><span class="s3">\n            </span><span class="s1">userEvent += </span><span class="s3">\&quot;</span><span class="s1">.start</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">view.inputState.compositionFirstChange = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return startState.update(tr, { userEvent, scrollIntoView: true });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findDiff(a, b, preferredPos, preferredSide) {</span><span class="s3">\n    </span><span class="s1">let minLen = Math.min(a.length, b.length);</span><span class="s3">\n    </span><span class="s1">let from = 0;</span><span class="s3">\n    </span><span class="s1">while (from &lt; minLen &amp;&amp; a.charCodeAt(from) == b.charCodeAt(from))</span><span class="s3">\n        </span><span class="s1">from++;</span><span class="s3">\n    </span><span class="s1">if (from == minLen &amp;&amp; a.length == b.length)</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">let toA = a.length, toB = b.length;</span><span class="s3">\n    </span><span class="s1">while (toA &gt; 0 &amp;&amp; toB &gt; 0 &amp;&amp; a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {</span><span class="s3">\n        </span><span class="s1">toA--;</span><span class="s3">\n        </span><span class="s1">toB--;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (preferredSide == </span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">let adjust = Math.max(0, from - Math.min(toA, toB));</span><span class="s3">\n        </span><span class="s1">preferredPos -= toA + adjust - from;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (toA &lt; from &amp;&amp; a.length &lt; b.length) {</span><span class="s3">\n        </span><span class="s1">let move = preferredPos &lt;= from &amp;&amp; preferredPos &gt;= toA ? from - preferredPos : 0;</span><span class="s3">\n        </span><span class="s1">from -= move;</span><span class="s3">\n        </span><span class="s1">toB = from + (toB - toA);</span><span class="s3">\n        </span><span class="s1">toA = from;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (toB &lt; from) {</span><span class="s3">\n        </span><span class="s1">let move = preferredPos &lt;= from &amp;&amp; preferredPos &gt;= toB ? from - preferredPos : 0;</span><span class="s3">\n        </span><span class="s1">from -= move;</span><span class="s3">\n        </span><span class="s1">toA = from + (toA - toB);</span><span class="s3">\n        </span><span class="s1">toB = from;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return { from, toA, toB };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function selectionPoints(view) {</span><span class="s3">\n    </span><span class="s1">let result = [];</span><span class="s3">\n    </span><span class="s1">if (view.root.activeElement != view.contentDOM)</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;</span><span class="s3">\n    </span><span class="s1">if (anchorNode) {</span><span class="s3">\n        </span><span class="s1">result.push(new DOMPoint(anchorNode, anchorOffset));</span><span class="s3">\n        </span><span class="s1">if (focusNode != anchorNode || focusOffset != anchorOffset)</span><span class="s3">\n            </span><span class="s1">result.push(new DOMPoint(focusNode, focusOffset));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function selectionFromPoints(points, base) {</span><span class="s3">\n    </span><span class="s1">if (points.length == 0)</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;</span><span class="s3">\n    </span><span class="s1">return anchor &gt; -1 &amp;&amp; head &gt; -1 ? EditorSelection.single(anchor + base, head + base) : null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class InputState {</span><span class="s3">\n    </span><span class="s1">setSelectionOrigin(origin) {</span><span class="s3">\n        </span><span class="s1">this.lastSelectionOrigin = origin;</span><span class="s3">\n        </span><span class="s1">this.lastSelectionTime = Date.now();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">constructor(view) {</span><span class="s3">\n        </span><span class="s1">this.view = view;</span><span class="s3">\n        </span><span class="s1">this.lastKeyCode = 0;</span><span class="s3">\n        </span><span class="s1">this.lastKeyTime = 0;</span><span class="s3">\n        </span><span class="s1">this.lastTouchTime = 0;</span><span class="s3">\n        </span><span class="s1">this.lastFocusTime = 0;</span><span class="s3">\n        </span><span class="s1">this.lastScrollTop = 0;</span><span class="s3">\n        </span><span class="s1">this.lastScrollLeft = 0;</span><span class="s3">\n        </span><span class="s1">// On iOS, some keys need to have their default behavior happen</span><span class="s3">\n        </span><span class="s1">// (after which we retroactively handle them and reset the DOM) to</span><span class="s3">\n        </span><span class="s1">// avoid messing up the virtual keyboard state.</span><span class="s3">\n        </span><span class="s1">this.pendingIOSKey = undefined;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">When enabled (&gt;-1), tab presses are not given to key handlers,</span><span class="s3">\n        </span><span class="s1">leaving the browser's default behavior. If &gt;0, the mode expires</span><span class="s3">\n        </span><span class="s1">at that timestamp, and any other keypress clears it.</span><span class="s3">\n        </span><span class="s1">Esc enables temporary tab focus mode for two seconds when not</span><span class="s3">\n        </span><span class="s1">otherwise handled.</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.tabFocusMode = -1;</span><span class="s3">\n        </span><span class="s1">this.lastSelectionOrigin = null;</span><span class="s3">\n        </span><span class="s1">this.lastSelectionTime = 0;</span><span class="s3">\n        </span><span class="s1">this.lastContextMenu = 0;</span><span class="s3">\n        </span><span class="s1">this.scrollHandlers = [];</span><span class="s3">\n        </span><span class="s1">this.handlers = Object.create(null);</span><span class="s3">\n        </span><span class="s1">// -1 means not in a composition. Otherwise, this counts the number</span><span class="s3">\n        </span><span class="s1">// of changes made during the composition. The count is used to</span><span class="s3">\n        </span><span class="s1">// avoid treating the start state of the composition, before any</span><span class="s3">\n        </span><span class="s1">// changes have been made, as part of the composition.</span><span class="s3">\n        </span><span class="s1">this.composing = -1;</span><span class="s3">\n        </span><span class="s1">// Tracks whether the next change should be marked as starting the</span><span class="s3">\n        </span><span class="s1">// composition (null means no composition, true means next is the</span><span class="s3">\n        </span><span class="s1">// first, false means first has already been marked for this</span><span class="s3">\n        </span><span class="s1">// composition)</span><span class="s3">\n        </span><span class="s1">this.compositionFirstChange = null;</span><span class="s3">\n        </span><span class="s1">// End time of the previous composition</span><span class="s3">\n        </span><span class="s1">this.compositionEndedAt = 0;</span><span class="s3">\n        </span><span class="s1">// Used in a kludge to detect when an Enter keypress should be</span><span class="s3">\n        </span><span class="s1">// considered part of the composition on Safari, which fires events</span><span class="s3">\n        </span><span class="s1">// in the wrong order</span><span class="s3">\n        </span><span class="s1">this.compositionPendingKey = false;</span><span class="s3">\n        </span><span class="s1">// Used to categorize changes as part of a composition, even when</span><span class="s3">\n        </span><span class="s1">// the mutation events fire shortly after the compositionend event</span><span class="s3">\n        </span><span class="s1">this.compositionPendingChange = false;</span><span class="s3">\n        </span><span class="s1">this.mouseSelection = null;</span><span class="s3">\n        </span><span class="s1">// When a drag from the editor is active, this points at the range</span><span class="s3">\n        </span><span class="s1">// being dragged.</span><span class="s3">\n        </span><span class="s1">this.draggedContent = null;</span><span class="s3">\n        </span><span class="s1">this.handleEvent = this.handleEvent.bind(this);</span><span class="s3">\n        </span><span class="s1">this.notifiedFocused = view.hasFocus;</span><span class="s3">\n        </span><span class="s1">// On Safari adding an input event handler somehow prevents an</span><span class="s3">\n        </span><span class="s1">// issue where the composition vanishes when you press enter.</span><span class="s3">\n        </span><span class="s1">if (browser.safari)</span><span class="s3">\n            </span><span class="s1">view.contentDOM.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; null);</span><span class="s3">\n        </span><span class="s1">if (browser.gecko)</span><span class="s3">\n            </span><span class="s1">firefoxCopyCutHack(view.contentDOM.ownerDocument);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">handleEvent(event) {</span><span class="s3">\n        </span><span class="s1">if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event))</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">if (event.type == </span><span class="s3">\&quot;</span><span class="s1">keydown</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; this.keydown(event))</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">this.runHandlers(event.type, event);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">runHandlers(type, event) {</span><span class="s3">\n        </span><span class="s1">let handlers = this.handlers[type];</span><span class="s3">\n        </span><span class="s1">if (handlers) {</span><span class="s3">\n            </span><span class="s1">for (let observer of handlers.observers)</span><span class="s3">\n                </span><span class="s1">observer(this.view, event);</span><span class="s3">\n            </span><span class="s1">for (let handler of handlers.handlers) {</span><span class="s3">\n                </span><span class="s1">if (event.defaultPrevented)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">if (handler(this.view, event)) {</span><span class="s3">\n                    </span><span class="s1">event.preventDefault();</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ensureHandlers(plugins) {</span><span class="s3">\n        </span><span class="s1">let handlers = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;</span><span class="s3">\n        </span><span class="s1">for (let type in handlers)</span><span class="s3">\n            </span><span class="s1">if (type != </span><span class="s3">\&quot;</span><span class="s1">scroll</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">let passive = !handlers[type].handlers.length;</span><span class="s3">\n                </span><span class="s1">let exists = prev[type];</span><span class="s3">\n                </span><span class="s1">if (exists &amp;&amp; passive != !exists.handlers.length) {</span><span class="s3">\n                    </span><span class="s1">dom.removeEventListener(type, this.handleEvent);</span><span class="s3">\n                    </span><span class="s1">exists = null;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (!exists)</span><span class="s3">\n                    </span><span class="s1">dom.addEventListener(type, this.handleEvent, { passive });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let type in prev)</span><span class="s3">\n            </span><span class="s1">if (type != </span><span class="s3">\&quot;</span><span class="s1">scroll</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !handlers[type])</span><span class="s3">\n                </span><span class="s1">dom.removeEventListener(type, this.handleEvent);</span><span class="s3">\n        </span><span class="s1">this.handlers = handlers;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">keydown(event) {</span><span class="s3">\n        </span><span class="s1">// Must always run, even if a custom handler handled the event</span><span class="s3">\n        </span><span class="s1">this.lastKeyCode = event.keyCode;</span><span class="s3">\n        </span><span class="s1">this.lastKeyTime = Date.now();</span><span class="s3">\n        </span><span class="s1">if (event.keyCode == 9 &amp;&amp; this.tabFocusMode &gt; -1 &amp;&amp; (!this.tabFocusMode || Date.now() &lt;= this.tabFocusMode))</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">if (this.tabFocusMode &gt; 0 &amp;&amp; event.keyCode != 27 &amp;&amp; modifierCodes.indexOf(event.keyCode) &lt; 0)</span><span class="s3">\n            </span><span class="s1">this.tabFocusMode = -1;</span><span class="s3">\n        </span><span class="s1">// Chrome for Android usually doesn't fire proper key events, but</span><span class="s3">\n        </span><span class="s1">// occasionally does, usually surrounded by a bunch of complicated</span><span class="s3">\n        </span><span class="s1">// composition changes. When an enter or backspace key event is</span><span class="s3">\n        </span><span class="s1">// seen, hold off on handling DOM events for a bit, and then</span><span class="s3">\n        </span><span class="s1">// dispatch it.</span><span class="s3">\n        </span><span class="s1">if (browser.android &amp;&amp; browser.chrome &amp;&amp; !event.synthetic &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(event.keyCode == 13 || event.keyCode == 8)) {</span><span class="s3">\n            </span><span class="s1">this.view.observer.delayAndroidKey(event.key, event.keyCode);</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Preventing the default behavior of Enter on iOS makes the</span><span class="s3">\n        </span><span class="s1">// virtual keyboard get stuck in the wrong (lowercase)</span><span class="s3">\n        </span><span class="s1">// state. So we let it go through, and then, in</span><span class="s3">\n        </span><span class="s1">// applyDOMChange, notify key handlers of it and reset to</span><span class="s3">\n        </span><span class="s1">// the state they produce.</span><span class="s3">\n        </span><span class="s1">let pending;</span><span class="s3">\n        </span><span class="s1">if (browser.ios &amp;&amp; !event.synthetic &amp;&amp; !event.altKey &amp;&amp; !event.metaKey &amp;&amp;</span><span class="s3">\n            </span><span class="s1">((pending = PendingKeys.find(key =&gt; key.keyCode == event.keyCode)) &amp;&amp; !event.ctrlKey ||</span><span class="s3">\n                </span><span class="s1">EmacsyPendingKeys.indexOf(event.key) &gt; -1 &amp;&amp; event.ctrlKey &amp;&amp; !event.shiftKey)) {</span><span class="s3">\n            </span><span class="s1">this.pendingIOSKey = pending || event;</span><span class="s3">\n            </span><span class="s1">setTimeout(() =&gt; this.flushIOSKey(), 250);</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (event.keyCode != 229)</span><span class="s3">\n            </span><span class="s1">this.view.observer.forceFlush();</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">flushIOSKey(change) {</span><span class="s3">\n        </span><span class="s1">let key = this.pendingIOSKey;</span><span class="s3">\n        </span><span class="s1">if (!key)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">// This looks like an autocorrection before Enter</span><span class="s3">\n        </span><span class="s1">if (key.key == </span><span class="s3">\&quot;</span><span class="s1">Enter</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; change &amp;&amp; change.from &lt; change.to &amp;&amp; /^</span><span class="s3">\\</span><span class="s1">S+$/.test(change.insert.toString()))</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">this.pendingIOSKey = undefined;</span><span class="s3">\n        </span><span class="s1">return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : undefined);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ignoreDuringComposition(event) {</span><span class="s3">\n        </span><span class="s1">if (!/^key/.test(event.type))</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">if (this.composing &gt; 0)</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">// See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.</span><span class="s3">\n        </span><span class="s1">// On some input method editors (IMEs), the Enter key is used to</span><span class="s3">\n        </span><span class="s1">// confirm character selection. On Safari, when Enter is pressed,</span><span class="s3">\n        </span><span class="s1">// compositionend and keydown events are sometimes emitted in the</span><span class="s3">\n        </span><span class="s1">// wrong order. The key event should still be ignored, even when</span><span class="s3">\n        </span><span class="s1">// it happens after the compositionend event.</span><span class="s3">\n        </span><span class="s1">if (browser.safari &amp;&amp; !browser.ios &amp;&amp; this.compositionPendingKey &amp;&amp; Date.now() - this.compositionEndedAt &lt; 100) {</span><span class="s3">\n            </span><span class="s1">this.compositionPendingKey = false;</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">startMouseSelection(mouseSelection) {</span><span class="s3">\n        </span><span class="s1">if (this.mouseSelection)</span><span class="s3">\n            </span><span class="s1">this.mouseSelection.destroy();</span><span class="s3">\n        </span><span class="s1">this.mouseSelection = mouseSelection;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">this.view.observer.update(update);</span><span class="s3">\n        </span><span class="s1">if (this.mouseSelection)</span><span class="s3">\n            </span><span class="s1">this.mouseSelection.update(update);</span><span class="s3">\n        </span><span class="s1">if (this.draggedContent &amp;&amp; update.docChanged)</span><span class="s3">\n            </span><span class="s1">this.draggedContent = this.draggedContent.map(update.changes);</span><span class="s3">\n        </span><span class="s1">if (update.transactions.length)</span><span class="s3">\n            </span><span class="s1">this.lastKeyCode = this.lastSelectionTime = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">destroy() {</span><span class="s3">\n        </span><span class="s1">if (this.mouseSelection)</span><span class="s3">\n            </span><span class="s1">this.mouseSelection.destroy();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function bindHandler(plugin, handler) {</span><span class="s3">\n    </span><span class="s1">return (view, event) =&gt; {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">return handler.call(plugin, event, view);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (e) {</span><span class="s3">\n            </span><span class="s1">logException(view.state, e);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function computeHandlers(plugins) {</span><span class="s3">\n    </span><span class="s1">let result = Object.create(null);</span><span class="s3">\n    </span><span class="s1">function record(type) {</span><span class="s3">\n        </span><span class="s1">return result[type] || (result[type] = { observers: [], handlers: [] });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (let plugin of plugins) {</span><span class="s3">\n        </span><span class="s1">let spec = plugin.spec;</span><span class="s3">\n        </span><span class="s1">if (spec &amp;&amp; spec.domEventHandlers)</span><span class="s3">\n            </span><span class="s1">for (let type in spec.domEventHandlers) {</span><span class="s3">\n                </span><span class="s1">let f = spec.domEventHandlers[type];</span><span class="s3">\n                </span><span class="s1">if (f)</span><span class="s3">\n                    </span><span class="s1">record(type).handlers.push(bindHandler(plugin.value, f));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (spec &amp;&amp; spec.domEventObservers)</span><span class="s3">\n            </span><span class="s1">for (let type in spec.domEventObservers) {</span><span class="s3">\n                </span><span class="s1">let f = spec.domEventObservers[type];</span><span class="s3">\n                </span><span class="s1">if (f)</span><span class="s3">\n                    </span><span class="s1">record(type).observers.push(bindHandler(plugin.value, f));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (let type in handlers)</span><span class="s3">\n        </span><span class="s1">record(type).handlers.push(handlers[type]);</span><span class="s3">\n    </span><span class="s1">for (let type in observers)</span><span class="s3">\n        </span><span class="s1">record(type).observers.push(observers[type]);</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const PendingKeys = [</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Backspace</span><span class="s3">\&quot;</span><span class="s1">, keyCode: 8, inputType: </span><span class="s3">\&quot;</span><span class="s1">deleteContentBackward</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Enter</span><span class="s3">\&quot;</span><span class="s1">, keyCode: 13, inputType: </span><span class="s3">\&quot;</span><span class="s1">insertParagraph</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Enter</span><span class="s3">\&quot;</span><span class="s1">, keyCode: 13, inputType: </span><span class="s3">\&quot;</span><span class="s1">insertLineBreak</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Delete</span><span class="s3">\&quot;</span><span class="s1">, keyCode: 46, inputType: </span><span class="s3">\&quot;</span><span class="s1">deleteContentForward</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">const EmacsyPendingKeys = </span><span class="s3">\&quot;</span><span class="s1">dthko</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">// Key codes for modifier keys</span><span class="s3">\n</span><span class="s1">const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];</span><span class="s3">\n</span><span class="s1">const dragScrollMargin = 6;</span><span class="s3">\n</span><span class="s1">function dragScrollSpeed(dist) {</span><span class="s3">\n    </span><span class="s1">return Math.max(0, dist) * 0.7 + 8;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function dist(a, b) {</span><span class="s3">\n    </span><span class="s1">return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class MouseSelection {</span><span class="s3">\n    </span><span class="s1">constructor(view, startEvent, style, mustSelect) {</span><span class="s3">\n        </span><span class="s1">this.view = view;</span><span class="s3">\n        </span><span class="s1">this.startEvent = startEvent;</span><span class="s3">\n        </span><span class="s1">this.style = style;</span><span class="s3">\n        </span><span class="s1">this.mustSelect = mustSelect;</span><span class="s3">\n        </span><span class="s1">this.scrollSpeed = { x: 0, y: 0 };</span><span class="s3">\n        </span><span class="s1">this.scrolling = -1;</span><span class="s3">\n        </span><span class="s1">this.lastEvent = startEvent;</span><span class="s3">\n        </span><span class="s1">this.scrollParents = scrollableParents(view.contentDOM);</span><span class="s3">\n        </span><span class="s1">this.atoms = view.state.facet(atomicRanges).map(f =&gt; f(view));</span><span class="s3">\n        </span><span class="s1">let doc = view.contentDOM.ownerDocument;</span><span class="s3">\n        </span><span class="s1">doc.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">mousemove</span><span class="s3">\&quot;</span><span class="s1">, this.move = this.move.bind(this));</span><span class="s3">\n        </span><span class="s1">doc.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">mouseup</span><span class="s3">\&quot;</span><span class="s1">, this.up = this.up.bind(this));</span><span class="s3">\n        </span><span class="s1">this.extend = startEvent.shiftKey;</span><span class="s3">\n        </span><span class="s1">this.multiple = view.state.facet(EditorState.allowMultipleSelections) &amp;&amp; addsSelectionRange(view, startEvent);</span><span class="s3">\n        </span><span class="s1">this.dragging = isInPrimarySelection(view, startEvent) &amp;&amp; getClickType(startEvent) == 1 ? null : false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">start(event) {</span><span class="s3">\n        </span><span class="s1">// When clicking outside of the selection, immediately apply the</span><span class="s3">\n        </span><span class="s1">// effect of starting the selection</span><span class="s3">\n        </span><span class="s1">if (this.dragging === false)</span><span class="s3">\n            </span><span class="s1">this.select(event);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">move(event) {</span><span class="s3">\n        </span><span class="s1">if (event.buttons == 0)</span><span class="s3">\n            </span><span class="s1">return this.destroy();</span><span class="s3">\n        </span><span class="s1">if (this.dragging || this.dragging == null &amp;&amp; dist(this.startEvent, event) &lt; 10)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">this.select(this.lastEvent = event);</span><span class="s3">\n        </span><span class="s1">let sx = 0, sy = 0;</span><span class="s3">\n        </span><span class="s1">let left = 0, top = 0, right = this.view.win.innerWidth, bottom = this.view.win.innerHeight;</span><span class="s3">\n        </span><span class="s1">if (this.scrollParents.x)</span><span class="s3">\n            </span><span class="s1">({ left, right } = this.scrollParents.x.getBoundingClientRect());</span><span class="s3">\n        </span><span class="s1">if (this.scrollParents.y)</span><span class="s3">\n            </span><span class="s1">({ top, bottom } = this.scrollParents.y.getBoundingClientRect());</span><span class="s3">\n        </span><span class="s1">let margins = getScrollMargins(this.view);</span><span class="s3">\n        </span><span class="s1">if (event.clientX - margins.left &lt;= left + dragScrollMargin)</span><span class="s3">\n            </span><span class="s1">sx = -dragScrollSpeed(left - event.clientX);</span><span class="s3">\n        </span><span class="s1">else if (event.clientX + margins.right &gt;= right - dragScrollMargin)</span><span class="s3">\n            </span><span class="s1">sx = dragScrollSpeed(event.clientX - right);</span><span class="s3">\n        </span><span class="s1">if (event.clientY - margins.top &lt;= top + dragScrollMargin)</span><span class="s3">\n            </span><span class="s1">sy = -dragScrollSpeed(top - event.clientY);</span><span class="s3">\n        </span><span class="s1">else if (event.clientY + margins.bottom &gt;= bottom - dragScrollMargin)</span><span class="s3">\n            </span><span class="s1">sy = dragScrollSpeed(event.clientY - bottom);</span><span class="s3">\n        </span><span class="s1">this.setScrollSpeed(sx, sy);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">up(event) {</span><span class="s3">\n        </span><span class="s1">if (this.dragging == null)</span><span class="s3">\n            </span><span class="s1">this.select(this.lastEvent);</span><span class="s3">\n        </span><span class="s1">if (!this.dragging)</span><span class="s3">\n            </span><span class="s1">event.preventDefault();</span><span class="s3">\n        </span><span class="s1">this.destroy();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">destroy() {</span><span class="s3">\n        </span><span class="s1">this.setScrollSpeed(0, 0);</span><span class="s3">\n        </span><span class="s1">let doc = this.view.contentDOM.ownerDocument;</span><span class="s3">\n        </span><span class="s1">doc.removeEventListener(</span><span class="s3">\&quot;</span><span class="s1">mousemove</span><span class="s3">\&quot;</span><span class="s1">, this.move);</span><span class="s3">\n        </span><span class="s1">doc.removeEventListener(</span><span class="s3">\&quot;</span><span class="s1">mouseup</span><span class="s3">\&quot;</span><span class="s1">, this.up);</span><span class="s3">\n        </span><span class="s1">this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setScrollSpeed(sx, sy) {</span><span class="s3">\n        </span><span class="s1">this.scrollSpeed = { x: sx, y: sy };</span><span class="s3">\n        </span><span class="s1">if (sx || sy) {</span><span class="s3">\n            </span><span class="s1">if (this.scrolling &lt; 0)</span><span class="s3">\n                </span><span class="s1">this.scrolling = setInterval(() =&gt; this.scroll(), 50);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (this.scrolling &gt; -1) {</span><span class="s3">\n            </span><span class="s1">clearInterval(this.scrolling);</span><span class="s3">\n            </span><span class="s1">this.scrolling = -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scroll() {</span><span class="s3">\n        </span><span class="s1">let { x, y } = this.scrollSpeed;</span><span class="s3">\n        </span><span class="s1">if (x &amp;&amp; this.scrollParents.x) {</span><span class="s3">\n            </span><span class="s1">this.scrollParents.x.scrollLeft += x;</span><span class="s3">\n            </span><span class="s1">x = 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (y &amp;&amp; this.scrollParents.y) {</span><span class="s3">\n            </span><span class="s1">this.scrollParents.y.scrollTop += y;</span><span class="s3">\n            </span><span class="s1">y = 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (x || y)</span><span class="s3">\n            </span><span class="s1">this.view.win.scrollBy(x, y);</span><span class="s3">\n        </span><span class="s1">if (this.dragging === false)</span><span class="s3">\n            </span><span class="s1">this.select(this.lastEvent);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">skipAtoms(sel) {</span><span class="s3">\n        </span><span class="s1">let ranges = null;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; sel.ranges.length; i++) {</span><span class="s3">\n            </span><span class="s1">let range = sel.ranges[i], updated = null;</span><span class="s3">\n            </span><span class="s1">if (range.empty) {</span><span class="s3">\n                </span><span class="s1">let pos = skipAtomicRanges(this.atoms, range.from, 0);</span><span class="s3">\n                </span><span class="s1">if (pos != range.from)</span><span class="s3">\n                    </span><span class="s1">updated = EditorSelection.cursor(pos, -1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let from = skipAtomicRanges(this.atoms, range.from, -1);</span><span class="s3">\n                </span><span class="s1">let to = skipAtomicRanges(this.atoms, range.to, 1);</span><span class="s3">\n                </span><span class="s1">if (from != range.from || to != range.to)</span><span class="s3">\n                    </span><span class="s1">updated = EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (updated) {</span><span class="s3">\n                </span><span class="s1">if (!ranges)</span><span class="s3">\n                    </span><span class="s1">ranges = sel.ranges.slice();</span><span class="s3">\n                </span><span class="s1">ranges[i] = updated;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return ranges ? EditorSelection.create(ranges, sel.mainIndex) : sel;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">select(event) {</span><span class="s3">\n        </span><span class="s1">let { view } = this, selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));</span><span class="s3">\n        </span><span class="s1">if (this.mustSelect || !selection.eq(view.state.selection, this.dragging === false))</span><span class="s3">\n            </span><span class="s1">this.view.dispatch({</span><span class="s3">\n                </span><span class="s1">selection,</span><span class="s3">\n                </span><span class="s1">userEvent: </span><span class="s3">\&quot;</span><span class="s1">select.pointer</span><span class="s3">\&quot;\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.mustSelect = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">if (update.transactions.some(tr =&gt; tr.isUserEvent(</span><span class="s3">\&quot;</span><span class="s1">input.type</span><span class="s3">\&quot;</span><span class="s1">)))</span><span class="s3">\n            </span><span class="s1">this.destroy();</span><span class="s3">\n        </span><span class="s1">else if (this.style.update(update))</span><span class="s3">\n            </span><span class="s1">setTimeout(() =&gt; this.select(this.lastEvent), 20);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addsSelectionRange(view, event) {</span><span class="s3">\n    </span><span class="s1">let facet = view.state.facet(clickAddsSelectionRange);</span><span class="s3">\n    </span><span class="s1">return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function dragMovesSelection(view, event) {</span><span class="s3">\n    </span><span class="s1">let facet = view.state.facet(dragMovesSelection$1);</span><span class="s3">\n    </span><span class="s1">return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isInPrimarySelection(view, event) {</span><span class="s3">\n    </span><span class="s1">let { main } = view.state.selection;</span><span class="s3">\n    </span><span class="s1">if (main.empty)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">// On boundary clicks, check whether the coordinates are inside the</span><span class="s3">\n    </span><span class="s1">// selection's client rectangles</span><span class="s3">\n    </span><span class="s1">let sel = getSelection(view.root);</span><span class="s3">\n    </span><span class="s1">if (!sel || sel.rangeCount == 0)</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">let rects = sel.getRangeAt(0).getClientRects();</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; rects.length; i++) {</span><span class="s3">\n        </span><span class="s1">let rect = rects[i];</span><span class="s3">\n        </span><span class="s1">if (rect.left &lt;= event.clientX &amp;&amp; rect.right &gt;= event.clientX &amp;&amp;</span><span class="s3">\n            </span><span class="s1">rect.top &lt;= event.clientY &amp;&amp; rect.bottom &gt;= event.clientY)</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function eventBelongsToEditor(view, event) {</span><span class="s3">\n    </span><span class="s1">if (!event.bubbles)</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">if (event.defaultPrevented)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)</span><span class="s3">\n        </span><span class="s1">if (!node || node.nodeType == 11 || ((cView = ContentView.get(node)) &amp;&amp; cView.ignoreEvent(event)))</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const handlers = /*@__PURE__*/Object.create(null);</span><span class="s3">\n</span><span class="s1">const observers = /*@__PURE__*/Object.create(null);</span><span class="s3">\n</span><span class="s1">// This is very crude, but unfortunately both these browsers _pretend_</span><span class="s3">\n</span><span class="s1">// that they have a clipboard APIall the objects and methods are</span><span class="s3">\n</span><span class="s1">// there, they just don't work, and they are hard to test.</span><span class="s3">\n</span><span class="s1">const brokenClipboardAPI = (browser.ie &amp;&amp; browser.ie_version &lt; 15) ||</span><span class="s3">\n    </span><span class="s1">(browser.ios &amp;&amp; browser.webkit_version &lt; 604);</span><span class="s3">\n</span><span class="s1">function capturePaste(view) {</span><span class="s3">\n    </span><span class="s1">let parent = view.dom.parentNode;</span><span class="s3">\n    </span><span class="s1">if (!parent)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">let target = parent.appendChild(document.createElement(</span><span class="s3">\&quot;</span><span class="s1">textarea</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">target.style.cssText = </span><span class="s3">\&quot;</span><span class="s1">position: fixed; left: -10000px; top: 10px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">target.focus();</span><span class="s3">\n    </span><span class="s1">setTimeout(() =&gt; {</span><span class="s3">\n        </span><span class="s1">view.focus();</span><span class="s3">\n        </span><span class="s1">target.remove();</span><span class="s3">\n        </span><span class="s1">doPaste(view, target.value);</span><span class="s3">\n    </span><span class="s1">}, 50);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function textFilter(state, facet, text) {</span><span class="s3">\n    </span><span class="s1">for (let filter of state.facet(facet))</span><span class="s3">\n        </span><span class="s1">text = filter(text, state);</span><span class="s3">\n    </span><span class="s1">return text;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function doPaste(view, input) {</span><span class="s3">\n    </span><span class="s1">input = textFilter(view.state, clipboardInputFilter, input);</span><span class="s3">\n    </span><span class="s1">let { state } = view, changes, i = 1, text = state.toText(input);</span><span class="s3">\n    </span><span class="s1">let byLine = text.lines == state.selection.ranges.length;</span><span class="s3">\n    </span><span class="s1">let linewise = lastLinewiseCopy != null &amp;&amp; state.selection.ranges.every(r =&gt; r.empty) &amp;&amp; lastLinewiseCopy == text.toString();</span><span class="s3">\n    </span><span class="s1">if (linewise) {</span><span class="s3">\n        </span><span class="s1">let lastLine = -1;</span><span class="s3">\n        </span><span class="s1">changes = state.changeByRange(range =&gt; {</span><span class="s3">\n            </span><span class="s1">let line = state.doc.lineAt(range.from);</span><span class="s3">\n            </span><span class="s1">if (line.from == lastLine)</span><span class="s3">\n                </span><span class="s1">return { range };</span><span class="s3">\n            </span><span class="s1">lastLine = line.from;</span><span class="s3">\n            </span><span class="s1">let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);</span><span class="s3">\n            </span><span class="s1">return { changes: { from: line.from, insert },</span><span class="s3">\n                </span><span class="s1">range: EditorSelection.cursor(range.from + insert.length) };</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (byLine) {</span><span class="s3">\n        </span><span class="s1">changes = state.changeByRange(range =&gt; {</span><span class="s3">\n            </span><span class="s1">let line = text.line(i++);</span><span class="s3">\n            </span><span class="s1">return { changes: { from: range.from, to: range.to, insert: line.text },</span><span class="s3">\n                </span><span class="s1">range: EditorSelection.cursor(range.from + line.length) };</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">changes = state.replaceSelection(text);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">view.dispatch(changes, {</span><span class="s3">\n        </span><span class="s1">userEvent: </span><span class="s3">\&quot;</span><span class="s1">input.paste</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">scrollIntoView: true</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">observers.scroll = view =&gt; {</span><span class="s3">\n    </span><span class="s1">view.inputState.lastScrollTop = view.scrollDOM.scrollTop;</span><span class="s3">\n    </span><span class="s1">view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">handlers.keydown = (view, event) =&gt; {</span><span class="s3">\n    </span><span class="s1">view.inputState.setSelectionOrigin(</span><span class="s3">\&quot;</span><span class="s1">select</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (event.keyCode == 27 &amp;&amp; view.inputState.tabFocusMode != 0)</span><span class="s3">\n        </span><span class="s1">view.inputState.tabFocusMode = Date.now() + 2000;</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">observers.touchstart = (view, e) =&gt; {</span><span class="s3">\n    </span><span class="s1">view.inputState.lastTouchTime = Date.now();</span><span class="s3">\n    </span><span class="s1">view.inputState.setSelectionOrigin(</span><span class="s3">\&quot;</span><span class="s1">select.pointer</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">observers.touchmove = view =&gt; {</span><span class="s3">\n    </span><span class="s1">view.inputState.setSelectionOrigin(</span><span class="s3">\&quot;</span><span class="s1">select.pointer</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">handlers.mousedown = (view, event) =&gt; {</span><span class="s3">\n    </span><span class="s1">view.observer.flush();</span><span class="s3">\n    </span><span class="s1">if (view.inputState.lastTouchTime &gt; Date.now() - 2000)</span><span class="s3">\n        </span><span class="s1">return false; // Ignore touch interaction</span><span class="s3">\n    </span><span class="s1">let style = null;</span><span class="s3">\n    </span><span class="s1">for (let makeStyle of view.state.facet(mouseSelectionStyle)) {</span><span class="s3">\n        </span><span class="s1">style = makeStyle(view, event);</span><span class="s3">\n        </span><span class="s1">if (style)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!style &amp;&amp; event.button == 0)</span><span class="s3">\n        </span><span class="s1">style = basicMouseSelection(view, event);</span><span class="s3">\n    </span><span class="s1">if (style) {</span><span class="s3">\n        </span><span class="s1">let mustFocus = !view.hasFocus;</span><span class="s3">\n        </span><span class="s1">view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));</span><span class="s3">\n        </span><span class="s1">if (mustFocus)</span><span class="s3">\n            </span><span class="s1">view.observer.ignore(() =&gt; {</span><span class="s3">\n                </span><span class="s1">focusPreventScroll(view.contentDOM);</span><span class="s3">\n                </span><span class="s1">let active = view.root.activeElement;</span><span class="s3">\n                </span><span class="s1">if (active &amp;&amp; !active.contains(view.contentDOM))</span><span class="s3">\n                    </span><span class="s1">active.blur();</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">let mouseSel = view.inputState.mouseSelection;</span><span class="s3">\n        </span><span class="s1">if (mouseSel) {</span><span class="s3">\n            </span><span class="s1">mouseSel.start(event);</span><span class="s3">\n            </span><span class="s1">return mouseSel.dragging === false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function rangeForClick(view, pos, bias, type) {</span><span class="s3">\n    </span><span class="s1">if (type == 1) { // Single click</span><span class="s3">\n        </span><span class="s1">return EditorSelection.cursor(pos, bias);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (type == 2) { // Double click</span><span class="s3">\n        </span><span class="s1">return groupAt(view.state, pos, bias);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else { // Triple click</span><span class="s3">\n        </span><span class="s1">let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);</span><span class="s3">\n        </span><span class="s1">let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;</span><span class="s3">\n        </span><span class="s1">if (to &lt; view.state.doc.length &amp;&amp; to == line.to)</span><span class="s3">\n            </span><span class="s1">to++;</span><span class="s3">\n        </span><span class="s1">return EditorSelection.range(from, to);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">let inside = (x, y, rect) =&gt; y &gt;= rect.top &amp;&amp; y &lt;= rect.bottom &amp;&amp; x &gt;= rect.left &amp;&amp; x &lt;= rect.right;</span><span class="s3">\n</span><span class="s1">// Try to determine, for the given coordinates, associated with the</span><span class="s3">\n</span><span class="s1">// given position, whether they are related to the element before or</span><span class="s3">\n</span><span class="s1">// the element after the position.</span><span class="s3">\n</span><span class="s1">function findPositionSide(view, pos, x, y) {</span><span class="s3">\n    </span><span class="s1">let line = LineView.find(view.docView, pos);</span><span class="s3">\n    </span><span class="s1">if (!line)</span><span class="s3">\n        </span><span class="s1">return 1;</span><span class="s3">\n    </span><span class="s1">let off = pos - line.posAtStart;</span><span class="s3">\n    </span><span class="s1">// Line boundaries point into the line</span><span class="s3">\n    </span><span class="s1">if (off == 0)</span><span class="s3">\n        </span><span class="s1">return 1;</span><span class="s3">\n    </span><span class="s1">if (off == line.length)</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">// Positions on top of an element point at that element</span><span class="s3">\n    </span><span class="s1">let before = line.coordsAt(off, -1);</span><span class="s3">\n    </span><span class="s1">if (before &amp;&amp; inside(x, y, before))</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">let after = line.coordsAt(off, 1);</span><span class="s3">\n    </span><span class="s1">if (after &amp;&amp; inside(x, y, after))</span><span class="s3">\n        </span><span class="s1">return 1;</span><span class="s3">\n    </span><span class="s1">// This is probably a line wrap point. Pick before if the point is</span><span class="s3">\n    </span><span class="s1">// above its bottom.</span><span class="s3">\n    </span><span class="s1">return before &amp;&amp; before.bottom &gt;= y ? -1 : 1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function queryPos(view, event) {</span><span class="s3">\n    </span><span class="s1">let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);</span><span class="s3">\n    </span><span class="s1">return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const BadMouseDetail = browser.ie &amp;&amp; browser.ie_version &lt;= 11;</span><span class="s3">\n</span><span class="s1">let lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;</span><span class="s3">\n</span><span class="s1">function getClickType(event) {</span><span class="s3">\n    </span><span class="s1">if (!BadMouseDetail)</span><span class="s3">\n        </span><span class="s1">return event.detail;</span><span class="s3">\n    </span><span class="s1">let last = lastMouseDown, lastTime = lastMouseDownTime;</span><span class="s3">\n    </span><span class="s1">lastMouseDown = event;</span><span class="s3">\n    </span><span class="s1">lastMouseDownTime = Date.now();</span><span class="s3">\n    </span><span class="s1">return lastMouseDownCount = !last || (lastTime &gt; Date.now() - 400 &amp;&amp; Math.abs(last.clientX - event.clientX) &lt; 2 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">Math.abs(last.clientY - event.clientY) &lt; 2) ? (lastMouseDownCount + 1) % 3 : 1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function basicMouseSelection(view, event) {</span><span class="s3">\n    </span><span class="s1">let start = queryPos(view, event), type = getClickType(event);</span><span class="s3">\n    </span><span class="s1">let startSel = view.state.selection;</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">update(update) {</span><span class="s3">\n            </span><span class="s1">if (update.docChanged) {</span><span class="s3">\n                </span><span class="s1">start.pos = update.changes.mapPos(start.pos);</span><span class="s3">\n                </span><span class="s1">startSel = startSel.map(update.changes);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">get(event, extend, multiple) {</span><span class="s3">\n            </span><span class="s1">let cur = queryPos(view, event), removed;</span><span class="s3">\n            </span><span class="s1">let range = rangeForClick(view, cur.pos, cur.bias, type);</span><span class="s3">\n            </span><span class="s1">if (start.pos != cur.pos &amp;&amp; !extend) {</span><span class="s3">\n                </span><span class="s1">let startRange = rangeForClick(view, start.pos, start.bias, type);</span><span class="s3">\n                </span><span class="s1">let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);</span><span class="s3">\n                </span><span class="s1">range = from &lt; range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (extend)</span><span class="s3">\n                </span><span class="s1">return startSel.replaceRange(startSel.main.extend(range.from, range.to));</span><span class="s3">\n            </span><span class="s1">else if (multiple &amp;&amp; type == 1 &amp;&amp; startSel.ranges.length &gt; 1 &amp;&amp; (removed = removeRangeAround(startSel, cur.pos)))</span><span class="s3">\n                </span><span class="s1">return removed;</span><span class="s3">\n            </span><span class="s1">else if (multiple)</span><span class="s3">\n                </span><span class="s1">return startSel.addRange(range);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">return EditorSelection.create([range]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function removeRangeAround(sel, pos) {</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; sel.ranges.length; i++) {</span><span class="s3">\n        </span><span class="s1">let { from, to } = sel.ranges[i];</span><span class="s3">\n        </span><span class="s1">if (from &lt;= pos &amp;&amp; to &gt;= pos)</span><span class="s3">\n            </span><span class="s1">return EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex &gt; i ? 1 : 0));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">handlers.dragstart = (view, event) =&gt; {</span><span class="s3">\n    </span><span class="s1">let { selection: { main: range } } = view.state;</span><span class="s3">\n    </span><span class="s1">if (event.target.draggable) {</span><span class="s3">\n        </span><span class="s1">let cView = view.docView.nearest(event.target);</span><span class="s3">\n        </span><span class="s1">if (cView &amp;&amp; cView.isWidget) {</span><span class="s3">\n            </span><span class="s1">let from = cView.posAtStart, to = from + cView.length;</span><span class="s3">\n            </span><span class="s1">if (from &gt;= range.to || to &lt;= range.from)</span><span class="s3">\n                </span><span class="s1">range = EditorSelection.range(from, to);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let { inputState } = view;</span><span class="s3">\n    </span><span class="s1">if (inputState.mouseSelection)</span><span class="s3">\n        </span><span class="s1">inputState.mouseSelection.dragging = true;</span><span class="s3">\n    </span><span class="s1">inputState.draggedContent = range;</span><span class="s3">\n    </span><span class="s1">if (event.dataTransfer) {</span><span class="s3">\n        </span><span class="s1">event.dataTransfer.setData(</span><span class="s3">\&quot;</span><span class="s1">Text</span><span class="s3">\&quot;</span><span class="s1">, textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range.from, range.to)));</span><span class="s3">\n        </span><span class="s1">event.dataTransfer.effectAllowed = </span><span class="s3">\&quot;</span><span class="s1">copyMove</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">handlers.dragend = view =&gt; {</span><span class="s3">\n    </span><span class="s1">view.inputState.draggedContent = null;</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function dropText(view, event, text, direct) {</span><span class="s3">\n    </span><span class="s1">text = textFilter(view.state, clipboardInputFilter, text);</span><span class="s3">\n    </span><span class="s1">if (!text)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);</span><span class="s3">\n    </span><span class="s1">let { draggedContent } = view.inputState;</span><span class="s3">\n    </span><span class="s1">let del = direct &amp;&amp; draggedContent &amp;&amp; dragMovesSelection(view, event)</span><span class="s3">\n        </span><span class="s1">? { from: draggedContent.from, to: draggedContent.to } : null;</span><span class="s3">\n    </span><span class="s1">let ins = { from: dropPos, insert: text };</span><span class="s3">\n    </span><span class="s1">let changes = view.state.changes(del ? [del, ins] : ins);</span><span class="s3">\n    </span><span class="s1">view.focus();</span><span class="s3">\n    </span><span class="s1">view.dispatch({</span><span class="s3">\n        </span><span class="s1">changes,</span><span class="s3">\n        </span><span class="s1">selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },</span><span class="s3">\n        </span><span class="s1">userEvent: del ? </span><span class="s3">\&quot;</span><span class="s1">move.drop</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">input.drop</span><span class="s3">\&quot;\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">view.inputState.draggedContent = null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">handlers.drop = (view, event) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!event.dataTransfer)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">if (view.state.readOnly)</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">let files = event.dataTransfer.files;</span><span class="s3">\n    </span><span class="s1">if (files &amp;&amp; files.length) { // For a file drop, read the file's text.</span><span class="s3">\n        </span><span class="s1">let text = Array(files.length), read = 0;</span><span class="s3">\n        </span><span class="s1">let finishFile = () =&gt; {</span><span class="s3">\n            </span><span class="s1">if (++read == files.length)</span><span class="s3">\n                </span><span class="s1">dropText(view, event, text.filter(s =&gt; s != null).join(view.state.lineBreak), false);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; files.length; i++) {</span><span class="s3">\n            </span><span class="s1">let reader = new FileReader;</span><span class="s3">\n            </span><span class="s1">reader.onerror = finishFile;</span><span class="s3">\n            </span><span class="s1">reader.onload = () =&gt; {</span><span class="s3">\n                </span><span class="s1">if (!/[</span><span class="s3">\\</span><span class="s1">x00-</span><span class="s3">\\</span><span class="s1">x08</span><span class="s3">\\</span><span class="s1">x0e-</span><span class="s3">\\</span><span class="s1">x1f]{2}/.test(reader.result))</span><span class="s3">\n                    </span><span class="s1">text[i] = reader.result;</span><span class="s3">\n                </span><span class="s1">finishFile();</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">reader.readAsText(files[i]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">let text = event.dataTransfer.getData(</span><span class="s3">\&quot;</span><span class="s1">Text</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (text) {</span><span class="s3">\n            </span><span class="s1">dropText(view, event, text, true);</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">handlers.paste = (view, event) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (view.state.readOnly)</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">view.observer.flush();</span><span class="s3">\n    </span><span class="s1">let data = brokenClipboardAPI ? null : event.clipboardData;</span><span class="s3">\n    </span><span class="s1">if (data) {</span><span class="s3">\n        </span><span class="s1">doPaste(view, data.getData(</span><span class="s3">\&quot;</span><span class="s1">text/plain</span><span class="s3">\&quot;</span><span class="s1">) || data.getData(</span><span class="s3">\&quot;</span><span class="s1">text/uri-list</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">capturePaste(view);</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function captureCopy(view, text) {</span><span class="s3">\n    </span><span class="s1">// The extra wrapper is somehow necessary on IE/Edge to prevent the</span><span class="s3">\n    </span><span class="s1">// content from being mangled when it is put onto the clipboard</span><span class="s3">\n    </span><span class="s1">let parent = view.dom.parentNode;</span><span class="s3">\n    </span><span class="s1">if (!parent)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">let target = parent.appendChild(document.createElement(</span><span class="s3">\&quot;</span><span class="s1">textarea</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">target.style.cssText = </span><span class="s3">\&quot;</span><span class="s1">position: fixed; left: -10000px; top: 10px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">target.value = text;</span><span class="s3">\n    </span><span class="s1">target.focus();</span><span class="s3">\n    </span><span class="s1">target.selectionEnd = text.length;</span><span class="s3">\n    </span><span class="s1">target.selectionStart = 0;</span><span class="s3">\n    </span><span class="s1">setTimeout(() =&gt; {</span><span class="s3">\n        </span><span class="s1">target.remove();</span><span class="s3">\n        </span><span class="s1">view.focus();</span><span class="s3">\n    </span><span class="s1">}, 50);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function copiedRange(state) {</span><span class="s3">\n    </span><span class="s1">let content = [], ranges = [], linewise = false;</span><span class="s3">\n    </span><span class="s1">for (let range of state.selection.ranges)</span><span class="s3">\n        </span><span class="s1">if (!range.empty) {</span><span class="s3">\n            </span><span class="s1">content.push(state.sliceDoc(range.from, range.to));</span><span class="s3">\n            </span><span class="s1">ranges.push(range);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!content.length) {</span><span class="s3">\n        </span><span class="s1">// Nothing selected, do a line-wise copy</span><span class="s3">\n        </span><span class="s1">let upto = -1;</span><span class="s3">\n        </span><span class="s1">for (let { from } of state.selection.ranges) {</span><span class="s3">\n            </span><span class="s1">let line = state.doc.lineAt(from);</span><span class="s3">\n            </span><span class="s1">if (line.number &gt; upto) {</span><span class="s3">\n                </span><span class="s1">content.push(line.text);</span><span class="s3">\n                </span><span class="s1">ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">upto = line.number;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">linewise = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return { text: textFilter(state, clipboardOutputFilter, content.join(state.lineBreak)), ranges, linewise };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">let lastLinewiseCopy = null;</span><span class="s3">\n</span><span class="s1">handlers.copy = handlers.cut = (view, event) =&gt; {</span><span class="s3">\n    </span><span class="s1">let { text, ranges, linewise } = copiedRange(view.state);</span><span class="s3">\n    </span><span class="s1">if (!text &amp;&amp; !linewise)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">lastLinewiseCopy = linewise ? text : null;</span><span class="s3">\n    </span><span class="s1">if (event.type == </span><span class="s3">\&quot;</span><span class="s1">cut</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !view.state.readOnly)</span><span class="s3">\n        </span><span class="s1">view.dispatch({</span><span class="s3">\n            </span><span class="s1">changes: ranges,</span><span class="s3">\n            </span><span class="s1">scrollIntoView: true,</span><span class="s3">\n            </span><span class="s1">userEvent: </span><span class="s3">\&quot;</span><span class="s1">delete.cut</span><span class="s3">\&quot;\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">let data = brokenClipboardAPI ? null : event.clipboardData;</span><span class="s3">\n    </span><span class="s1">if (data) {</span><span class="s3">\n        </span><span class="s1">data.clearData();</span><span class="s3">\n        </span><span class="s1">data.setData(</span><span class="s3">\&quot;</span><span class="s1">text/plain</span><span class="s3">\&quot;</span><span class="s1">, text);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">captureCopy(view, text);</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const isFocusChange = /*@__PURE__*/Annotation.define();</span><span class="s3">\n</span><span class="s1">function focusChangeTransaction(state, focus) {</span><span class="s3">\n    </span><span class="s1">let effects = [];</span><span class="s3">\n    </span><span class="s1">for (let getEffect of state.facet(focusChangeEffect)) {</span><span class="s3">\n        </span><span class="s1">let effect = getEffect(state, focus);</span><span class="s3">\n        </span><span class="s1">if (effect)</span><span class="s3">\n            </span><span class="s1">effects.push(effect);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return effects ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function updateForFocusChange(view) {</span><span class="s3">\n    </span><span class="s1">setTimeout(() =&gt; {</span><span class="s3">\n        </span><span class="s1">let focus = view.hasFocus;</span><span class="s3">\n        </span><span class="s1">if (focus != view.inputState.notifiedFocused) {</span><span class="s3">\n            </span><span class="s1">let tr = focusChangeTransaction(view.state, focus);</span><span class="s3">\n            </span><span class="s1">if (tr)</span><span class="s3">\n                </span><span class="s1">view.dispatch(tr);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">view.update([]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, 10);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">observers.focus = view =&gt; {</span><span class="s3">\n    </span><span class="s1">view.inputState.lastFocusTime = Date.now();</span><span class="s3">\n    </span><span class="s1">// When focusing reset the scroll position, move it back to where it was</span><span class="s3">\n    </span><span class="s1">if (!view.scrollDOM.scrollTop &amp;&amp; (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {</span><span class="s3">\n        </span><span class="s1">view.scrollDOM.scrollTop = view.inputState.lastScrollTop;</span><span class="s3">\n        </span><span class="s1">view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateForFocusChange(view);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">observers.blur = view =&gt; {</span><span class="s3">\n    </span><span class="s1">view.observer.clearSelectionRange();</span><span class="s3">\n    </span><span class="s1">updateForFocusChange(view);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">observers.compositionstart = observers.compositionupdate = view =&gt; {</span><span class="s3">\n    </span><span class="s1">if (view.observer.editContext)</span><span class="s3">\n        </span><span class="s1">return; // Composition handled by edit context</span><span class="s3">\n    </span><span class="s1">if (view.inputState.compositionFirstChange == null)</span><span class="s3">\n        </span><span class="s1">view.inputState.compositionFirstChange = true;</span><span class="s3">\n    </span><span class="s1">if (view.inputState.composing &lt; 0) {</span><span class="s3">\n        </span><span class="s1">// FIXME possibly set a timeout to clear it again on Android</span><span class="s3">\n        </span><span class="s1">view.inputState.composing = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">observers.compositionend = view =&gt; {</span><span class="s3">\n    </span><span class="s1">if (view.observer.editContext)</span><span class="s3">\n        </span><span class="s1">return; // Composition handled by edit context</span><span class="s3">\n    </span><span class="s1">view.inputState.composing = -1;</span><span class="s3">\n    </span><span class="s1">view.inputState.compositionEndedAt = Date.now();</span><span class="s3">\n    </span><span class="s1">view.inputState.compositionPendingKey = true;</span><span class="s3">\n    </span><span class="s1">view.inputState.compositionPendingChange = view.observer.pendingRecords().length &gt; 0;</span><span class="s3">\n    </span><span class="s1">view.inputState.compositionFirstChange = null;</span><span class="s3">\n    </span><span class="s1">if (browser.chrome &amp;&amp; browser.android) {</span><span class="s3">\n        </span><span class="s1">// Delay flushing for a bit on Android because it'll often fire a</span><span class="s3">\n        </span><span class="s1">// bunch of contradictory changes in a row at end of compositon</span><span class="s3">\n        </span><span class="s1">view.observer.flushSoon();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (view.inputState.compositionPendingChange) {</span><span class="s3">\n        </span><span class="s1">// If we found pending records, schedule a flush.</span><span class="s3">\n        </span><span class="s1">Promise.resolve().then(() =&gt; view.observer.flush());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">// Otherwise, make sure that, if no changes come in soon, the</span><span class="s3">\n        </span><span class="s1">// composition view is cleared.</span><span class="s3">\n        </span><span class="s1">setTimeout(() =&gt; {</span><span class="s3">\n            </span><span class="s1">if (view.inputState.composing &lt; 0 &amp;&amp; view.docView.hasComposition)</span><span class="s3">\n                </span><span class="s1">view.update([]);</span><span class="s3">\n        </span><span class="s1">}, 50);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">observers.contextmenu = view =&gt; {</span><span class="s3">\n    </span><span class="s1">view.inputState.lastContextMenu = Date.now();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">handlers.beforeinput = (view, event) =&gt; {</span><span class="s3">\n    </span><span class="s1">var _a, _b;</span><span class="s3">\n    </span><span class="s1">// In EditContext mode, we must handle insertReplacementText events</span><span class="s3">\n    </span><span class="s1">// directly, to make spell checking corrections work</span><span class="s3">\n    </span><span class="s1">if (event.inputType == </span><span class="s3">\&quot;</span><span class="s1">insertReplacementText</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; view.observer.editContext) {</span><span class="s3">\n        </span><span class="s1">let text = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData(</span><span class="s3">\&quot;</span><span class="s1">text/plain</span><span class="s3">\&quot;</span><span class="s1">), ranges = event.getTargetRanges();</span><span class="s3">\n        </span><span class="s1">if (text &amp;&amp; ranges.length) {</span><span class="s3">\n            </span><span class="s1">let r = ranges[0];</span><span class="s3">\n            </span><span class="s1">let from = view.posAtDOM(r.startContainer, r.startOffset), to = view.posAtDOM(r.endContainer, r.endOffset);</span><span class="s3">\n            </span><span class="s1">applyDOMChangeInner(view, { from, to, insert: view.state.toText(text) }, null);</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Because Chrome Android doesn't fire useful key events, use</span><span class="s3">\n    </span><span class="s1">// beforeinput to detect backspace (and possibly enter and delete,</span><span class="s3">\n    </span><span class="s1">// but those usually don't even seem to fire beforeinput events at</span><span class="s3">\n    </span><span class="s1">// the moment) and fake a key event for it.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// (preventDefault on beforeinput, though supported in the spec,</span><span class="s3">\n    </span><span class="s1">// seems to do nothing at all on Chrome).</span><span class="s3">\n    </span><span class="s1">let pending;</span><span class="s3">\n    </span><span class="s1">if (browser.chrome &amp;&amp; browser.android &amp;&amp; (pending = PendingKeys.find(key =&gt; key.inputType == event.inputType))) {</span><span class="s3">\n        </span><span class="s1">view.observer.delayAndroidKey(pending.key, pending.keyCode);</span><span class="s3">\n        </span><span class="s1">if (pending.key == </span><span class="s3">\&quot;</span><span class="s1">Backspace</span><span class="s3">\&quot; </span><span class="s1">|| pending.key == </span><span class="s3">\&quot;</span><span class="s1">Delete</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;</span><span class="s3">\n            </span><span class="s1">setTimeout(() =&gt; {</span><span class="s3">\n                </span><span class="s1">var _a;</span><span class="s3">\n                </span><span class="s1">// Backspacing near uneditable nodes on Chrome Android sometimes</span><span class="s3">\n                </span><span class="s1">// closes the virtual keyboard. This tries to crudely detect</span><span class="s3">\n                </span><span class="s1">// that and refocus to get it back.</span><span class="s3">\n                </span><span class="s1">if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) &gt; startViewHeight + 10 &amp;&amp; view.hasFocus) {</span><span class="s3">\n                    </span><span class="s1">view.contentDOM.blur();</span><span class="s3">\n                    </span><span class="s1">view.focus();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}, 100);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (browser.ios &amp;&amp; event.inputType == </span><span class="s3">\&quot;</span><span class="s1">deleteContentForward</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// For some reason, DOM changes (and beforeinput) happen _before_</span><span class="s3">\n        </span><span class="s1">// the key event for ctrl-d on iOS when using an external</span><span class="s3">\n        </span><span class="s1">// keyboard.</span><span class="s3">\n        </span><span class="s1">view.observer.flushSoon();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Safari will occasionally forget to fire compositionend at the end of a dead-key composition</span><span class="s3">\n    </span><span class="s1">if (browser.safari &amp;&amp; event.inputType == </span><span class="s3">\&quot;</span><span class="s1">insertText</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; view.inputState.composing &gt;= 0) {</span><span class="s3">\n        </span><span class="s1">setTimeout(() =&gt; observers.compositionend(view, event), 20);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const appliedFirefoxHack = /*@__PURE__*/new Set;</span><span class="s3">\n</span><span class="s1">// In Firefox, when cut/copy handlers are added to the document, that</span><span class="s3">\n</span><span class="s1">// somehow avoids a bug where those events aren't fired when the</span><span class="s3">\n</span><span class="s1">// selection is empty. See https://github.com/codemirror/dev/issues/1082</span><span class="s3">\n</span><span class="s1">// and https://bugzilla.mozilla.org/show_bug.cgi?id=995961</span><span class="s3">\n</span><span class="s1">function firefoxCopyCutHack(doc) {</span><span class="s3">\n    </span><span class="s1">if (!appliedFirefoxHack.has(doc)) {</span><span class="s3">\n        </span><span class="s1">appliedFirefoxHack.add(doc);</span><span class="s3">\n        </span><span class="s1">doc.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">copy</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; { });</span><span class="s3">\n        </span><span class="s1">doc.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">cut</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; { });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const wrappingWhiteSpace = [</span><span class="s3">\&quot;</span><span class="s1">pre-wrap</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">normal</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">pre-line</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">break-spaces</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">// Used to track, during updateHeight, if any actual heights changed</span><span class="s3">\n</span><span class="s1">let heightChangeFlag = false;</span><span class="s3">\n</span><span class="s1">function clearHeightChangeFlag() { heightChangeFlag = false; }</span><span class="s3">\n</span><span class="s1">class HeightOracle {</span><span class="s3">\n    </span><span class="s1">constructor(lineWrapping) {</span><span class="s3">\n        </span><span class="s1">this.lineWrapping = lineWrapping;</span><span class="s3">\n        </span><span class="s1">this.doc = Text.empty;</span><span class="s3">\n        </span><span class="s1">this.heightSamples = {};</span><span class="s3">\n        </span><span class="s1">this.lineHeight = 14; // The height of an entire line (line-height)</span><span class="s3">\n        </span><span class="s1">this.charWidth = 7;</span><span class="s3">\n        </span><span class="s1">this.textHeight = 14; // The height of the actual font (font-size)</span><span class="s3">\n        </span><span class="s1">this.lineLength = 30;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">heightForGap(from, to) {</span><span class="s3">\n        </span><span class="s1">let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;</span><span class="s3">\n        </span><span class="s1">if (this.lineWrapping)</span><span class="s3">\n            </span><span class="s1">lines += Math.max(0, Math.ceil(((to - from) - (lines * this.lineLength * 0.5)) / this.lineLength));</span><span class="s3">\n        </span><span class="s1">return this.lineHeight * lines;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">heightForLine(length) {</span><span class="s3">\n        </span><span class="s1">if (!this.lineWrapping)</span><span class="s3">\n            </span><span class="s1">return this.lineHeight;</span><span class="s3">\n        </span><span class="s1">let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));</span><span class="s3">\n        </span><span class="s1">return lines * this.lineHeight;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setDoc(doc) { this.doc = doc; return this; }</span><span class="s3">\n    </span><span class="s1">mustRefreshForWrapping(whiteSpace) {</span><span class="s3">\n        </span><span class="s1">return (wrappingWhiteSpace.indexOf(whiteSpace) &gt; -1) != this.lineWrapping;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mustRefreshForHeights(lineHeights) {</span><span class="s3">\n        </span><span class="s1">let newHeight = false;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; lineHeights.length; i++) {</span><span class="s3">\n            </span><span class="s1">let h = lineHeights[i];</span><span class="s3">\n            </span><span class="s1">if (h &lt; 0) {</span><span class="s3">\n                </span><span class="s1">i++;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (!this.heightSamples[Math.floor(h * 10)]) { // Round to .1 pixels</span><span class="s3">\n                </span><span class="s1">newHeight = true;</span><span class="s3">\n                </span><span class="s1">this.heightSamples[Math.floor(h * 10)] = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return newHeight;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {</span><span class="s3">\n        </span><span class="s1">let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) &gt; -1;</span><span class="s3">\n        </span><span class="s1">let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;</span><span class="s3">\n        </span><span class="s1">this.lineWrapping = lineWrapping;</span><span class="s3">\n        </span><span class="s1">this.lineHeight = lineHeight;</span><span class="s3">\n        </span><span class="s1">this.charWidth = charWidth;</span><span class="s3">\n        </span><span class="s1">this.textHeight = textHeight;</span><span class="s3">\n        </span><span class="s1">this.lineLength = lineLength;</span><span class="s3">\n        </span><span class="s1">if (changed) {</span><span class="s3">\n            </span><span class="s1">this.heightSamples = {};</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; knownHeights.length; i++) {</span><span class="s3">\n                </span><span class="s1">let h = knownHeights[i];</span><span class="s3">\n                </span><span class="s1">if (h &lt; 0)</span><span class="s3">\n                    </span><span class="s1">i++;</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">this.heightSamples[Math.floor(h * 10)] = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return changed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// This object is used by `updateHeight` to make DOM measurements</span><span class="s3">\n</span><span class="s1">// arrive at the right nides. The `heights` array is a sequence of</span><span class="s3">\n</span><span class="s1">// block heights, starting from position `from`.</span><span class="s3">\n</span><span class="s1">class MeasuredHeights {</span><span class="s3">\n    </span><span class="s1">constructor(from, heights) {</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.heights = heights;</span><span class="s3">\n        </span><span class="s1">this.index = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get more() { return this.index &lt; this.heights.length; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Record used to represent information about a block-level element</span><span class="s3">\n</span><span class="s1">in the editor view.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class BlockInfo {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The start of the element in the document.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">from, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The length of the element.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">length, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The top position of the element (relative to the top of the</span><span class="s3">\n    </span><span class="s1">document).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">top, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Its height.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">height, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal Weird packed field that holds an array of children</span><span class="s3">\n    </span><span class="s1">for composite blocks, a decoration for block widgets, and a</span><span class="s3">\n    </span><span class="s1">number indicating the amount of widget-create line breaks for</span><span class="s3">\n    </span><span class="s1">text blocks.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_content) {</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.length = length;</span><span class="s3">\n        </span><span class="s1">this.top = top;</span><span class="s3">\n        </span><span class="s1">this.height = height;</span><span class="s3">\n        </span><span class="s1">this._content = _content;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The type of element this is. When querying lines, this may be</span><span class="s3">\n    </span><span class="s1">an array of all the blocks that make up the line.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get type() {</span><span class="s3">\n        </span><span class="s1">return typeof this._content == </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">? BlockType.Text :</span><span class="s3">\n            </span><span class="s1">Array.isArray(this._content) ? this._content : this._content.type;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The end of the element as a document position.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get to() { return this.from + this.length; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The bottom position of the element.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get bottom() { return this.top + this.height; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">If this is a widget block, this will return the widget</span><span class="s3">\n    </span><span class="s1">associated with it.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get widget() {</span><span class="s3">\n        </span><span class="s1">return this._content instanceof PointDecoration ? this._content.widget : null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">If this is a textblock, this holds the number of line breaks</span><span class="s3">\n    </span><span class="s1">that appear in widgets inside the block.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get widgetLineBreaks() {</span><span class="s3">\n        </span><span class="s1">return typeof this._content == </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">? this._content : 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">join(other) {</span><span class="s3">\n        </span><span class="s1">let content = (Array.isArray(this._content) ? this._content : [this])</span><span class="s3">\n            </span><span class="s1">.concat(Array.isArray(other._content) ? other._content : [other]);</span><span class="s3">\n        </span><span class="s1">return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var QueryType = /*@__PURE__*/(function (QueryType) {</span><span class="s3">\n    </span><span class="s1">QueryType[QueryType[</span><span class="s3">\&quot;</span><span class="s1">ByPos</span><span class="s3">\&quot;</span><span class="s1">] = 0] = </span><span class="s3">\&quot;</span><span class="s1">ByPos</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">QueryType[QueryType[</span><span class="s3">\&quot;</span><span class="s1">ByHeight</span><span class="s3">\&quot;</span><span class="s1">] = 1] = </span><span class="s3">\&quot;</span><span class="s1">ByHeight</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">QueryType[QueryType[</span><span class="s3">\&quot;</span><span class="s1">ByPosNoHeight</span><span class="s3">\&quot;</span><span class="s1">] = 2] = </span><span class="s3">\&quot;</span><span class="s1">ByPosNoHeight</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">return QueryType})(QueryType || (QueryType = {}));</span><span class="s3">\n</span><span class="s1">const Epsilon = 1e-3;</span><span class="s3">\n</span><span class="s1">class HeightMap {</span><span class="s3">\n    </span><span class="s1">constructor(length, // The number of characters covered</span><span class="s3">\n    </span><span class="s1">height, // Height of this part of the document</span><span class="s3">\n    </span><span class="s1">flags = 2 /* Flag.Outdated */) {</span><span class="s3">\n        </span><span class="s1">this.length = length;</span><span class="s3">\n        </span><span class="s1">this.height = height;</span><span class="s3">\n        </span><span class="s1">this.flags = flags;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get outdated() { return (this.flags &amp; 2 /* Flag.Outdated */) &gt; 0; }</span><span class="s3">\n    </span><span class="s1">set outdated(value) { this.flags = (value ? 2 /* Flag.Outdated */ : 0) | (this.flags &amp; ~2 /* Flag.Outdated */); }</span><span class="s3">\n    </span><span class="s1">setHeight(height) {</span><span class="s3">\n        </span><span class="s1">if (this.height != height) {</span><span class="s3">\n            </span><span class="s1">if (Math.abs(this.height - height) &gt; Epsilon)</span><span class="s3">\n                </span><span class="s1">heightChangeFlag = true;</span><span class="s3">\n            </span><span class="s1">this.height = height;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Base case is to replace a leaf node, which simply builds a tree</span><span class="s3">\n    </span><span class="s1">// from the new nodes and returns that (HeightMapBranch and</span><span class="s3">\n    </span><span class="s1">// HeightMapGap override this to actually use from/to)</span><span class="s3">\n    </span><span class="s1">replace(_from, _to, nodes) {</span><span class="s3">\n        </span><span class="s1">return HeightMap.of(nodes);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Again, these are base cases, and are overridden for branch and gap nodes.</span><span class="s3">\n    </span><span class="s1">decomposeLeft(_to, result) { result.push(this); }</span><span class="s3">\n    </span><span class="s1">decomposeRight(_from, result) { result.push(this); }</span><span class="s3">\n    </span><span class="s1">applyChanges(decorations, oldDoc, oracle, changes) {</span><span class="s3">\n        </span><span class="s1">let me = this, doc = oracle.doc;</span><span class="s3">\n        </span><span class="s1">for (let i = changes.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n            </span><span class="s1">let { fromA, toA, fromB, toB } = changes[i];</span><span class="s3">\n            </span><span class="s1">let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);</span><span class="s3">\n            </span><span class="s1">let end = start.to &gt;= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);</span><span class="s3">\n            </span><span class="s1">toB += end.to - toA;</span><span class="s3">\n            </span><span class="s1">toA = end.to;</span><span class="s3">\n            </span><span class="s1">while (i &gt; 0 &amp;&amp; start.from &lt;= changes[i - 1].toA) {</span><span class="s3">\n                </span><span class="s1">fromA = changes[i - 1].fromA;</span><span class="s3">\n                </span><span class="s1">fromB = changes[i - 1].fromB;</span><span class="s3">\n                </span><span class="s1">i--;</span><span class="s3">\n                </span><span class="s1">if (fromA &lt; start.from)</span><span class="s3">\n                    </span><span class="s1">start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">fromB += start.from - fromA;</span><span class="s3">\n            </span><span class="s1">fromA = start.from;</span><span class="s3">\n            </span><span class="s1">let nodes = NodeBuilder.build(oracle.setDoc(doc), decorations, fromB, toB);</span><span class="s3">\n            </span><span class="s1">me = replace(me, me.replace(fromA, toA, nodes));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return me.updateHeight(oracle, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static empty() { return new HeightMapText(0, 0); }</span><span class="s3">\n    </span><span class="s1">// nodes uses null values to indicate the position of line breaks.</span><span class="s3">\n    </span><span class="s1">// There are never line breaks at the start or end of the array, or</span><span class="s3">\n    </span><span class="s1">// two line breaks next to each other, and the array isn't allowed</span><span class="s3">\n    </span><span class="s1">// to be empty (same restrictions as return value from the builder).</span><span class="s3">\n    </span><span class="s1">static of(nodes) {</span><span class="s3">\n        </span><span class="s1">if (nodes.length == 1)</span><span class="s3">\n            </span><span class="s1">return nodes[0];</span><span class="s3">\n        </span><span class="s1">let i = 0, j = nodes.length, before = 0, after = 0;</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">if (i == j) {</span><span class="s3">\n                </span><span class="s1">if (before &gt; after * 2) {</span><span class="s3">\n                    </span><span class="s1">let split = nodes[i - 1];</span><span class="s3">\n                    </span><span class="s1">if (split.break)</span><span class="s3">\n                        </span><span class="s1">nodes.splice(--i, 1, split.left, null, split.right);</span><span class="s3">\n                    </span><span class="s1">else</span><span class="s3">\n                        </span><span class="s1">nodes.splice(--i, 1, split.left, split.right);</span><span class="s3">\n                    </span><span class="s1">j += 1 + split.break;</span><span class="s3">\n                    </span><span class="s1">before -= split.size;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (after &gt; before * 2) {</span><span class="s3">\n                    </span><span class="s1">let split = nodes[j];</span><span class="s3">\n                    </span><span class="s1">if (split.break)</span><span class="s3">\n                        </span><span class="s1">nodes.splice(j, 1, split.left, null, split.right);</span><span class="s3">\n                    </span><span class="s1">else</span><span class="s3">\n                        </span><span class="s1">nodes.splice(j, 1, split.left, split.right);</span><span class="s3">\n                    </span><span class="s1">j += 2 + split.break;</span><span class="s3">\n                    </span><span class="s1">after -= split.size;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (before &lt; after) {</span><span class="s3">\n                </span><span class="s1">let next = nodes[i++];</span><span class="s3">\n                </span><span class="s1">if (next)</span><span class="s3">\n                    </span><span class="s1">before += next.size;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let next = nodes[--j];</span><span class="s3">\n                </span><span class="s1">if (next)</span><span class="s3">\n                    </span><span class="s1">after += next.size;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let brk = 0;</span><span class="s3">\n        </span><span class="s1">if (nodes[i - 1] == null) {</span><span class="s3">\n            </span><span class="s1">brk = 1;</span><span class="s3">\n            </span><span class="s1">i--;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (nodes[i] == null) {</span><span class="s3">\n            </span><span class="s1">brk = 1;</span><span class="s3">\n            </span><span class="s1">j++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function replace(old, val) {</span><span class="s3">\n    </span><span class="s1">if (old == val)</span><span class="s3">\n        </span><span class="s1">return old;</span><span class="s3">\n    </span><span class="s1">if (old.constructor != val.constructor)</span><span class="s3">\n        </span><span class="s1">heightChangeFlag = true;</span><span class="s3">\n    </span><span class="s1">return val;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">HeightMap.prototype.size = 1;</span><span class="s3">\n</span><span class="s1">class HeightMapBlock extends HeightMap {</span><span class="s3">\n    </span><span class="s1">constructor(length, height, deco) {</span><span class="s3">\n        </span><span class="s1">super(length, height);</span><span class="s3">\n        </span><span class="s1">this.deco = deco;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">blockAt(_height, _oracle, top, offset) {</span><span class="s3">\n        </span><span class="s1">return new BlockInfo(offset, this.length, top, this.height, this.deco || 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">lineAt(_value, _type, oracle, top, offset) {</span><span class="s3">\n        </span><span class="s1">return this.blockAt(0, oracle, top, offset);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">forEachLine(from, to, oracle, top, offset, f) {</span><span class="s3">\n        </span><span class="s1">if (from &lt;= offset + this.length &amp;&amp; to &gt;= offset)</span><span class="s3">\n            </span><span class="s1">f(this.blockAt(0, oracle, top, offset));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateHeight(oracle, offset = 0, _force = false, measured) {</span><span class="s3">\n        </span><span class="s1">if (measured &amp;&amp; measured.from &lt;= offset &amp;&amp; measured.more)</span><span class="s3">\n            </span><span class="s1">this.setHeight(measured.heights[measured.index++]);</span><span class="s3">\n        </span><span class="s1">this.outdated = false;</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() { return `block(${this.length})`; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class HeightMapText extends HeightMapBlock {</span><span class="s3">\n    </span><span class="s1">constructor(length, height) {</span><span class="s3">\n        </span><span class="s1">super(length, height, null);</span><span class="s3">\n        </span><span class="s1">this.collapsed = 0; // Amount of collapsed content in the line</span><span class="s3">\n        </span><span class="s1">this.widgetHeight = 0; // Maximum inline widget height</span><span class="s3">\n        </span><span class="s1">this.breaks = 0; // Number of widget-introduced line breaks on the line</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">blockAt(_height, _oracle, top, offset) {</span><span class="s3">\n        </span><span class="s1">return new BlockInfo(offset, this.length, top, this.height, this.breaks);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">replace(_from, _to, nodes) {</span><span class="s3">\n        </span><span class="s1">let node = nodes[0];</span><span class="s3">\n        </span><span class="s1">if (nodes.length == 1 &amp;&amp; (node instanceof HeightMapText || node instanceof HeightMapGap &amp;&amp; (node.flags &amp; 4 /* Flag.SingleLine */)) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">Math.abs(this.length - node.length) &lt; 10) {</span><span class="s3">\n            </span><span class="s1">if (node instanceof HeightMapGap)</span><span class="s3">\n                </span><span class="s1">node = new HeightMapText(node.length, this.height);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">node.height = this.height;</span><span class="s3">\n            </span><span class="s1">if (!this.outdated)</span><span class="s3">\n                </span><span class="s1">node.outdated = false;</span><span class="s3">\n            </span><span class="s1">return node;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return HeightMap.of(nodes);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateHeight(oracle, offset = 0, force = false, measured) {</span><span class="s3">\n        </span><span class="s1">if (measured &amp;&amp; measured.from &lt;= offset &amp;&amp; measured.more)</span><span class="s3">\n            </span><span class="s1">this.setHeight(measured.heights[measured.index++]);</span><span class="s3">\n        </span><span class="s1">else if (force || this.outdated)</span><span class="s3">\n            </span><span class="s1">this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) +</span><span class="s3">\n                </span><span class="s1">this.breaks * oracle.lineHeight);</span><span class="s3">\n        </span><span class="s1">this.outdated = false;</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">return `line(${this.length}${this.collapsed ? -this.collapsed : </span><span class="s3">\&quot;\&quot;</span><span class="s1">}${this.widgetHeight ? </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ this.widgetHeight : </span><span class="s3">\&quot;\&quot;</span><span class="s1">})`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class HeightMapGap extends HeightMap {</span><span class="s3">\n    </span><span class="s1">constructor(length) { super(length, 0); }</span><span class="s3">\n    </span><span class="s1">heightMetrics(oracle, offset) {</span><span class="s3">\n        </span><span class="s1">let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;</span><span class="s3">\n        </span><span class="s1">let lines = lastLine - firstLine + 1;</span><span class="s3">\n        </span><span class="s1">let perLine, perChar = 0;</span><span class="s3">\n        </span><span class="s1">if (oracle.lineWrapping) {</span><span class="s3">\n            </span><span class="s1">let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);</span><span class="s3">\n            </span><span class="s1">perLine = totalPerLine / lines;</span><span class="s3">\n            </span><span class="s1">if (this.length &gt; lines + 1)</span><span class="s3">\n                </span><span class="s1">perChar = (this.height - totalPerLine) / (this.length - lines - 1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">perLine = this.height / lines;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { firstLine, lastLine, perLine, perChar };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">blockAt(height, oracle, top, offset) {</span><span class="s3">\n        </span><span class="s1">let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);</span><span class="s3">\n        </span><span class="s1">if (oracle.lineWrapping) {</span><span class="s3">\n            </span><span class="s1">let guess = offset + (height &lt; oracle.lineHeight ? 0</span><span class="s3">\n                </span><span class="s1">: Math.round(Math.max(0, Math.min(1, (height - top) / this.height)) * this.length));</span><span class="s3">\n            </span><span class="s1">let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;</span><span class="s3">\n            </span><span class="s1">let lineTop = Math.max(top, height - lineHeight / 2);</span><span class="s3">\n            </span><span class="s1">return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / perLine)));</span><span class="s3">\n            </span><span class="s1">let { from, length } = oracle.doc.line(firstLine + line);</span><span class="s3">\n            </span><span class="s1">return new BlockInfo(from, length, top + perLine * line, perLine, 0);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">lineAt(value, type, oracle, top, offset) {</span><span class="s3">\n        </span><span class="s1">if (type == QueryType.ByHeight)</span><span class="s3">\n            </span><span class="s1">return this.blockAt(value, oracle, top, offset);</span><span class="s3">\n        </span><span class="s1">if (type == QueryType.ByPosNoHeight) {</span><span class="s3">\n            </span><span class="s1">let { from, to } = oracle.doc.lineAt(value);</span><span class="s3">\n            </span><span class="s1">return new BlockInfo(from, to - from, 0, 0, 0);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);</span><span class="s3">\n        </span><span class="s1">let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;</span><span class="s3">\n        </span><span class="s1">let linesAbove = line.number - firstLine;</span><span class="s3">\n        </span><span class="s1">let lineTop = top + perLine * linesAbove + perChar * (line.from - offset - linesAbove);</span><span class="s3">\n        </span><span class="s1">return new BlockInfo(line.from, line.length, Math.max(top, Math.min(lineTop, top + this.height - lineHeight)), lineHeight, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">forEachLine(from, to, oracle, top, offset, f) {</span><span class="s3">\n        </span><span class="s1">from = Math.max(from, offset);</span><span class="s3">\n        </span><span class="s1">to = Math.min(to, offset + this.length);</span><span class="s3">\n        </span><span class="s1">let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);</span><span class="s3">\n        </span><span class="s1">for (let pos = from, lineTop = top; pos &lt;= to;) {</span><span class="s3">\n            </span><span class="s1">let line = oracle.doc.lineAt(pos);</span><span class="s3">\n            </span><span class="s1">if (pos == from) {</span><span class="s3">\n                </span><span class="s1">let linesAbove = line.number - firstLine;</span><span class="s3">\n                </span><span class="s1">lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let lineHeight = perLine + perChar * line.length;</span><span class="s3">\n            </span><span class="s1">f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));</span><span class="s3">\n            </span><span class="s1">lineTop += lineHeight;</span><span class="s3">\n            </span><span class="s1">pos = line.to + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">replace(from, to, nodes) {</span><span class="s3">\n        </span><span class="s1">let after = this.length - to;</span><span class="s3">\n        </span><span class="s1">if (after &gt; 0) {</span><span class="s3">\n            </span><span class="s1">let last = nodes[nodes.length - 1];</span><span class="s3">\n            </span><span class="s1">if (last instanceof HeightMapGap)</span><span class="s3">\n                </span><span class="s1">nodes[nodes.length - 1] = new HeightMapGap(last.length + after);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">nodes.push(null, new HeightMapGap(after - 1));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (from &gt; 0) {</span><span class="s3">\n            </span><span class="s1">let first = nodes[0];</span><span class="s3">\n            </span><span class="s1">if (first instanceof HeightMapGap)</span><span class="s3">\n                </span><span class="s1">nodes[0] = new HeightMapGap(from + first.length);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">nodes.unshift(new HeightMapGap(from - 1), null);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return HeightMap.of(nodes);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">decomposeLeft(to, result) {</span><span class="s3">\n        </span><span class="s1">result.push(new HeightMapGap(to - 1), null);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">decomposeRight(from, result) {</span><span class="s3">\n        </span><span class="s1">result.push(null, new HeightMapGap(this.length - from - 1));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateHeight(oracle, offset = 0, force = false, measured) {</span><span class="s3">\n        </span><span class="s1">let end = offset + this.length;</span><span class="s3">\n        </span><span class="s1">if (measured &amp;&amp; measured.from &lt;= offset + this.length &amp;&amp; measured.more) {</span><span class="s3">\n            </span><span class="s1">// Fill in part of this gap with measured lines. We know there</span><span class="s3">\n            </span><span class="s1">// can't be widgets or collapsed ranges in those lines, because</span><span class="s3">\n            </span><span class="s1">// they would already have been added to the heightmap (gaps</span><span class="s3">\n            </span><span class="s1">// only contain plain text).</span><span class="s3">\n            </span><span class="s1">let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;</span><span class="s3">\n            </span><span class="s1">if (measured.from &gt; offset)</span><span class="s3">\n                </span><span class="s1">nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));</span><span class="s3">\n            </span><span class="s1">while (pos &lt;= end &amp;&amp; measured.more) {</span><span class="s3">\n                </span><span class="s1">let len = oracle.doc.lineAt(pos).length;</span><span class="s3">\n                </span><span class="s1">if (nodes.length)</span><span class="s3">\n                    </span><span class="s1">nodes.push(null);</span><span class="s3">\n                </span><span class="s1">let height = measured.heights[measured.index++];</span><span class="s3">\n                </span><span class="s1">if (singleHeight == -1)</span><span class="s3">\n                    </span><span class="s1">singleHeight = height;</span><span class="s3">\n                </span><span class="s1">else if (Math.abs(height - singleHeight) &gt;= Epsilon)</span><span class="s3">\n                    </span><span class="s1">singleHeight = -2;</span><span class="s3">\n                </span><span class="s1">let line = new HeightMapText(len, height);</span><span class="s3">\n                </span><span class="s1">line.outdated = false;</span><span class="s3">\n                </span><span class="s1">nodes.push(line);</span><span class="s3">\n                </span><span class="s1">pos += len + 1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (pos &lt;= end)</span><span class="s3">\n                </span><span class="s1">nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));</span><span class="s3">\n            </span><span class="s1">let result = HeightMap.of(nodes);</span><span class="s3">\n            </span><span class="s1">if (singleHeight &lt; 0 || Math.abs(result.height - this.height) &gt;= Epsilon ||</span><span class="s3">\n                </span><span class="s1">Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) &gt;= Epsilon)</span><span class="s3">\n                </span><span class="s1">heightChangeFlag = true;</span><span class="s3">\n            </span><span class="s1">return replace(this, result);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (force || this.outdated) {</span><span class="s3">\n            </span><span class="s1">this.setHeight(oracle.heightForGap(offset, offset + this.length));</span><span class="s3">\n            </span><span class="s1">this.outdated = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() { return `gap(${this.length})`; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class HeightMapBranch extends HeightMap {</span><span class="s3">\n    </span><span class="s1">constructor(left, brk, right) {</span><span class="s3">\n        </span><span class="s1">super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Flag.Outdated */ : 0));</span><span class="s3">\n        </span><span class="s1">this.left = left;</span><span class="s3">\n        </span><span class="s1">this.right = right;</span><span class="s3">\n        </span><span class="s1">this.size = left.size + right.size;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get break() { return this.flags &amp; 1 /* Flag.Break */; }</span><span class="s3">\n    </span><span class="s1">blockAt(height, oracle, top, offset) {</span><span class="s3">\n        </span><span class="s1">let mid = top + this.left.height;</span><span class="s3">\n        </span><span class="s1">return height &lt; mid ? this.left.blockAt(height, oracle, top, offset)</span><span class="s3">\n            </span><span class="s1">: this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">lineAt(value, type, oracle, top, offset) {</span><span class="s3">\n        </span><span class="s1">let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;</span><span class="s3">\n        </span><span class="s1">let left = type == QueryType.ByHeight ? value &lt; rightTop : value &lt; rightOffset;</span><span class="s3">\n        </span><span class="s1">let base = left ? this.left.lineAt(value, type, oracle, top, offset)</span><span class="s3">\n            </span><span class="s1">: this.right.lineAt(value, type, oracle, rightTop, rightOffset);</span><span class="s3">\n        </span><span class="s1">if (this.break || (left ? base.to &lt; rightOffset : base.from &gt; rightOffset))</span><span class="s3">\n            </span><span class="s1">return base;</span><span class="s3">\n        </span><span class="s1">let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;</span><span class="s3">\n        </span><span class="s1">if (left)</span><span class="s3">\n            </span><span class="s1">return base.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">return this.left.lineAt(rightOffset, subQuery, oracle, top, offset).join(base);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">forEachLine(from, to, oracle, top, offset, f) {</span><span class="s3">\n        </span><span class="s1">let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;</span><span class="s3">\n        </span><span class="s1">if (this.break) {</span><span class="s3">\n            </span><span class="s1">if (from &lt; rightOffset)</span><span class="s3">\n                </span><span class="s1">this.left.forEachLine(from, to, oracle, top, offset, f);</span><span class="s3">\n            </span><span class="s1">if (to &gt;= rightOffset)</span><span class="s3">\n                </span><span class="s1">this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top, offset);</span><span class="s3">\n            </span><span class="s1">if (from &lt; mid.from)</span><span class="s3">\n                </span><span class="s1">this.left.forEachLine(from, mid.from - 1, oracle, top, offset, f);</span><span class="s3">\n            </span><span class="s1">if (mid.to &gt;= from &amp;&amp; mid.from &lt;= to)</span><span class="s3">\n                </span><span class="s1">f(mid);</span><span class="s3">\n            </span><span class="s1">if (to &gt; mid.to)</span><span class="s3">\n                </span><span class="s1">this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">replace(from, to, nodes) {</span><span class="s3">\n        </span><span class="s1">let rightStart = this.left.length + this.break;</span><span class="s3">\n        </span><span class="s1">if (to &lt; rightStart)</span><span class="s3">\n            </span><span class="s1">return this.balanced(this.left.replace(from, to, nodes), this.right);</span><span class="s3">\n        </span><span class="s1">if (from &gt; this.left.length)</span><span class="s3">\n            </span><span class="s1">return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));</span><span class="s3">\n        </span><span class="s1">let result = [];</span><span class="s3">\n        </span><span class="s1">if (from &gt; 0)</span><span class="s3">\n            </span><span class="s1">this.decomposeLeft(from, result);</span><span class="s3">\n        </span><span class="s1">let left = result.length;</span><span class="s3">\n        </span><span class="s1">for (let node of nodes)</span><span class="s3">\n            </span><span class="s1">result.push(node);</span><span class="s3">\n        </span><span class="s1">if (from &gt; 0)</span><span class="s3">\n            </span><span class="s1">mergeGaps(result, left - 1);</span><span class="s3">\n        </span><span class="s1">if (to &lt; this.length) {</span><span class="s3">\n            </span><span class="s1">let right = result.length;</span><span class="s3">\n            </span><span class="s1">this.decomposeRight(to, result);</span><span class="s3">\n            </span><span class="s1">mergeGaps(result, right);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return HeightMap.of(result);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">decomposeLeft(to, result) {</span><span class="s3">\n        </span><span class="s1">let left = this.left.length;</span><span class="s3">\n        </span><span class="s1">if (to &lt;= left)</span><span class="s3">\n            </span><span class="s1">return this.left.decomposeLeft(to, result);</span><span class="s3">\n        </span><span class="s1">result.push(this.left);</span><span class="s3">\n        </span><span class="s1">if (this.break) {</span><span class="s3">\n            </span><span class="s1">left++;</span><span class="s3">\n            </span><span class="s1">if (to &gt;= left)</span><span class="s3">\n                </span><span class="s1">result.push(null);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (to &gt; left)</span><span class="s3">\n            </span><span class="s1">this.right.decomposeLeft(to - left, result);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">decomposeRight(from, result) {</span><span class="s3">\n        </span><span class="s1">let left = this.left.length, right = left + this.break;</span><span class="s3">\n        </span><span class="s1">if (from &gt;= right)</span><span class="s3">\n            </span><span class="s1">return this.right.decomposeRight(from - right, result);</span><span class="s3">\n        </span><span class="s1">if (from &lt; left)</span><span class="s3">\n            </span><span class="s1">this.left.decomposeRight(from, result);</span><span class="s3">\n        </span><span class="s1">if (this.break &amp;&amp; from &lt; right)</span><span class="s3">\n            </span><span class="s1">result.push(null);</span><span class="s3">\n        </span><span class="s1">result.push(this.right);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">balanced(left, right) {</span><span class="s3">\n        </span><span class="s1">if (left.size &gt; 2 * right.size || right.size &gt; 2 * left.size)</span><span class="s3">\n            </span><span class="s1">return HeightMap.of(this.break ? [left, null, right] : [left, right]);</span><span class="s3">\n        </span><span class="s1">this.left = replace(this.left, left);</span><span class="s3">\n        </span><span class="s1">this.right = replace(this.right, right);</span><span class="s3">\n        </span><span class="s1">this.setHeight(left.height + right.height);</span><span class="s3">\n        </span><span class="s1">this.outdated = left.outdated || right.outdated;</span><span class="s3">\n        </span><span class="s1">this.size = left.size + right.size;</span><span class="s3">\n        </span><span class="s1">this.length = left.length + this.break + right.length;</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateHeight(oracle, offset = 0, force = false, measured) {</span><span class="s3">\n        </span><span class="s1">let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;</span><span class="s3">\n        </span><span class="s1">if (measured &amp;&amp; measured.from &lt;= offset + left.length &amp;&amp; measured.more)</span><span class="s3">\n            </span><span class="s1">rebalance = left = left.updateHeight(oracle, offset, force, measured);</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">left.updateHeight(oracle, offset, force);</span><span class="s3">\n        </span><span class="s1">if (measured &amp;&amp; measured.from &lt;= rightStart + right.length &amp;&amp; measured.more)</span><span class="s3">\n            </span><span class="s1">rebalance = right = right.updateHeight(oracle, rightStart, force, measured);</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">right.updateHeight(oracle, rightStart, force);</span><span class="s3">\n        </span><span class="s1">if (rebalance)</span><span class="s3">\n            </span><span class="s1">return this.balanced(left, right);</span><span class="s3">\n        </span><span class="s1">this.height = this.left.height + this.right.height;</span><span class="s3">\n        </span><span class="s1">this.outdated = false;</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() { return this.left + (this.break ? </span><span class="s3">\&quot; \&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">) + this.right; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function mergeGaps(nodes, around) {</span><span class="s3">\n    </span><span class="s1">let before, after;</span><span class="s3">\n    </span><span class="s1">if (nodes[around] == null &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(before = nodes[around - 1]) instanceof HeightMapGap &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(after = nodes[around + 1]) instanceof HeightMapGap)</span><span class="s3">\n        </span><span class="s1">nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const relevantWidgetHeight = 5;</span><span class="s3">\n</span><span class="s1">class NodeBuilder {</span><span class="s3">\n    </span><span class="s1">constructor(pos, oracle) {</span><span class="s3">\n        </span><span class="s1">this.pos = pos;</span><span class="s3">\n        </span><span class="s1">this.oracle = oracle;</span><span class="s3">\n        </span><span class="s1">this.nodes = [];</span><span class="s3">\n        </span><span class="s1">this.lineStart = -1;</span><span class="s3">\n        </span><span class="s1">this.lineEnd = -1;</span><span class="s3">\n        </span><span class="s1">this.covering = null;</span><span class="s3">\n        </span><span class="s1">this.writtenTo = pos;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get isCovered() {</span><span class="s3">\n        </span><span class="s1">return this.covering &amp;&amp; this.nodes[this.nodes.length - 1] == this.covering;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">span(_from, to) {</span><span class="s3">\n        </span><span class="s1">if (this.lineStart &gt; -1) {</span><span class="s3">\n            </span><span class="s1">let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];</span><span class="s3">\n            </span><span class="s1">if (last instanceof HeightMapText)</span><span class="s3">\n                </span><span class="s1">last.length += end - this.pos;</span><span class="s3">\n            </span><span class="s1">else if (end &gt; this.pos || !this.isCovered)</span><span class="s3">\n                </span><span class="s1">this.nodes.push(new HeightMapText(end - this.pos, -1));</span><span class="s3">\n            </span><span class="s1">this.writtenTo = end;</span><span class="s3">\n            </span><span class="s1">if (to &gt; end) {</span><span class="s3">\n                </span><span class="s1">this.nodes.push(null);</span><span class="s3">\n                </span><span class="s1">this.writtenTo++;</span><span class="s3">\n                </span><span class="s1">this.lineStart = -1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.pos = to;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">point(from, to, deco) {</span><span class="s3">\n        </span><span class="s1">if (from &lt; to || deco.heightRelevant) {</span><span class="s3">\n            </span><span class="s1">let height = deco.widget ? deco.widget.estimatedHeight : 0;</span><span class="s3">\n            </span><span class="s1">let breaks = deco.widget ? deco.widget.lineBreaks : 0;</span><span class="s3">\n            </span><span class="s1">if (height &lt; 0)</span><span class="s3">\n                </span><span class="s1">height = this.oracle.lineHeight;</span><span class="s3">\n            </span><span class="s1">let len = to - from;</span><span class="s3">\n            </span><span class="s1">if (deco.block) {</span><span class="s3">\n                </span><span class="s1">this.addBlock(new HeightMapBlock(len, height, deco));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (len || breaks || height &gt;= relevantWidgetHeight) {</span><span class="s3">\n                </span><span class="s1">this.addLineDeco(height, breaks, len);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (to &gt; from) {</span><span class="s3">\n            </span><span class="s1">this.span(from, to);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.lineEnd &gt; -1 &amp;&amp; this.lineEnd &lt; this.pos)</span><span class="s3">\n            </span><span class="s1">this.lineEnd = this.oracle.doc.lineAt(this.pos).to;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">enterLine() {</span><span class="s3">\n        </span><span class="s1">if (this.lineStart &gt; -1)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">let { from, to } = this.oracle.doc.lineAt(this.pos);</span><span class="s3">\n        </span><span class="s1">this.lineStart = from;</span><span class="s3">\n        </span><span class="s1">this.lineEnd = to;</span><span class="s3">\n        </span><span class="s1">if (this.writtenTo &lt; from) {</span><span class="s3">\n            </span><span class="s1">if (this.writtenTo &lt; from - 1 || this.nodes[this.nodes.length - 1] == null)</span><span class="s3">\n                </span><span class="s1">this.nodes.push(this.blankContent(this.writtenTo, from - 1));</span><span class="s3">\n            </span><span class="s1">this.nodes.push(null);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.pos &gt; from)</span><span class="s3">\n            </span><span class="s1">this.nodes.push(new HeightMapText(this.pos - from, -1));</span><span class="s3">\n        </span><span class="s1">this.writtenTo = this.pos;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">blankContent(from, to) {</span><span class="s3">\n        </span><span class="s1">let gap = new HeightMapGap(to - from);</span><span class="s3">\n        </span><span class="s1">if (this.oracle.doc.lineAt(from).to == to)</span><span class="s3">\n            </span><span class="s1">gap.flags |= 4 /* Flag.SingleLine */;</span><span class="s3">\n        </span><span class="s1">return gap;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ensureLine() {</span><span class="s3">\n        </span><span class="s1">this.enterLine();</span><span class="s3">\n        </span><span class="s1">let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;</span><span class="s3">\n        </span><span class="s1">if (last instanceof HeightMapText)</span><span class="s3">\n            </span><span class="s1">return last;</span><span class="s3">\n        </span><span class="s1">let line = new HeightMapText(0, -1);</span><span class="s3">\n        </span><span class="s1">this.nodes.push(line);</span><span class="s3">\n        </span><span class="s1">return line;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addBlock(block) {</span><span class="s3">\n        </span><span class="s1">this.enterLine();</span><span class="s3">\n        </span><span class="s1">let deco = block.deco;</span><span class="s3">\n        </span><span class="s1">if (deco &amp;&amp; deco.startSide &gt; 0 &amp;&amp; !this.isCovered)</span><span class="s3">\n            </span><span class="s1">this.ensureLine();</span><span class="s3">\n        </span><span class="s1">this.nodes.push(block);</span><span class="s3">\n        </span><span class="s1">this.writtenTo = this.pos = this.pos + block.length;</span><span class="s3">\n        </span><span class="s1">if (deco &amp;&amp; deco.endSide &gt; 0)</span><span class="s3">\n            </span><span class="s1">this.covering = block;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addLineDeco(height, breaks, length) {</span><span class="s3">\n        </span><span class="s1">let line = this.ensureLine();</span><span class="s3">\n        </span><span class="s1">line.length += length;</span><span class="s3">\n        </span><span class="s1">line.collapsed += length;</span><span class="s3">\n        </span><span class="s1">line.widgetHeight = Math.max(line.widgetHeight, height);</span><span class="s3">\n        </span><span class="s1">line.breaks += breaks;</span><span class="s3">\n        </span><span class="s1">this.writtenTo = this.pos = this.pos + length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">finish(from) {</span><span class="s3">\n        </span><span class="s1">let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];</span><span class="s3">\n        </span><span class="s1">if (this.lineStart &gt; -1 &amp;&amp; !(last instanceof HeightMapText) &amp;&amp; !this.isCovered)</span><span class="s3">\n            </span><span class="s1">this.nodes.push(new HeightMapText(0, -1));</span><span class="s3">\n        </span><span class="s1">else if (this.writtenTo &lt; this.pos || last == null)</span><span class="s3">\n            </span><span class="s1">this.nodes.push(this.blankContent(this.writtenTo, this.pos));</span><span class="s3">\n        </span><span class="s1">let pos = from;</span><span class="s3">\n        </span><span class="s1">for (let node of this.nodes) {</span><span class="s3">\n            </span><span class="s1">if (node instanceof HeightMapText)</span><span class="s3">\n                </span><span class="s1">node.updateHeight(this.oracle, pos);</span><span class="s3">\n            </span><span class="s1">pos += node ? node.length : 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.nodes;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Always called with a region that on both sides either stretches</span><span class="s3">\n    </span><span class="s1">// to a line break or the end of the document.</span><span class="s3">\n    </span><span class="s1">// The returned array uses null to indicate line breaks, but never</span><span class="s3">\n    </span><span class="s1">// starts or ends in a line break, or has multiple line breaks next</span><span class="s3">\n    </span><span class="s1">// to each other.</span><span class="s3">\n    </span><span class="s1">static build(oracle, decorations, from, to) {</span><span class="s3">\n        </span><span class="s1">let builder = new NodeBuilder(from, oracle);</span><span class="s3">\n        </span><span class="s1">RangeSet.spans(decorations, from, to, builder, 0);</span><span class="s3">\n        </span><span class="s1">return builder.finish(from);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function heightRelevantDecoChanges(a, b, diff) {</span><span class="s3">\n    </span><span class="s1">let comp = new DecorationComparator;</span><span class="s3">\n    </span><span class="s1">RangeSet.compare(a, b, diff, comp, 0);</span><span class="s3">\n    </span><span class="s1">return comp.changes;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class DecorationComparator {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.changes = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">compareRange() { }</span><span class="s3">\n    </span><span class="s1">comparePoint(from, to, a, b) {</span><span class="s3">\n        </span><span class="s1">if (from &lt; to || a &amp;&amp; a.heightRelevant || b &amp;&amp; b.heightRelevant)</span><span class="s3">\n            </span><span class="s1">addRange(from, to, this.changes, 5);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function visiblePixelRange(dom, paddingTop) {</span><span class="s3">\n    </span><span class="s1">let rect = dom.getBoundingClientRect();</span><span class="s3">\n    </span><span class="s1">let doc = dom.ownerDocument, win = doc.defaultView || window;</span><span class="s3">\n    </span><span class="s1">let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);</span><span class="s3">\n    </span><span class="s1">let top = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);</span><span class="s3">\n    </span><span class="s1">for (let parent = dom.parentNode; parent &amp;&amp; parent != doc.body;) {</span><span class="s3">\n        </span><span class="s1">if (parent.nodeType == 1) {</span><span class="s3">\n            </span><span class="s1">let elt = parent;</span><span class="s3">\n            </span><span class="s1">let style = window.getComputedStyle(elt);</span><span class="s3">\n            </span><span class="s1">if ((elt.scrollHeight &gt; elt.clientHeight || elt.scrollWidth &gt; elt.clientWidth) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">style.overflow != </span><span class="s3">\&quot;</span><span class="s1">visible</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">let parentRect = elt.getBoundingClientRect();</span><span class="s3">\n                </span><span class="s1">left = Math.max(left, parentRect.left);</span><span class="s3">\n                </span><span class="s1">right = Math.min(right, parentRect.right);</span><span class="s3">\n                </span><span class="s1">top = Math.max(top, parentRect.top);</span><span class="s3">\n                </span><span class="s1">bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">parent = style.position == </span><span class="s3">\&quot;</span><span class="s1">absolute</span><span class="s3">\&quot; </span><span class="s1">|| style.position == </span><span class="s3">\&quot;</span><span class="s1">fixed</span><span class="s3">\&quot; </span><span class="s1">? elt.offsetParent : elt.parentNode;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (parent.nodeType == 11) { // Shadow root</span><span class="s3">\n            </span><span class="s1">parent = parent.host;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return { left: left - rect.left, right: Math.max(left, right) - rect.left,</span><span class="s3">\n        </span><span class="s1">top: top - (rect.top + paddingTop), bottom: Math.max(top, bottom) - (rect.top + paddingTop) };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function fullPixelRange(dom, paddingTop) {</span><span class="s3">\n    </span><span class="s1">let rect = dom.getBoundingClientRect();</span><span class="s3">\n    </span><span class="s1">return { left: 0, right: rect.right - rect.left,</span><span class="s3">\n        </span><span class="s1">top: paddingTop, bottom: rect.bottom - (rect.top + paddingTop) };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Line gaps are placeholder widgets used to hide pieces of overlong</span><span class="s3">\n</span><span class="s1">// lines within the viewport, as a kludge to keep the editor</span><span class="s3">\n</span><span class="s1">// responsive when a ridiculously long line is loaded into it.</span><span class="s3">\n</span><span class="s1">class LineGap {</span><span class="s3">\n    </span><span class="s1">constructor(from, to, size, displaySize) {</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n        </span><span class="s1">this.size = size;</span><span class="s3">\n        </span><span class="s1">this.displaySize = displaySize;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static same(a, b) {</span><span class="s3">\n        </span><span class="s1">if (a.length != b.length)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; a.length; i++) {</span><span class="s3">\n            </span><span class="s1">let gA = a[i], gB = b[i];</span><span class="s3">\n            </span><span class="s1">if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">draw(viewState, wrapping) {</span><span class="s3">\n        </span><span class="s1">return Decoration.replace({</span><span class="s3">\n            </span><span class="s1">widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)</span><span class="s3">\n        </span><span class="s1">}).range(this.from, this.to);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class LineGapWidget extends WidgetType {</span><span class="s3">\n    </span><span class="s1">constructor(size, vertical) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.size = size;</span><span class="s3">\n        </span><span class="s1">this.vertical = vertical;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(other) { return other.size == this.size &amp;&amp; other.vertical == this.vertical; }</span><span class="s3">\n    </span><span class="s1">toDOM() {</span><span class="s3">\n        </span><span class="s1">let elt = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (this.vertical) {</span><span class="s3">\n            </span><span class="s1">elt.style.height = this.size + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">elt.style.width = this.size + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">elt.style.height = </span><span class="s3">\&quot;</span><span class="s1">2px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">elt.style.display = </span><span class="s3">\&quot;</span><span class="s1">inline-block</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return elt;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get estimatedHeight() { return this.vertical ? this.size : -1; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class ViewState {</span><span class="s3">\n    </span><span class="s1">constructor(state) {</span><span class="s3">\n        </span><span class="s1">this.state = state;</span><span class="s3">\n        </span><span class="s1">// These are contentDOM-local coordinates</span><span class="s3">\n        </span><span class="s1">this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };</span><span class="s3">\n        </span><span class="s1">this.inView = true;</span><span class="s3">\n        </span><span class="s1">this.paddingTop = 0; // Padding above the document, scaled</span><span class="s3">\n        </span><span class="s1">this.paddingBottom = 0; // Padding below the document, scaled</span><span class="s3">\n        </span><span class="s1">this.contentDOMWidth = 0; // contentDOM.getBoundingClientRect().width</span><span class="s3">\n        </span><span class="s1">this.contentDOMHeight = 0; // contentDOM.getBoundingClientRect().height</span><span class="s3">\n        </span><span class="s1">this.editorHeight = 0; // scrollDOM.clientHeight, unscaled</span><span class="s3">\n        </span><span class="s1">this.editorWidth = 0; // scrollDOM.clientWidth, unscaled</span><span class="s3">\n        </span><span class="s1">this.scrollTop = 0; // Last seen scrollDOM.scrollTop, scaled</span><span class="s3">\n        </span><span class="s1">this.scrolledToBottom = false;</span><span class="s3">\n        </span><span class="s1">// The CSS-transformation scale of the editor (transformed size /</span><span class="s3">\n        </span><span class="s1">// concrete size)</span><span class="s3">\n        </span><span class="s1">this.scaleX = 1;</span><span class="s3">\n        </span><span class="s1">this.scaleY = 1;</span><span class="s3">\n        </span><span class="s1">// The vertical position (document-relative) to which to anchor the</span><span class="s3">\n        </span><span class="s1">// scroll position. -1 means anchor to the end of the document.</span><span class="s3">\n        </span><span class="s1">this.scrollAnchorPos = 0;</span><span class="s3">\n        </span><span class="s1">// The height at the anchor position. Set by the DOM update phase.</span><span class="s3">\n        </span><span class="s1">// -1 means no height available.</span><span class="s3">\n        </span><span class="s1">this.scrollAnchorHeight = -1;</span><span class="s3">\n        </span><span class="s1">// See VP.MaxDOMHeight</span><span class="s3">\n        </span><span class="s1">this.scaler = IdScaler;</span><span class="s3">\n        </span><span class="s1">this.scrollTarget = null;</span><span class="s3">\n        </span><span class="s1">// Briefly set to true when printing, to disable viewport limiting</span><span class="s3">\n        </span><span class="s1">this.printing = false;</span><span class="s3">\n        </span><span class="s1">// Flag set when editor content was redrawn, so that the next</span><span class="s3">\n        </span><span class="s1">// measure stage knows it must read DOM layout</span><span class="s3">\n        </span><span class="s1">this.mustMeasureContent = true;</span><span class="s3">\n        </span><span class="s1">this.defaultTextDirection = Direction.LTR;</span><span class="s3">\n        </span><span class="s1">this.visibleRanges = [];</span><span class="s3">\n        </span><span class="s1">// Cursor 'assoc' is only significant when the cursor is on a line</span><span class="s3">\n        </span><span class="s1">// wrap point, where it must stick to the character that it is</span><span class="s3">\n        </span><span class="s1">// associated with. Since browsers don't provide a reasonable</span><span class="s3">\n        </span><span class="s1">// interface to set or query this, when a selection is set that</span><span class="s3">\n        </span><span class="s1">// might cause this to be significant, this flag is set. The next</span><span class="s3">\n        </span><span class="s1">// measure phase will check whether the cursor is on a line-wrapping</span><span class="s3">\n        </span><span class="s1">// boundary and, if so, reset it to make sure it is positioned in</span><span class="s3">\n        </span><span class="s1">// the right place.</span><span class="s3">\n        </span><span class="s1">this.mustEnforceCursorAssoc = false;</span><span class="s3">\n        </span><span class="s1">let guessWrapping = state.facet(contentAttributes).some(v =&gt; typeof v != </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; v.class == </span><span class="s3">\&quot;</span><span class="s1">cm-lineWrapping</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.heightOracle = new HeightOracle(guessWrapping);</span><span class="s3">\n        </span><span class="s1">this.stateDeco = state.facet(decorations).filter(d =&gt; typeof d != </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; 2; i++) {</span><span class="s3">\n            </span><span class="s1">this.viewport = this.getViewport(0, null);</span><span class="s3">\n            </span><span class="s1">if (!this.updateForViewport())</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.updateViewportLines();</span><span class="s3">\n        </span><span class="s1">this.lineGaps = this.ensureLineGaps([]);</span><span class="s3">\n        </span><span class="s1">this.lineGapDeco = Decoration.set(this.lineGaps.map(gap =&gt; gap.draw(this, false)));</span><span class="s3">\n        </span><span class="s1">this.computeVisibleRanges();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateForViewport() {</span><span class="s3">\n        </span><span class="s1">let viewports = [this.viewport], { main } = this.state.selection;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt;= 1; i++) {</span><span class="s3">\n            </span><span class="s1">let pos = i ? main.head : main.anchor;</span><span class="s3">\n            </span><span class="s1">if (!viewports.some(({ from, to }) =&gt; pos &gt;= from &amp;&amp; pos &lt;= to)) {</span><span class="s3">\n                </span><span class="s1">let { from, to } = this.lineBlockAt(pos);</span><span class="s3">\n                </span><span class="s1">viewports.push(new Viewport(from, to));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.viewports = viewports.sort((a, b) =&gt; a.from - b.from);</span><span class="s3">\n        </span><span class="s1">return this.updateScaler();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateScaler() {</span><span class="s3">\n        </span><span class="s1">let scaler = this.scaler;</span><span class="s3">\n        </span><span class="s1">this.scaler = this.heightMap.height &lt;= 7000000 /* VP.MaxDOMHeight */ ? IdScaler :</span><span class="s3">\n            </span><span class="s1">new BigScaler(this.heightOracle, this.heightMap, this.viewports);</span><span class="s3">\n        </span><span class="s1">return scaler.eq(this.scaler) ? 0 : 2 /* UpdateFlag.Height */;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateViewportLines() {</span><span class="s3">\n        </span><span class="s1">this.viewportLines = [];</span><span class="s3">\n        </span><span class="s1">this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, block =&gt; {</span><span class="s3">\n            </span><span class="s1">this.viewportLines.push(scaleBlock(block, this.scaler));</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update, scrollTarget = null) {</span><span class="s3">\n        </span><span class="s1">this.state = update.state;</span><span class="s3">\n        </span><span class="s1">let prevDeco = this.stateDeco;</span><span class="s3">\n        </span><span class="s1">this.stateDeco = this.state.facet(decorations).filter(d =&gt; typeof d != </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">let contentChanges = update.changedRanges;</span><span class="s3">\n        </span><span class="s1">let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));</span><span class="s3">\n        </span><span class="s1">let prevHeight = this.heightMap.height;</span><span class="s3">\n        </span><span class="s1">let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);</span><span class="s3">\n        </span><span class="s1">clearHeightChangeFlag();</span><span class="s3">\n        </span><span class="s1">this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);</span><span class="s3">\n        </span><span class="s1">if (this.heightMap.height != prevHeight || heightChangeFlag)</span><span class="s3">\n            </span><span class="s1">update.flags |= 2 /* UpdateFlag.Height */;</span><span class="s3">\n        </span><span class="s1">if (scrollAnchor) {</span><span class="s3">\n            </span><span class="s1">this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);</span><span class="s3">\n            </span><span class="s1">this.scrollAnchorHeight = scrollAnchor.top;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.scrollAnchorPos = -1;</span><span class="s3">\n            </span><span class="s1">this.scrollAnchorHeight = this.heightMap.height;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;</span><span class="s3">\n        </span><span class="s1">if (scrollTarget &amp;&amp; (scrollTarget.range.head &lt; viewport.from || scrollTarget.range.head &gt; viewport.to) ||</span><span class="s3">\n            </span><span class="s1">!this.viewportIsAppropriate(viewport))</span><span class="s3">\n            </span><span class="s1">viewport = this.getViewport(0, scrollTarget);</span><span class="s3">\n        </span><span class="s1">let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;</span><span class="s3">\n        </span><span class="s1">this.viewport = viewport;</span><span class="s3">\n        </span><span class="s1">update.flags |= this.updateForViewport();</span><span class="s3">\n        </span><span class="s1">if (viewportChange || !update.changes.empty || (update.flags &amp; 2 /* UpdateFlag.Height */))</span><span class="s3">\n            </span><span class="s1">this.updateViewportLines();</span><span class="s3">\n        </span><span class="s1">if (this.lineGaps.length || this.viewport.to - this.viewport.from &gt; (2000 /* LG.Margin */ &lt;&lt; 1))</span><span class="s3">\n            </span><span class="s1">this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));</span><span class="s3">\n        </span><span class="s1">update.flags |= this.computeVisibleRanges(update.changes);</span><span class="s3">\n        </span><span class="s1">if (scrollTarget)</span><span class="s3">\n            </span><span class="s1">this.scrollTarget = scrollTarget;</span><span class="s3">\n        </span><span class="s1">if (!this.mustEnforceCursorAssoc &amp;&amp; update.selectionSet &amp;&amp; update.view.lineWrapping &amp;&amp;</span><span class="s3">\n            </span><span class="s1">update.state.selection.main.empty &amp;&amp; update.state.selection.main.assoc &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!update.state.facet(nativeSelectionHidden))</span><span class="s3">\n            </span><span class="s1">this.mustEnforceCursorAssoc = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">measure(view) {</span><span class="s3">\n        </span><span class="s1">let dom = view.contentDOM, style = window.getComputedStyle(dom);</span><span class="s3">\n        </span><span class="s1">let oracle = this.heightOracle;</span><span class="s3">\n        </span><span class="s1">let whiteSpace = style.whiteSpace;</span><span class="s3">\n        </span><span class="s1">this.defaultTextDirection = style.direction == </span><span class="s3">\&quot;</span><span class="s1">rtl</span><span class="s3">\&quot; </span><span class="s1">? Direction.RTL : Direction.LTR;</span><span class="s3">\n        </span><span class="s1">let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);</span><span class="s3">\n        </span><span class="s1">let domRect = dom.getBoundingClientRect();</span><span class="s3">\n        </span><span class="s1">let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;</span><span class="s3">\n        </span><span class="s1">this.contentDOMHeight = domRect.height;</span><span class="s3">\n        </span><span class="s1">this.mustMeasureContent = false;</span><span class="s3">\n        </span><span class="s1">let result = 0, bias = 0;</span><span class="s3">\n        </span><span class="s1">if (domRect.width &amp;&amp; domRect.height) {</span><span class="s3">\n            </span><span class="s1">let { scaleX, scaleY } = getScale(dom, domRect);</span><span class="s3">\n            </span><span class="s1">if (scaleX &gt; .005 &amp;&amp; Math.abs(this.scaleX - scaleX) &gt; .005 ||</span><span class="s3">\n                </span><span class="s1">scaleY &gt; .005 &amp;&amp; Math.abs(this.scaleY - scaleY) &gt; .005) {</span><span class="s3">\n                </span><span class="s1">this.scaleX = scaleX;</span><span class="s3">\n                </span><span class="s1">this.scaleY = scaleY;</span><span class="s3">\n                </span><span class="s1">result |= 16 /* UpdateFlag.Geometry */;</span><span class="s3">\n                </span><span class="s1">refresh = measureContent = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Vertical padding</span><span class="s3">\n        </span><span class="s1">let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;</span><span class="s3">\n        </span><span class="s1">let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;</span><span class="s3">\n        </span><span class="s1">if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {</span><span class="s3">\n            </span><span class="s1">this.paddingTop = paddingTop;</span><span class="s3">\n            </span><span class="s1">this.paddingBottom = paddingBottom;</span><span class="s3">\n            </span><span class="s1">result |= 16 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.editorWidth != view.scrollDOM.clientWidth) {</span><span class="s3">\n            </span><span class="s1">if (oracle.lineWrapping)</span><span class="s3">\n                </span><span class="s1">measureContent = true;</span><span class="s3">\n            </span><span class="s1">this.editorWidth = view.scrollDOM.clientWidth;</span><span class="s3">\n            </span><span class="s1">result |= 16 /* UpdateFlag.Geometry */;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let scrollTop = view.scrollDOM.scrollTop * this.scaleY;</span><span class="s3">\n        </span><span class="s1">if (this.scrollTop != scrollTop) {</span><span class="s3">\n            </span><span class="s1">this.scrollAnchorHeight = -1;</span><span class="s3">\n            </span><span class="s1">this.scrollTop = scrollTop;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);</span><span class="s3">\n        </span><span class="s1">// Pixel viewport</span><span class="s3">\n        </span><span class="s1">let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);</span><span class="s3">\n        </span><span class="s1">let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;</span><span class="s3">\n        </span><span class="s1">this.pixelViewport = pixelViewport;</span><span class="s3">\n        </span><span class="s1">let inView = this.pixelViewport.bottom &gt; this.pixelViewport.top &amp;&amp; this.pixelViewport.right &gt; this.pixelViewport.left;</span><span class="s3">\n        </span><span class="s1">if (inView != this.inView) {</span><span class="s3">\n            </span><span class="s1">this.inView = inView;</span><span class="s3">\n            </span><span class="s1">if (inView)</span><span class="s3">\n                </span><span class="s1">measureContent = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!this.inView &amp;&amp; !this.scrollTarget)</span><span class="s3">\n            </span><span class="s1">return 0;</span><span class="s3">\n        </span><span class="s1">let contentWidth = domRect.width;</span><span class="s3">\n        </span><span class="s1">if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {</span><span class="s3">\n            </span><span class="s1">this.contentDOMWidth = domRect.width;</span><span class="s3">\n            </span><span class="s1">this.editorHeight = view.scrollDOM.clientHeight;</span><span class="s3">\n            </span><span class="s1">result |= 16 /* UpdateFlag.Geometry */;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (measureContent) {</span><span class="s3">\n            </span><span class="s1">let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);</span><span class="s3">\n            </span><span class="s1">if (oracle.mustRefreshForHeights(lineHeights))</span><span class="s3">\n                </span><span class="s1">refresh = true;</span><span class="s3">\n            </span><span class="s1">if (refresh || oracle.lineWrapping &amp;&amp; Math.abs(contentWidth - this.contentDOMWidth) &gt; oracle.charWidth) {</span><span class="s3">\n                </span><span class="s1">let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();</span><span class="s3">\n                </span><span class="s1">refresh = lineHeight &gt; 0 &amp;&amp; oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);</span><span class="s3">\n                </span><span class="s1">if (refresh) {</span><span class="s3">\n                    </span><span class="s1">view.docView.minWidth = 0;</span><span class="s3">\n                    </span><span class="s1">result |= 16 /* UpdateFlag.Geometry */;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (dTop &gt; 0 &amp;&amp; dBottom &gt; 0)</span><span class="s3">\n                </span><span class="s1">bias = Math.max(dTop, dBottom);</span><span class="s3">\n            </span><span class="s1">else if (dTop &lt; 0 &amp;&amp; dBottom &lt; 0)</span><span class="s3">\n                </span><span class="s1">bias = Math.min(dTop, dBottom);</span><span class="s3">\n            </span><span class="s1">clearHeightChangeFlag();</span><span class="s3">\n            </span><span class="s1">for (let vp of this.viewports) {</span><span class="s3">\n                </span><span class="s1">let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);</span><span class="s3">\n                </span><span class="s1">this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (heightChangeFlag)</span><span class="s3">\n                </span><span class="s1">result |= 2 /* UpdateFlag.Height */;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) ||</span><span class="s3">\n            </span><span class="s1">this.scrollTarget &amp;&amp; (this.scrollTarget.range.head &lt; this.viewport.from ||</span><span class="s3">\n                </span><span class="s1">this.scrollTarget.range.head &gt; this.viewport.to);</span><span class="s3">\n        </span><span class="s1">if (viewportChange) {</span><span class="s3">\n            </span><span class="s1">if (result &amp; 2 /* UpdateFlag.Height */)</span><span class="s3">\n                </span><span class="s1">result |= this.updateScaler();</span><span class="s3">\n            </span><span class="s1">this.viewport = this.getViewport(bias, this.scrollTarget);</span><span class="s3">\n            </span><span class="s1">result |= this.updateForViewport();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if ((result &amp; 2 /* UpdateFlag.Height */) || viewportChange)</span><span class="s3">\n            </span><span class="s1">this.updateViewportLines();</span><span class="s3">\n        </span><span class="s1">if (this.lineGaps.length || this.viewport.to - this.viewport.from &gt; (2000 /* LG.Margin */ &lt;&lt; 1))</span><span class="s3">\n            </span><span class="s1">this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));</span><span class="s3">\n        </span><span class="s1">result |= this.computeVisibleRanges();</span><span class="s3">\n        </span><span class="s1">if (this.mustEnforceCursorAssoc) {</span><span class="s3">\n            </span><span class="s1">this.mustEnforceCursorAssoc = false;</span><span class="s3">\n            </span><span class="s1">// This is done in the read stage, because moving the selection</span><span class="s3">\n            </span><span class="s1">// to a line end is going to trigger a layout anyway, so it</span><span class="s3">\n            </span><span class="s1">// can't be a pure write. It should be rare that it does any</span><span class="s3">\n            </span><span class="s1">// writing.</span><span class="s3">\n            </span><span class="s1">view.docView.enforceCursorAssoc();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get visibleTop() { return this.scaler.fromDOM(this.pixelViewport.top); }</span><span class="s3">\n    </span><span class="s1">get visibleBottom() { return this.scaler.fromDOM(this.pixelViewport.bottom); }</span><span class="s3">\n    </span><span class="s1">getViewport(bias, scrollTarget) {</span><span class="s3">\n        </span><span class="s1">// This will divide VP.Margin between the top and the</span><span class="s3">\n        </span><span class="s1">// bottom, depending on the bias (the change in viewport position</span><span class="s3">\n        </span><span class="s1">// since the last update). It'll hold a number between 0 and 1</span><span class="s3">\n        </span><span class="s1">let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* VP.Margin */ / 2));</span><span class="s3">\n        </span><span class="s1">let map = this.heightMap, oracle = this.heightOracle;</span><span class="s3">\n        </span><span class="s1">let { visibleTop, visibleBottom } = this;</span><span class="s3">\n        </span><span class="s1">let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000 /* VP.Margin */, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000 /* VP.Margin */, QueryType.ByHeight, oracle, 0, 0).to);</span><span class="s3">\n        </span><span class="s1">// If scrollTarget is given, make sure the viewport includes that position</span><span class="s3">\n        </span><span class="s1">if (scrollTarget) {</span><span class="s3">\n            </span><span class="s1">let { head } = scrollTarget.range;</span><span class="s3">\n            </span><span class="s1">if (head &lt; viewport.from || head &gt; viewport.to) {</span><span class="s3">\n                </span><span class="s1">let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);</span><span class="s3">\n                </span><span class="s1">let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;</span><span class="s3">\n                </span><span class="s1">if (scrollTarget.y == </span><span class="s3">\&quot;</span><span class="s1">center</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                    </span><span class="s1">topPos = (block.top + block.bottom) / 2 - viewHeight / 2;</span><span class="s3">\n                </span><span class="s1">else if (scrollTarget.y == </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot; </span><span class="s1">|| scrollTarget.y == </span><span class="s3">\&quot;</span><span class="s1">nearest</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; head &lt; viewport.from)</span><span class="s3">\n                    </span><span class="s1">topPos = block.top;</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">topPos = block.bottom - viewHeight;</span><span class="s3">\n                </span><span class="s1">viewport = new Viewport(map.lineAt(topPos - 1000 /* VP.Margin */ / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 /* VP.Margin */ / 2, QueryType.ByHeight, oracle, 0, 0).to);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return viewport;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mapViewport(viewport, changes) {</span><span class="s3">\n        </span><span class="s1">let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);</span><span class="s3">\n        </span><span class="s1">return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Checks if a given viewport covers the visible part of the</span><span class="s3">\n    </span><span class="s1">// document and not too much beyond that.</span><span class="s3">\n    </span><span class="s1">viewportIsAppropriate({ from, to }, bias = 0) {</span><span class="s3">\n        </span><span class="s1">if (!this.inView)</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);</span><span class="s3">\n        </span><span class="s1">let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);</span><span class="s3">\n        </span><span class="s1">let { visibleTop, visibleBottom } = this;</span><span class="s3">\n        </span><span class="s1">return (from == 0 || top &lt;= visibleTop - Math.max(10 /* VP.MinCoverMargin */, Math.min(-bias, 250 /* VP.MaxCoverMargin */))) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(to == this.state.doc.length ||</span><span class="s3">\n                </span><span class="s1">bottom &gt;= visibleBottom + Math.max(10 /* VP.MinCoverMargin */, Math.min(bias, 250 /* VP.MaxCoverMargin */))) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(top &gt; visibleTop - 2 * 1000 /* VP.Margin */ &amp;&amp; bottom &lt; visibleBottom + 2 * 1000 /* VP.Margin */);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mapLineGaps(gaps, changes) {</span><span class="s3">\n        </span><span class="s1">if (!gaps.length || changes.empty)</span><span class="s3">\n            </span><span class="s1">return gaps;</span><span class="s3">\n        </span><span class="s1">let mapped = [];</span><span class="s3">\n        </span><span class="s1">for (let gap of gaps)</span><span class="s3">\n            </span><span class="s1">if (!changes.touchesRange(gap.from, gap.to))</span><span class="s3">\n                </span><span class="s1">mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));</span><span class="s3">\n        </span><span class="s1">return mapped;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Computes positions in the viewport where the start or end of a</span><span class="s3">\n    </span><span class="s1">// line should be hidden, trying to reuse existing line gaps when</span><span class="s3">\n    </span><span class="s1">// appropriate to avoid unneccesary redraws.</span><span class="s3">\n    </span><span class="s1">// Uses crude character-counting for the positioning and sizing,</span><span class="s3">\n    </span><span class="s1">// since actual DOM coordinates aren't always available and</span><span class="s3">\n    </span><span class="s1">// predictable. Relies on generous margins (see LG.Margin) to hide</span><span class="s3">\n    </span><span class="s1">// the artifacts this might produce from the user.</span><span class="s3">\n    </span><span class="s1">ensureLineGaps(current, mayMeasure) {</span><span class="s3">\n        </span><span class="s1">let wrapping = this.heightOracle.lineWrapping;</span><span class="s3">\n        </span><span class="s1">let margin = wrapping ? 10000 /* LG.MarginWrap */ : 2000 /* LG.Margin */, halfMargin = margin &gt;&gt; 1, doubleMargin = margin &lt;&lt; 1;</span><span class="s3">\n        </span><span class="s1">// The non-wrapping logic won't work at all in predominantly right-to-left text.</span><span class="s3">\n        </span><span class="s1">if (this.defaultTextDirection != Direction.LTR &amp;&amp; !wrapping)</span><span class="s3">\n            </span><span class="s1">return [];</span><span class="s3">\n        </span><span class="s1">let gaps = [];</span><span class="s3">\n        </span><span class="s1">let addGap = (from, to, line, structure) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (to - from &lt; halfMargin)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">let sel = this.state.selection.main, avoid = [sel.from];</span><span class="s3">\n            </span><span class="s1">if (!sel.empty)</span><span class="s3">\n                </span><span class="s1">avoid.push(sel.to);</span><span class="s3">\n            </span><span class="s1">for (let pos of avoid) {</span><span class="s3">\n                </span><span class="s1">if (pos &gt; from &amp;&amp; pos &lt; to) {</span><span class="s3">\n                    </span><span class="s1">addGap(from, pos - 10 /* LG.SelectionMargin */, line, structure);</span><span class="s3">\n                    </span><span class="s1">addGap(pos + 10 /* LG.SelectionMargin */, to, line, structure);</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let gap = find(current, gap =&gt; gap.from &gt;= line.from &amp;&amp; gap.to &lt;= line.to &amp;&amp;</span><span class="s3">\n                </span><span class="s1">Math.abs(gap.from - from) &lt; halfMargin &amp;&amp; Math.abs(gap.to - to) &lt; halfMargin &amp;&amp;</span><span class="s3">\n                </span><span class="s1">!avoid.some(pos =&gt; gap.from &lt; pos &amp;&amp; gap.to &gt; pos));</span><span class="s3">\n            </span><span class="s1">if (!gap) {</span><span class="s3">\n                </span><span class="s1">// When scrolling down, snap gap ends to line starts to avoid shifts in wrapping</span><span class="s3">\n                </span><span class="s1">if (to &lt; line.to &amp;&amp; mayMeasure &amp;&amp; wrapping &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">mayMeasure.visibleRanges.some(r =&gt; r.from &lt;= to &amp;&amp; r.to &gt;= to)) {</span><span class="s3">\n                    </span><span class="s1">let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to), false, true).head;</span><span class="s3">\n                    </span><span class="s1">if (lineStart &gt; from)</span><span class="s3">\n                        </span><span class="s1">to = lineStart;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">let size = this.gapSize(line, from, to, structure);</span><span class="s3">\n                </span><span class="s1">let displaySize = wrapping || size &lt; 2000000 /* VP.MaxHorizGap */ ? size : 2000000 /* VP.MaxHorizGap */;</span><span class="s3">\n                </span><span class="s1">gap = new LineGap(from, to, size, displaySize);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">gaps.push(gap);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">let checkLine = (line) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (line.length &lt; doubleMargin || line.type != BlockType.Text)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">let structure = lineStructure(line.from, line.to, this.stateDeco);</span><span class="s3">\n            </span><span class="s1">if (structure.total &lt; doubleMargin)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">let target = this.scrollTarget ? this.scrollTarget.range.head : null;</span><span class="s3">\n            </span><span class="s1">let viewFrom, viewTo;</span><span class="s3">\n            </span><span class="s1">if (wrapping) {</span><span class="s3">\n                </span><span class="s1">let marginHeight = (margin / this.heightOracle.lineLength) * this.heightOracle.lineHeight;</span><span class="s3">\n                </span><span class="s1">let top, bot;</span><span class="s3">\n                </span><span class="s1">if (target != null) {</span><span class="s3">\n                    </span><span class="s1">let targetFrac = findFraction(structure, target);</span><span class="s3">\n                    </span><span class="s1">let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;</span><span class="s3">\n                    </span><span class="s1">top = targetFrac - spaceFrac;</span><span class="s3">\n                    </span><span class="s1">bot = targetFrac + spaceFrac;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">top = (this.visibleTop - line.top - marginHeight) / line.height;</span><span class="s3">\n                    </span><span class="s1">bot = (this.visibleBottom - line.top + marginHeight) / line.height;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">viewFrom = findPosition(structure, top);</span><span class="s3">\n                </span><span class="s1">viewTo = findPosition(structure, bot);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let totalWidth = structure.total * this.heightOracle.charWidth;</span><span class="s3">\n                </span><span class="s1">let marginWidth = margin * this.heightOracle.charWidth;</span><span class="s3">\n                </span><span class="s1">let horizOffset = 0;</span><span class="s3">\n                </span><span class="s1">if (totalWidth &gt; 2000000 /* VP.MaxHorizGap */)</span><span class="s3">\n                    </span><span class="s1">for (let old of current) {</span><span class="s3">\n                        </span><span class="s1">if (old.from &gt;= line.from &amp;&amp; old.from &lt; line.to &amp;&amp; old.size != old.displaySize &amp;&amp;</span><span class="s3">\n                            </span><span class="s1">old.from * this.heightOracle.charWidth + horizOffset &lt; this.pixelViewport.left)</span><span class="s3">\n                            </span><span class="s1">horizOffset = old.size - old.displaySize;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;</span><span class="s3">\n                </span><span class="s1">let left, right;</span><span class="s3">\n                </span><span class="s1">if (target != null) {</span><span class="s3">\n                    </span><span class="s1">let targetFrac = findFraction(structure, target);</span><span class="s3">\n                    </span><span class="s1">let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;</span><span class="s3">\n                    </span><span class="s1">left = targetFrac - spaceFrac;</span><span class="s3">\n                    </span><span class="s1">right = targetFrac + spaceFrac;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">left = (pxLeft - marginWidth) / totalWidth;</span><span class="s3">\n                    </span><span class="s1">right = (pxRight + marginWidth) / totalWidth;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">viewFrom = findPosition(structure, left);</span><span class="s3">\n                </span><span class="s1">viewTo = findPosition(structure, right);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (viewFrom &gt; line.from)</span><span class="s3">\n                </span><span class="s1">addGap(line.from, viewFrom, line, structure);</span><span class="s3">\n            </span><span class="s1">if (viewTo &lt; line.to)</span><span class="s3">\n                </span><span class="s1">addGap(viewTo, line.to, line, structure);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">for (let line of this.viewportLines) {</span><span class="s3">\n            </span><span class="s1">if (Array.isArray(line.type))</span><span class="s3">\n                </span><span class="s1">line.type.forEach(checkLine);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">checkLine(line);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return gaps;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">gapSize(line, from, to, structure) {</span><span class="s3">\n        </span><span class="s1">let fraction = findFraction(structure, to) - findFraction(structure, from);</span><span class="s3">\n        </span><span class="s1">if (this.heightOracle.lineWrapping) {</span><span class="s3">\n            </span><span class="s1">return line.height * fraction;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return structure.total * this.heightOracle.charWidth * fraction;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateLineGaps(gaps) {</span><span class="s3">\n        </span><span class="s1">if (!LineGap.same(gaps, this.lineGaps)) {</span><span class="s3">\n            </span><span class="s1">this.lineGaps = gaps;</span><span class="s3">\n            </span><span class="s1">this.lineGapDeco = Decoration.set(gaps.map(gap =&gt; gap.draw(this, this.heightOracle.lineWrapping)));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">computeVisibleRanges(changes) {</span><span class="s3">\n        </span><span class="s1">let deco = this.stateDeco;</span><span class="s3">\n        </span><span class="s1">if (this.lineGaps.length)</span><span class="s3">\n            </span><span class="s1">deco = deco.concat(this.lineGapDeco);</span><span class="s3">\n        </span><span class="s1">let ranges = [];</span><span class="s3">\n        </span><span class="s1">RangeSet.spans(deco, this.viewport.from, this.viewport.to, {</span><span class="s3">\n            </span><span class="s1">span(from, to) { ranges.push({ from, to }); },</span><span class="s3">\n            </span><span class="s1">point() { }</span><span class="s3">\n        </span><span class="s1">}, 20);</span><span class="s3">\n        </span><span class="s1">let changed = 0;</span><span class="s3">\n        </span><span class="s1">if (ranges.length != this.visibleRanges.length) {</span><span class="s3">\n            </span><span class="s1">changed = 8 /* UpdateFlag.ViewportMoved */ | 4 /* UpdateFlag.Viewport */;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; ranges.length &amp;&amp; !(changed &amp; 8 /* UpdateFlag.ViewportMoved */); i++) {</span><span class="s3">\n                </span><span class="s1">let old = this.visibleRanges[i], nw = ranges[i];</span><span class="s3">\n                </span><span class="s1">if (old.from != nw.from || old.to != nw.to) {</span><span class="s3">\n                    </span><span class="s1">changed |= 4 /* UpdateFlag.Viewport */;</span><span class="s3">\n                    </span><span class="s1">if (!(changes &amp;&amp; changes.mapPos(old.from, -1) == nw.from &amp;&amp; changes.mapPos(old.to, 1) == nw.to))</span><span class="s3">\n                        </span><span class="s1">changed |= 8 /* UpdateFlag.ViewportMoved */;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.visibleRanges = ranges;</span><span class="s3">\n        </span><span class="s1">return changed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">lineBlockAt(pos) {</span><span class="s3">\n        </span><span class="s1">return (pos &gt;= this.viewport.from &amp;&amp; pos &lt;= this.viewport.to &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.viewportLines.find(b =&gt; b.from &lt;= pos &amp;&amp; b.to &gt;= pos)) ||</span><span class="s3">\n            </span><span class="s1">scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">lineBlockAtHeight(height) {</span><span class="s3">\n        </span><span class="s1">return (height &gt;= this.viewportLines[0].top &amp;&amp; height &lt;= this.viewportLines[this.viewportLines.length - 1].bottom &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.viewportLines.find(l =&gt; l.top &lt;= height &amp;&amp; l.bottom &gt;= height)) ||</span><span class="s3">\n            </span><span class="s1">scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scrollAnchorAt(scrollTop) {</span><span class="s3">\n        </span><span class="s1">let block = this.lineBlockAtHeight(scrollTop + 8);</span><span class="s3">\n        </span><span class="s1">return block.from &gt;= this.viewport.from || this.viewportLines[0].top - scrollTop &gt; 200 ? block : this.viewportLines[0];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">elementAtHeight(height) {</span><span class="s3">\n        </span><span class="s1">return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get docHeight() {</span><span class="s3">\n        </span><span class="s1">return this.scaler.toDOM(this.heightMap.height);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get contentHeight() {</span><span class="s3">\n        </span><span class="s1">return this.docHeight + this.paddingTop + this.paddingBottom;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Viewport {</span><span class="s3">\n    </span><span class="s1">constructor(from, to) {</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function lineStructure(from, to, stateDeco) {</span><span class="s3">\n    </span><span class="s1">let ranges = [], pos = from, total = 0;</span><span class="s3">\n    </span><span class="s1">RangeSet.spans(stateDeco, from, to, {</span><span class="s3">\n        </span><span class="s1">span() { },</span><span class="s3">\n        </span><span class="s1">point(from, to) {</span><span class="s3">\n            </span><span class="s1">if (from &gt; pos) {</span><span class="s3">\n                </span><span class="s1">ranges.push({ from: pos, to: from });</span><span class="s3">\n                </span><span class="s1">total += from - pos;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">pos = to;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, 20); // We're only interested in collapsed ranges of a significant size</span><span class="s3">\n    </span><span class="s1">if (pos &lt; to) {</span><span class="s3">\n        </span><span class="s1">ranges.push({ from: pos, to });</span><span class="s3">\n        </span><span class="s1">total += to - pos;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return { total, ranges };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findPosition({ total, ranges }, ratio) {</span><span class="s3">\n    </span><span class="s1">if (ratio &lt;= 0)</span><span class="s3">\n        </span><span class="s1">return ranges[0].from;</span><span class="s3">\n    </span><span class="s1">if (ratio &gt;= 1)</span><span class="s3">\n        </span><span class="s1">return ranges[ranges.length - 1].to;</span><span class="s3">\n    </span><span class="s1">let dist = Math.floor(total * ratio);</span><span class="s3">\n    </span><span class="s1">for (let i = 0;; i++) {</span><span class="s3">\n        </span><span class="s1">let { from, to } = ranges[i], size = to - from;</span><span class="s3">\n        </span><span class="s1">if (dist &lt;= size)</span><span class="s3">\n            </span><span class="s1">return from + dist;</span><span class="s3">\n        </span><span class="s1">dist -= size;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findFraction(structure, pos) {</span><span class="s3">\n    </span><span class="s1">let counted = 0;</span><span class="s3">\n    </span><span class="s1">for (let { from, to } of structure.ranges) {</span><span class="s3">\n        </span><span class="s1">if (pos &lt;= to) {</span><span class="s3">\n            </span><span class="s1">counted += pos - from;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">counted += to - from;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return counted / structure.total;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function find(array, f) {</span><span class="s3">\n    </span><span class="s1">for (let val of array)</span><span class="s3">\n        </span><span class="s1">if (f(val))</span><span class="s3">\n            </span><span class="s1">return val;</span><span class="s3">\n    </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Don't scale when the document height is within the range of what</span><span class="s3">\n</span><span class="s1">// the DOM can handle.</span><span class="s3">\n</span><span class="s1">const IdScaler = {</span><span class="s3">\n    </span><span class="s1">toDOM(n) { return n; },</span><span class="s3">\n    </span><span class="s1">fromDOM(n) { return n; },</span><span class="s3">\n    </span><span class="s1">scale: 1,</span><span class="s3">\n    </span><span class="s1">eq(other) { return other == this; }</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">// When the height is too big (&gt; VP.MaxDOMHeight), scale down the</span><span class="s3">\n</span><span class="s1">// regions outside the viewports so that the total height is</span><span class="s3">\n</span><span class="s1">// VP.MaxDOMHeight.</span><span class="s3">\n</span><span class="s1">class BigScaler {</span><span class="s3">\n    </span><span class="s1">constructor(oracle, heightMap, viewports) {</span><span class="s3">\n        </span><span class="s1">let vpHeight = 0, base = 0, domBase = 0;</span><span class="s3">\n        </span><span class="s1">this.viewports = viewports.map(({ from, to }) =&gt; {</span><span class="s3">\n            </span><span class="s1">let top = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;</span><span class="s3">\n            </span><span class="s1">let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;</span><span class="s3">\n            </span><span class="s1">vpHeight += bottom - top;</span><span class="s3">\n            </span><span class="s1">return { from, to, top, bottom, domTop: 0, domBottom: 0 };</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.scale = (7000000 /* VP.MaxDOMHeight */ - vpHeight) / (heightMap.height - vpHeight);</span><span class="s3">\n        </span><span class="s1">for (let obj of this.viewports) {</span><span class="s3">\n            </span><span class="s1">obj.domTop = domBase + (obj.top - base) * this.scale;</span><span class="s3">\n            </span><span class="s1">domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);</span><span class="s3">\n            </span><span class="s1">base = obj.bottom;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toDOM(n) {</span><span class="s3">\n        </span><span class="s1">for (let i = 0, base = 0, domBase = 0;; i++) {</span><span class="s3">\n            </span><span class="s1">let vp = i &lt; this.viewports.length ? this.viewports[i] : null;</span><span class="s3">\n            </span><span class="s1">if (!vp || n &lt; vp.top)</span><span class="s3">\n                </span><span class="s1">return domBase + (n - base) * this.scale;</span><span class="s3">\n            </span><span class="s1">if (n &lt;= vp.bottom)</span><span class="s3">\n                </span><span class="s1">return vp.domTop + (n - vp.top);</span><span class="s3">\n            </span><span class="s1">base = vp.bottom;</span><span class="s3">\n            </span><span class="s1">domBase = vp.domBottom;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fromDOM(n) {</span><span class="s3">\n        </span><span class="s1">for (let i = 0, base = 0, domBase = 0;; i++) {</span><span class="s3">\n            </span><span class="s1">let vp = i &lt; this.viewports.length ? this.viewports[i] : null;</span><span class="s3">\n            </span><span class="s1">if (!vp || n &lt; vp.domTop)</span><span class="s3">\n                </span><span class="s1">return base + (n - domBase) / this.scale;</span><span class="s3">\n            </span><span class="s1">if (n &lt;= vp.domBottom)</span><span class="s3">\n                </span><span class="s1">return vp.top + (n - vp.domTop);</span><span class="s3">\n            </span><span class="s1">base = vp.bottom;</span><span class="s3">\n            </span><span class="s1">domBase = vp.domBottom;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(other) {</span><span class="s3">\n        </span><span class="s1">if (!(other instanceof BigScaler))</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">return this.scale == other.scale &amp;&amp; this.viewports.length == other.viewports.length &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.viewports.every((vp, i) =&gt; vp.from == other.viewports[i].from &amp;&amp; vp.to == other.viewports[i].to);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function scaleBlock(block, scaler) {</span><span class="s3">\n    </span><span class="s1">if (scaler.scale == 1)</span><span class="s3">\n        </span><span class="s1">return block;</span><span class="s3">\n    </span><span class="s1">let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);</span><span class="s3">\n    </span><span class="s1">return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map(b =&gt; scaleBlock(b, scaler)) : block._content);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const theme = /*@__PURE__*/Facet.define({ combine: strs =&gt; strs.join(</span><span class="s3">\&quot; \&quot;</span><span class="s1">) });</span><span class="s3">\n</span><span class="s1">const darkTheme = /*@__PURE__*/Facet.define({ combine: values =&gt; values.indexOf(true) &gt; -1 });</span><span class="s3">\n</span><span class="s1">const baseThemeID = /*@__PURE__*/StyleModule.newName(), baseLightID = /*@__PURE__*/StyleModule.newName(), baseDarkID = /*@__PURE__*/StyleModule.newName();</span><span class="s3">\n</span><span class="s1">const lightDarkIDs = { </span><span class="s3">\&quot;</span><span class="s1">&amp;light</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">+ baseLightID, </span><span class="s3">\&quot;</span><span class="s1">&amp;dark</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">+ baseDarkID };</span><span class="s3">\n</span><span class="s1">function buildTheme(main, spec, scopes) {</span><span class="s3">\n    </span><span class="s1">return new StyleModule(spec, {</span><span class="s3">\n        </span><span class="s1">finish(sel) {</span><span class="s3">\n            </span><span class="s1">return /&amp;/.test(sel) ? sel.replace(/&amp;</span><span class="s3">\\</span><span class="s1">w*/, m =&gt; {</span><span class="s3">\n                </span><span class="s1">if (m == </span><span class="s3">\&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                    </span><span class="s1">return main;</span><span class="s3">\n                </span><span class="s1">if (!scopes || !scopes[m])</span><span class="s3">\n                    </span><span class="s1">throw new RangeError(`Unsupported selector: ${m}`);</span><span class="s3">\n                </span><span class="s1">return scopes[m];</span><span class="s3">\n            </span><span class="s1">}) : main + </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ sel;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const baseTheme$1 = /*@__PURE__*/buildTheme(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">+ baseThemeID, {</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">position: </span><span class="s3">\&quot;</span><span class="s1">relative !important</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">boxSizing: </span><span class="s3">\&quot;</span><span class="s1">border-box</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">&amp;.cm-focused</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">// Provide a simple default outline to make sure a focused</span><span class="s3">\n            </span><span class="s1">// editor is visually distinct. Can't leave the default behavior</span><span class="s3">\n            </span><span class="s1">// because that will apply to the content element, which is</span><span class="s3">\n            </span><span class="s1">// inside the scrollable container and doesn't include the</span><span class="s3">\n            </span><span class="s1">// gutters. We also can't use an 'auto' outline, since those</span><span class="s3">\n            </span><span class="s1">// are, for some reason, drawn behind the element content, which</span><span class="s3">\n            </span><span class="s1">// will cause things like the active line background to cover</span><span class="s3">\n            </span><span class="s1">// the outline (#297).</span><span class="s3">\n            </span><span class="s1">outline: </span><span class="s3">\&quot;</span><span class="s1">1px dotted #212121</span><span class="s3">\&quot;\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">display: </span><span class="s3">\&quot;</span><span class="s1">flex !important</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">flexDirection: </span><span class="s3">\&quot;</span><span class="s1">column</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-scroller</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">display: </span><span class="s3">\&quot;</span><span class="s1">flex !important</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">alignItems: </span><span class="s3">\&quot;</span><span class="s1">flex-start !important</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">fontFamily: </span><span class="s3">\&quot;</span><span class="s1">monospace</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">lineHeight: 1.4,</span><span class="s3">\n        </span><span class="s1">height: </span><span class="s3">\&quot;</span><span class="s1">100%</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">overflowX: </span><span class="s3">\&quot;</span><span class="s1">auto</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">position: </span><span class="s3">\&quot;</span><span class="s1">relative</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">zIndex: 0,</span><span class="s3">\n        </span><span class="s1">overflowAnchor: </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-content</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">margin: 0,</span><span class="s3">\n        </span><span class="s1">flexGrow: 2,</span><span class="s3">\n        </span><span class="s1">flexShrink: 0,</span><span class="s3">\n        </span><span class="s1">display: </span><span class="s3">\&quot;</span><span class="s1">block</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">whiteSpace: </span><span class="s3">\&quot;</span><span class="s1">pre</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">wordWrap: </span><span class="s3">\&quot;</span><span class="s1">normal</span><span class="s3">\&quot;</span><span class="s1">, // https://github.com/codemirror/dev/issues/456</span><span class="s3">\n        </span><span class="s1">boxSizing: </span><span class="s3">\&quot;</span><span class="s1">border-box</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">minHeight: </span><span class="s3">\&quot;</span><span class="s1">100%</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">padding: </span><span class="s3">\&quot;</span><span class="s1">4px 0</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">outline: </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">&amp;[contenteditable=true]</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">WebkitUserModify: </span><span class="s3">\&quot;</span><span class="s1">read-write-plaintext-only</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-lineWrapping</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">whiteSpace_fallback: </span><span class="s3">\&quot;</span><span class="s1">pre-wrap</span><span class="s3">\&quot;</span><span class="s1">, // For IE</span><span class="s3">\n        </span><span class="s1">whiteSpace: </span><span class="s3">\&quot;</span><span class="s1">break-spaces</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">wordBreak: </span><span class="s3">\&quot;</span><span class="s1">break-word</span><span class="s3">\&quot;</span><span class="s1">, // For Safari, which doesn't support overflow-wrap: anywhere</span><span class="s3">\n        </span><span class="s1">overflowWrap: </span><span class="s3">\&quot;</span><span class="s1">anywhere</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">flexShrink: 1</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;light .cm-content</span><span class="s3">\&quot;</span><span class="s1">: { caretColor: </span><span class="s3">\&quot;</span><span class="s1">black</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;dark .cm-content</span><span class="s3">\&quot;</span><span class="s1">: { caretColor: </span><span class="s3">\&quot;</span><span class="s1">white</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-line</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">display: </span><span class="s3">\&quot;</span><span class="s1">block</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">padding: </span><span class="s3">\&quot;</span><span class="s1">0 2px 0 6px</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-layer</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">position: </span><span class="s3">\&quot;</span><span class="s1">absolute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">left: 0,</span><span class="s3">\n        </span><span class="s1">top: 0,</span><span class="s3">\n        </span><span class="s1">contain: </span><span class="s3">\&quot;</span><span class="s1">size style</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">&amp; &gt; *</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">position: </span><span class="s3">\&quot;</span><span class="s1">absolute</span><span class="s3">\&quot;\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;light .cm-selectionBackground</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">background: </span><span class="s3">\&quot;</span><span class="s1">#d9d9d9</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;dark .cm-selectionBackground</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">background: </span><span class="s3">\&quot;</span><span class="s1">#222</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;light.cm-focused &gt; .cm-scroller &gt; .cm-selectionLayer .cm-selectionBackground</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">background: </span><span class="s3">\&quot;</span><span class="s1">#d7d4f0</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;dark.cm-focused &gt; .cm-scroller &gt; .cm-selectionLayer .cm-selectionBackground</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">background: </span><span class="s3">\&quot;</span><span class="s1">#233</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-cursorLayer</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">pointerEvents: </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;.cm-focused &gt; .cm-scroller &gt; .cm-cursorLayer</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">animation: </span><span class="s3">\&quot;</span><span class="s1">steps(1) cm-blink 1.2s infinite</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">// Two animations defined so that we can switch between them to</span><span class="s3">\n    </span><span class="s1">// restart the animation without forcing another style</span><span class="s3">\n    </span><span class="s1">// recomputation.</span><span class="s3">\n    \&quot;</span><span class="s1">@keyframes cm-blink</span><span class="s3">\&quot;</span><span class="s1">: { </span><span class="s3">\&quot;</span><span class="s1">0%</span><span class="s3">\&quot;</span><span class="s1">: {}, </span><span class="s3">\&quot;</span><span class="s1">50%</span><span class="s3">\&quot;</span><span class="s1">: { opacity: 0 }, </span><span class="s3">\&quot;</span><span class="s1">100%</span><span class="s3">\&quot;</span><span class="s1">: {} },</span><span class="s3">\n    \&quot;</span><span class="s1">@keyframes cm-blink2</span><span class="s3">\&quot;</span><span class="s1">: { </span><span class="s3">\&quot;</span><span class="s1">0%</span><span class="s3">\&quot;</span><span class="s1">: {}, </span><span class="s3">\&quot;</span><span class="s1">50%</span><span class="s3">\&quot;</span><span class="s1">: { opacity: 0 }, </span><span class="s3">\&quot;</span><span class="s1">100%</span><span class="s3">\&quot;</span><span class="s1">: {} },</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-cursor, .cm-dropCursor</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">borderLeft: </span><span class="s3">\&quot;</span><span class="s1">1.2px solid black</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">marginLeft: </span><span class="s3">\&quot;</span><span class="s1">-0.6px</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">pointerEvents: </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-cursor</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">display: </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;dark .cm-cursor</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">borderLeftColor: </span><span class="s3">\&quot;</span><span class="s1">#ddd</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-dropCursor</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">position: </span><span class="s3">\&quot;</span><span class="s1">absolute</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;.cm-focused &gt; .cm-scroller &gt; .cm-cursorLayer .cm-cursor</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">display: </span><span class="s3">\&quot;</span><span class="s1">block</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-iso</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">unicodeBidi: </span><span class="s3">\&quot;</span><span class="s1">isolate</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-announced</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">position: </span><span class="s3">\&quot;</span><span class="s1">fixed</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">top: </span><span class="s3">\&quot;</span><span class="s1">-10000px</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">@media print</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        \&quot;</span><span class="s1">.cm-announced</span><span class="s3">\&quot;</span><span class="s1">: { display: </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;light .cm-activeLine</span><span class="s3">\&quot;</span><span class="s1">: { backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#cceeff44</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;dark .cm-activeLine</span><span class="s3">\&quot;</span><span class="s1">: { backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#99eeff33</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;light .cm-specialChar</span><span class="s3">\&quot;</span><span class="s1">: { color: </span><span class="s3">\&quot;</span><span class="s1">red</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;dark .cm-specialChar</span><span class="s3">\&quot;</span><span class="s1">: { color: </span><span class="s3">\&quot;</span><span class="s1">#f78</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-gutters</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">flexShrink: 0,</span><span class="s3">\n        </span><span class="s1">display: </span><span class="s3">\&quot;</span><span class="s1">flex</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">height: </span><span class="s3">\&quot;</span><span class="s1">100%</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">boxSizing: </span><span class="s3">\&quot;</span><span class="s1">border-box</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">insetInlineStart: 0,</span><span class="s3">\n        </span><span class="s1">zIndex: 200</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;light .cm-gutters</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#f5f5f5</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">#6c6c6c</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">borderRight: </span><span class="s3">\&quot;</span><span class="s1">1px solid #ddd</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;dark .cm-gutters</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#333338</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">#ccc</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-gutter</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">display: </span><span class="s3">\&quot;</span><span class="s1">flex !important</span><span class="s3">\&quot;</span><span class="s1">, // Necessary -- prevents margin collapsing</span><span class="s3">\n        </span><span class="s1">flexDirection: </span><span class="s3">\&quot;</span><span class="s1">column</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">flexShrink: 0,</span><span class="s3">\n        </span><span class="s1">boxSizing: </span><span class="s3">\&quot;</span><span class="s1">border-box</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">minHeight: </span><span class="s3">\&quot;</span><span class="s1">100%</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">overflow: </span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-gutterElement</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">boxSizing: </span><span class="s3">\&quot;</span><span class="s1">border-box</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-lineNumbers .cm-gutterElement</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">padding: </span><span class="s3">\&quot;</span><span class="s1">0 3px 0 5px</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">minWidth: </span><span class="s3">\&quot;</span><span class="s1">20px</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">textAlign: </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">whiteSpace: </span><span class="s3">\&quot;</span><span class="s1">nowrap</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;light .cm-activeLineGutter</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#e2f2ff</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;dark .cm-activeLineGutter</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#222227</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-panels</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">boxSizing: </span><span class="s3">\&quot;</span><span class="s1">border-box</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">position: </span><span class="s3">\&quot;</span><span class="s1">sticky</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">left: 0,</span><span class="s3">\n        </span><span class="s1">right: 0,</span><span class="s3">\n        </span><span class="s1">zIndex: 300</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;light .cm-panels</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#f5f5f5</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">black</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;light .cm-panels-top</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">borderBottom: </span><span class="s3">\&quot;</span><span class="s1">1px solid #ddd</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;light .cm-panels-bottom</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">borderTop: </span><span class="s3">\&quot;</span><span class="s1">1px solid #ddd</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;dark .cm-panels</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#333338</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">white</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-tab</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">display: </span><span class="s3">\&quot;</span><span class="s1">inline-block</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">overflow: </span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">verticalAlign: </span><span class="s3">\&quot;</span><span class="s1">bottom</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-widgetBuffer</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">verticalAlign: </span><span class="s3">\&quot;</span><span class="s1">text-top</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">height: </span><span class="s3">\&quot;</span><span class="s1">1em</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">width: 0,</span><span class="s3">\n        </span><span class="s1">display: </span><span class="s3">\&quot;</span><span class="s1">inline</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-placeholder</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">#888</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">display: </span><span class="s3">\&quot;</span><span class="s1">inline-block</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">verticalAlign: </span><span class="s3">\&quot;</span><span class="s1">top</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-highlightSpace</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">backgroundImage: </span><span class="s3">\&quot;</span><span class="s1">radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">backgroundPosition: </span><span class="s3">\&quot;</span><span class="s1">center</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-highlightTab</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">backgroundImage: `url('data:image/svg+xml,&lt;svg xmlns=</span><span class="s3">\&quot;</span><span class="s1">http://www.w3.org/2000/svg</span><span class="s3">\&quot; </span><span class="s1">width=</span><span class="s3">\&quot;</span><span class="s1">200</span><span class="s3">\&quot; </span><span class="s1">height=</span><span class="s3">\&quot;</span><span class="s1">20</span><span class="s3">\&quot;</span><span class="s1">&gt;&lt;path stroke=</span><span class="s3">\&quot;</span><span class="s1">%23888</span><span class="s3">\&quot; </span><span class="s1">stroke-width=</span><span class="s3">\&quot;</span><span class="s1">1</span><span class="s3">\&quot; </span><span class="s1">fill=</span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot; </span><span class="s1">d=</span><span class="s3">\&quot;</span><span class="s1">M1 10H196L190 5M190 15L196 10M197 4L197 16</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;/svg&gt;')`,</span><span class="s3">\n        </span><span class="s1">backgroundSize: </span><span class="s3">\&quot;</span><span class="s1">auto 100%</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">backgroundPosition: </span><span class="s3">\&quot;</span><span class="s1">right 90%</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">backgroundRepeat: </span><span class="s3">\&quot;</span><span class="s1">no-repeat</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-trailingSpace</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#ff332255</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-button</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">verticalAlign: </span><span class="s3">\&quot;</span><span class="s1">middle</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">inherit</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">fontSize: </span><span class="s3">\&quot;</span><span class="s1">70%</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">padding: </span><span class="s3">\&quot;</span><span class="s1">.2em 1em</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">borderRadius: </span><span class="s3">\&quot;</span><span class="s1">1px</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;light .cm-button</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">backgroundImage: </span><span class="s3">\&quot;</span><span class="s1">linear-gradient(#eff1f5, #d9d9df)</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">border: </span><span class="s3">\&quot;</span><span class="s1">1px solid #888</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">&amp;:active</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">backgroundImage: </span><span class="s3">\&quot;</span><span class="s1">linear-gradient(#b4b4b4, #d0d3d6)</span><span class="s3">\&quot;\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;dark .cm-button</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">backgroundImage: </span><span class="s3">\&quot;</span><span class="s1">linear-gradient(#393939, #111)</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">border: </span><span class="s3">\&quot;</span><span class="s1">1px solid #888</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">&amp;:active</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">backgroundImage: </span><span class="s3">\&quot;</span><span class="s1">linear-gradient(#111, #333)</span><span class="s3">\&quot;\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-textfield</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">verticalAlign: </span><span class="s3">\&quot;</span><span class="s1">middle</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">inherit</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">fontSize: </span><span class="s3">\&quot;</span><span class="s1">70%</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">border: </span><span class="s3">\&quot;</span><span class="s1">1px solid silver</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">padding: </span><span class="s3">\&quot;</span><span class="s1">.2em .5em</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;light .cm-textfield</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">white</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;dark .cm-textfield</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">border: </span><span class="s3">\&quot;</span><span class="s1">1px solid #555</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">inherit</span><span class="s3">\&quot;\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, lightDarkIDs);</span><span class="s3">\n\n</span><span class="s1">const observeOptions = {</span><span class="s3">\n    </span><span class="s1">childList: true,</span><span class="s3">\n    </span><span class="s1">characterData: true,</span><span class="s3">\n    </span><span class="s1">subtree: true,</span><span class="s3">\n    </span><span class="s1">attributes: true,</span><span class="s3">\n    </span><span class="s1">characterDataOldValue: true</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">// IE11 has very broken mutation observers, so we also listen to</span><span class="s3">\n</span><span class="s1">// DOMCharacterDataModified there</span><span class="s3">\n</span><span class="s1">const useCharData = browser.ie &amp;&amp; browser.ie_version &lt;= 11;</span><span class="s3">\n</span><span class="s1">class DOMObserver {</span><span class="s3">\n    </span><span class="s1">constructor(view) {</span><span class="s3">\n        </span><span class="s1">this.view = view;</span><span class="s3">\n        </span><span class="s1">this.active = false;</span><span class="s3">\n        </span><span class="s1">this.editContext = null;</span><span class="s3">\n        </span><span class="s1">// The known selection. Kept in our own object, as opposed to just</span><span class="s3">\n        </span><span class="s1">// directly accessing the selection because:</span><span class="s3">\n        </span><span class="s1">//  - Safari doesn't report the right selection in shadow DOM</span><span class="s3">\n        </span><span class="s1">//  - Reading from the selection forces a DOM layout</span><span class="s3">\n        </span><span class="s1">//  - This way, we can ignore selectionchange events if we have</span><span class="s3">\n        </span><span class="s1">//    already seen the 'new' selection</span><span class="s3">\n        </span><span class="s1">this.selectionRange = new DOMSelectionState;</span><span class="s3">\n        </span><span class="s1">// Set when a selection change is detected, cleared on flush</span><span class="s3">\n        </span><span class="s1">this.selectionChanged = false;</span><span class="s3">\n        </span><span class="s1">this.delayedFlush = -1;</span><span class="s3">\n        </span><span class="s1">this.resizeTimeout = -1;</span><span class="s3">\n        </span><span class="s1">this.queue = [];</span><span class="s3">\n        </span><span class="s1">this.delayedAndroidKey = null;</span><span class="s3">\n        </span><span class="s1">this.flushingAndroidKey = -1;</span><span class="s3">\n        </span><span class="s1">this.lastChange = 0;</span><span class="s3">\n        </span><span class="s1">this.scrollTargets = [];</span><span class="s3">\n        </span><span class="s1">this.intersection = null;</span><span class="s3">\n        </span><span class="s1">this.resizeScroll = null;</span><span class="s3">\n        </span><span class="s1">this.intersecting = false;</span><span class="s3">\n        </span><span class="s1">this.gapIntersection = null;</span><span class="s3">\n        </span><span class="s1">this.gaps = [];</span><span class="s3">\n        </span><span class="s1">this.printQuery = null;</span><span class="s3">\n        </span><span class="s1">// Timeout for scheduling check of the parents that need scroll handlers</span><span class="s3">\n        </span><span class="s1">this.parentCheck = -1;</span><span class="s3">\n        </span><span class="s1">this.dom = view.contentDOM;</span><span class="s3">\n        </span><span class="s1">this.observer = new MutationObserver(mutations =&gt; {</span><span class="s3">\n            </span><span class="s1">for (let mut of mutations)</span><span class="s3">\n                </span><span class="s1">this.queue.push(mut);</span><span class="s3">\n            </span><span class="s1">// IE11 will sometimes (on typing over a selection or</span><span class="s3">\n            </span><span class="s1">// backspacing out a single character text node) call the</span><span class="s3">\n            </span><span class="s1">// observer callback before actually updating the DOM.</span><span class="s3">\n            </span><span class="s1">//</span><span class="s3">\n            </span><span class="s1">// Unrelatedly, iOS Safari will, when ending a composition,</span><span class="s3">\n            </span><span class="s1">// sometimes first clear it, deliver the mutations, and then</span><span class="s3">\n            </span><span class="s1">// reinsert the finished text. CodeMirror's handling of the</span><span class="s3">\n            </span><span class="s1">// deletion will prevent the reinsertion from happening,</span><span class="s3">\n            </span><span class="s1">// breaking composition.</span><span class="s3">\n            </span><span class="s1">if ((browser.ie &amp;&amp; browser.ie_version &lt;= 11 || browser.ios &amp;&amp; view.composing) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">mutations.some(m =&gt; m.type == </span><span class="s3">\&quot;</span><span class="s1">childList</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; m.removedNodes.length ||</span><span class="s3">\n                    </span><span class="s1">m.type == </span><span class="s3">\&quot;</span><span class="s1">characterData</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; m.oldValue.length &gt; m.target.nodeValue.length))</span><span class="s3">\n                </span><span class="s1">this.flushSoon();</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">this.flush();</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">if (window.EditContext &amp;&amp; view.constructor.EDIT_CONTEXT !== false &amp;&amp;</span><span class="s3">\n            </span><span class="s1">// Chrome &lt;126 doesn't support inverted selections in edit context (#1392)</span><span class="s3">\n            </span><span class="s1">!(browser.chrome &amp;&amp; browser.chrome_version &lt; 126)) {</span><span class="s3">\n            </span><span class="s1">this.editContext = new EditContextManager(view);</span><span class="s3">\n            </span><span class="s1">if (view.state.facet(editable))</span><span class="s3">\n                </span><span class="s1">view.contentDOM.editContext = this.editContext.editContext;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (useCharData)</span><span class="s3">\n            </span><span class="s1">this.onCharData = (event) =&gt; {</span><span class="s3">\n                </span><span class="s1">this.queue.push({ target: event.target,</span><span class="s3">\n                    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">characterData</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                    </span><span class="s1">oldValue: event.prevValue });</span><span class="s3">\n                </span><span class="s1">this.flushSoon();</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this.onSelectionChange = this.onSelectionChange.bind(this);</span><span class="s3">\n        </span><span class="s1">this.onResize = this.onResize.bind(this);</span><span class="s3">\n        </span><span class="s1">this.onPrint = this.onPrint.bind(this);</span><span class="s3">\n        </span><span class="s1">this.onScroll = this.onScroll.bind(this);</span><span class="s3">\n        </span><span class="s1">if (window.matchMedia)</span><span class="s3">\n            </span><span class="s1">this.printQuery = window.matchMedia(</span><span class="s3">\&quot;</span><span class="s1">print</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (typeof ResizeObserver == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">this.resizeScroll = new ResizeObserver(() =&gt; {</span><span class="s3">\n                </span><span class="s1">var _a;</span><span class="s3">\n                </span><span class="s1">if (((_a = this.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) &lt; Date.now() - 75)</span><span class="s3">\n                    </span><span class="s1">this.onResize();</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">this.resizeScroll.observe(view.scrollDOM);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.addWindowListeners(this.win = view.win);</span><span class="s3">\n        </span><span class="s1">this.start();</span><span class="s3">\n        </span><span class="s1">if (typeof IntersectionObserver == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">this.intersection = new IntersectionObserver(entries =&gt; {</span><span class="s3">\n                </span><span class="s1">if (this.parentCheck &lt; 0)</span><span class="s3">\n                    </span><span class="s1">this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);</span><span class="s3">\n                </span><span class="s1">if (entries.length &gt; 0 &amp;&amp; (entries[entries.length - 1].intersectionRatio &gt; 0) != this.intersecting) {</span><span class="s3">\n                    </span><span class="s1">this.intersecting = !this.intersecting;</span><span class="s3">\n                    </span><span class="s1">if (this.intersecting != this.view.inView)</span><span class="s3">\n                        </span><span class="s1">this.onScrollChanged(document.createEvent(</span><span class="s3">\&quot;</span><span class="s1">Event</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}, { threshold: [0, .001] });</span><span class="s3">\n            </span><span class="s1">this.intersection.observe(this.dom);</span><span class="s3">\n            </span><span class="s1">this.gapIntersection = new IntersectionObserver(entries =&gt; {</span><span class="s3">\n                </span><span class="s1">if (entries.length &gt; 0 &amp;&amp; entries[entries.length - 1].intersectionRatio &gt; 0)</span><span class="s3">\n                    </span><span class="s1">this.onScrollChanged(document.createEvent(</span><span class="s3">\&quot;</span><span class="s1">Event</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n            </span><span class="s1">}, {});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.listenForScroll();</span><span class="s3">\n        </span><span class="s1">this.readSelectionRange();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onScrollChanged(e) {</span><span class="s3">\n        </span><span class="s1">this.view.inputState.runHandlers(</span><span class="s3">\&quot;</span><span class="s1">scroll</span><span class="s3">\&quot;</span><span class="s1">, e);</span><span class="s3">\n        </span><span class="s1">if (this.intersecting)</span><span class="s3">\n            </span><span class="s1">this.view.measure();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onScroll(e) {</span><span class="s3">\n        </span><span class="s1">if (this.intersecting)</span><span class="s3">\n            </span><span class="s1">this.flush(false);</span><span class="s3">\n        </span><span class="s1">if (this.editContext)</span><span class="s3">\n            </span><span class="s1">this.view.requestMeasure(this.editContext.measureReq);</span><span class="s3">\n        </span><span class="s1">this.onScrollChanged(e);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onResize() {</span><span class="s3">\n        </span><span class="s1">if (this.resizeTimeout &lt; 0)</span><span class="s3">\n            </span><span class="s1">this.resizeTimeout = setTimeout(() =&gt; {</span><span class="s3">\n                </span><span class="s1">this.resizeTimeout = -1;</span><span class="s3">\n                </span><span class="s1">this.view.requestMeasure();</span><span class="s3">\n            </span><span class="s1">}, 50);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onPrint(event) {</span><span class="s3">\n        </span><span class="s1">if ((event.type == </span><span class="s3">\&quot;</span><span class="s1">change</span><span class="s3">\&quot; </span><span class="s1">|| !event.type) &amp;&amp; !event.matches)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">this.view.viewState.printing = true;</span><span class="s3">\n        </span><span class="s1">this.view.measure();</span><span class="s3">\n        </span><span class="s1">setTimeout(() =&gt; {</span><span class="s3">\n            </span><span class="s1">this.view.viewState.printing = false;</span><span class="s3">\n            </span><span class="s1">this.view.requestMeasure();</span><span class="s3">\n        </span><span class="s1">}, 500);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateGaps(gaps) {</span><span class="s3">\n        </span><span class="s1">if (this.gapIntersection &amp;&amp; (gaps.length != this.gaps.length || this.gaps.some((g, i) =&gt; g != gaps[i]))) {</span><span class="s3">\n            </span><span class="s1">this.gapIntersection.disconnect();</span><span class="s3">\n            </span><span class="s1">for (let gap of gaps)</span><span class="s3">\n                </span><span class="s1">this.gapIntersection.observe(gap);</span><span class="s3">\n            </span><span class="s1">this.gaps = gaps;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onSelectionChange(event) {</span><span class="s3">\n        </span><span class="s1">let wasChanged = this.selectionChanged;</span><span class="s3">\n        </span><span class="s1">if (!this.readSelectionRange() || this.delayedAndroidKey)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">let { view } = this, sel = this.selectionRange;</span><span class="s3">\n        </span><span class="s1">if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel))</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">let context = sel.anchorNode &amp;&amp; view.docView.nearest(sel.anchorNode);</span><span class="s3">\n        </span><span class="s1">if (context &amp;&amp; context.ignoreEvent(event)) {</span><span class="s3">\n            </span><span class="s1">if (!wasChanged)</span><span class="s3">\n                </span><span class="s1">this.selectionChanged = false;</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Deletions on IE11 fire their events in the wrong order, giving</span><span class="s3">\n        </span><span class="s1">// us a selection change event before the DOM changes are</span><span class="s3">\n        </span><span class="s1">// reported.</span><span class="s3">\n        </span><span class="s1">// Chrome Android has a similar issue when backspacing out a</span><span class="s3">\n        </span><span class="s1">// selection (#645).</span><span class="s3">\n        </span><span class="s1">if ((browser.ie &amp;&amp; browser.ie_version &lt;= 11 || browser.android &amp;&amp; browser.chrome) &amp;&amp; !view.state.selection.main.empty &amp;&amp;</span><span class="s3">\n            </span><span class="s1">// (Selection.isCollapsed isn't reliable on IE)</span><span class="s3">\n            </span><span class="s1">sel.focusNode &amp;&amp; isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))</span><span class="s3">\n            </span><span class="s1">this.flushSoon();</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">this.flush(false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">readSelectionRange() {</span><span class="s3">\n        </span><span class="s1">let { view } = this;</span><span class="s3">\n        </span><span class="s1">// The Selection object is broken in shadow roots in Safari. See</span><span class="s3">\n        </span><span class="s1">// https://github.com/codemirror/dev/issues/414</span><span class="s3">\n        </span><span class="s1">let selection = getSelection(view.root);</span><span class="s3">\n        </span><span class="s1">if (!selection)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">let range = browser.safari &amp;&amp; view.root.nodeType == 11 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">view.root.activeElement == this.dom &amp;&amp;</span><span class="s3">\n            </span><span class="s1">safariSelectionRangeHack(this.view, selection) || selection;</span><span class="s3">\n        </span><span class="s1">if (!range || this.selectionRange.eq(range))</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">let local = hasSelection(this.dom, range);</span><span class="s3">\n        </span><span class="s1">// Detect the situation where the browser has, on focus, moved the</span><span class="s3">\n        </span><span class="s1">// selection to the start of the content element. Reset it to the</span><span class="s3">\n        </span><span class="s1">// position from the editor state.</span><span class="s3">\n        </span><span class="s1">if (local &amp;&amp; !this.selectionChanged &amp;&amp;</span><span class="s3">\n            </span><span class="s1">view.inputState.lastFocusTime &gt; Date.now() - 200 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">view.inputState.lastTouchTime &lt; Date.now() - 300 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">atElementStart(this.dom, range)) {</span><span class="s3">\n            </span><span class="s1">this.view.inputState.lastFocusTime = 0;</span><span class="s3">\n            </span><span class="s1">view.docView.updateSelection();</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.selectionRange.setRange(range);</span><span class="s3">\n        </span><span class="s1">if (local)</span><span class="s3">\n            </span><span class="s1">this.selectionChanged = true;</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setSelectionRange(anchor, head) {</span><span class="s3">\n        </span><span class="s1">this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);</span><span class="s3">\n        </span><span class="s1">this.selectionChanged = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">clearSelectionRange() {</span><span class="s3">\n        </span><span class="s1">this.selectionRange.set(null, 0, null, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">listenForScroll() {</span><span class="s3">\n        </span><span class="s1">this.parentCheck = -1;</span><span class="s3">\n        </span><span class="s1">let i = 0, changed = null;</span><span class="s3">\n        </span><span class="s1">for (let dom = this.dom; dom;) {</span><span class="s3">\n            </span><span class="s1">if (dom.nodeType == 1) {</span><span class="s3">\n                </span><span class="s1">if (!changed &amp;&amp; i &lt; this.scrollTargets.length &amp;&amp; this.scrollTargets[i] == dom)</span><span class="s3">\n                    </span><span class="s1">i++;</span><span class="s3">\n                </span><span class="s1">else if (!changed)</span><span class="s3">\n                    </span><span class="s1">changed = this.scrollTargets.slice(0, i);</span><span class="s3">\n                </span><span class="s1">if (changed)</span><span class="s3">\n                    </span><span class="s1">changed.push(dom);</span><span class="s3">\n                </span><span class="s1">dom = dom.assignedSlot || dom.parentNode;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (dom.nodeType == 11) { // Shadow root</span><span class="s3">\n                </span><span class="s1">dom = dom.host;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (i &lt; this.scrollTargets.length &amp;&amp; !changed)</span><span class="s3">\n            </span><span class="s1">changed = this.scrollTargets.slice(0, i);</span><span class="s3">\n        </span><span class="s1">if (changed) {</span><span class="s3">\n            </span><span class="s1">for (let dom of this.scrollTargets)</span><span class="s3">\n                </span><span class="s1">dom.removeEventListener(</span><span class="s3">\&quot;</span><span class="s1">scroll</span><span class="s3">\&quot;</span><span class="s1">, this.onScroll);</span><span class="s3">\n            </span><span class="s1">for (let dom of this.scrollTargets = changed)</span><span class="s3">\n                </span><span class="s1">dom.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">scroll</span><span class="s3">\&quot;</span><span class="s1">, this.onScroll);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ignore(f) {</span><span class="s3">\n        </span><span class="s1">if (!this.active)</span><span class="s3">\n            </span><span class="s1">return f();</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">this.stop();</span><span class="s3">\n            </span><span class="s1">return f();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">finally {</span><span class="s3">\n            </span><span class="s1">this.start();</span><span class="s3">\n            </span><span class="s1">this.clear();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">start() {</span><span class="s3">\n        </span><span class="s1">if (this.active)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">this.observer.observe(this.dom, observeOptions);</span><span class="s3">\n        </span><span class="s1">if (useCharData)</span><span class="s3">\n            </span><span class="s1">this.dom.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">DOMCharacterDataModified</span><span class="s3">\&quot;</span><span class="s1">, this.onCharData);</span><span class="s3">\n        </span><span class="s1">this.active = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">stop() {</span><span class="s3">\n        </span><span class="s1">if (!this.active)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">this.active = false;</span><span class="s3">\n        </span><span class="s1">this.observer.disconnect();</span><span class="s3">\n        </span><span class="s1">if (useCharData)</span><span class="s3">\n            </span><span class="s1">this.dom.removeEventListener(</span><span class="s3">\&quot;</span><span class="s1">DOMCharacterDataModified</span><span class="s3">\&quot;</span><span class="s1">, this.onCharData);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Throw away any pending changes</span><span class="s3">\n    </span><span class="s1">clear() {</span><span class="s3">\n        </span><span class="s1">this.processRecords();</span><span class="s3">\n        </span><span class="s1">this.queue.length = 0;</span><span class="s3">\n        </span><span class="s1">this.selectionChanged = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Chrome Android, especially in combination with GBoard, not only</span><span class="s3">\n    </span><span class="s1">// doesn't reliably fire regular key events, but also often</span><span class="s3">\n    </span><span class="s1">// surrounds the effect of enter or backspace with a bunch of</span><span class="s3">\n    </span><span class="s1">// composition events that, when interrupted, cause text duplication</span><span class="s3">\n    </span><span class="s1">// or other kinds of corruption. This hack makes the editor back off</span><span class="s3">\n    </span><span class="s1">// from handling DOM changes for a moment when such a key is</span><span class="s3">\n    </span><span class="s1">// detected (via beforeinput or keydown), and then tries to flush</span><span class="s3">\n    </span><span class="s1">// them or, if that has no effect, dispatches the given key.</span><span class="s3">\n    </span><span class="s1">delayAndroidKey(key, keyCode) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">if (!this.delayedAndroidKey) {</span><span class="s3">\n            </span><span class="s1">let flush = () =&gt; {</span><span class="s3">\n                </span><span class="s1">let key = this.delayedAndroidKey;</span><span class="s3">\n                </span><span class="s1">if (key) {</span><span class="s3">\n                    </span><span class="s1">this.clearDelayedAndroidKey();</span><span class="s3">\n                    </span><span class="s1">this.view.inputState.lastKeyCode = key.keyCode;</span><span class="s3">\n                    </span><span class="s1">this.view.inputState.lastKeyTime = Date.now();</span><span class="s3">\n                    </span><span class="s1">let flushed = this.flush();</span><span class="s3">\n                    </span><span class="s1">if (!flushed &amp;&amp; key.force)</span><span class="s3">\n                        </span><span class="s1">dispatchKey(this.dom, key.key, key.keyCode);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Since backspace beforeinput is sometimes signalled spuriously,</span><span class="s3">\n        </span><span class="s1">// Enter always takes precedence.</span><span class="s3">\n        </span><span class="s1">if (!this.delayedAndroidKey || key == </span><span class="s3">\&quot;</span><span class="s1">Enter</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">this.delayedAndroidKey = {</span><span class="s3">\n                </span><span class="s1">key, keyCode,</span><span class="s3">\n                </span><span class="s1">// Only run the key handler when no changes are detected if</span><span class="s3">\n                </span><span class="s1">// this isn't coming right after another change, in which case</span><span class="s3">\n                </span><span class="s1">// it is probably part of a weird chain of updates, and should</span><span class="s3">\n                </span><span class="s1">// be ignored if it returns the DOM to its previous state.</span><span class="s3">\n                </span><span class="s1">force: this.lastChange &lt; Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">clearDelayedAndroidKey() {</span><span class="s3">\n        </span><span class="s1">this.win.cancelAnimationFrame(this.flushingAndroidKey);</span><span class="s3">\n        </span><span class="s1">this.delayedAndroidKey = null;</span><span class="s3">\n        </span><span class="s1">this.flushingAndroidKey = -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">flushSoon() {</span><span class="s3">\n        </span><span class="s1">if (this.delayedFlush &lt; 0)</span><span class="s3">\n            </span><span class="s1">this.delayedFlush = this.view.win.requestAnimationFrame(() =&gt; { this.delayedFlush = -1; this.flush(); });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">forceFlush() {</span><span class="s3">\n        </span><span class="s1">if (this.delayedFlush &gt;= 0) {</span><span class="s3">\n            </span><span class="s1">this.view.win.cancelAnimationFrame(this.delayedFlush);</span><span class="s3">\n            </span><span class="s1">this.delayedFlush = -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.flush();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">pendingRecords() {</span><span class="s3">\n        </span><span class="s1">for (let mut of this.observer.takeRecords())</span><span class="s3">\n            </span><span class="s1">this.queue.push(mut);</span><span class="s3">\n        </span><span class="s1">return this.queue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">processRecords() {</span><span class="s3">\n        </span><span class="s1">let records = this.pendingRecords();</span><span class="s3">\n        </span><span class="s1">if (records.length)</span><span class="s3">\n            </span><span class="s1">this.queue = [];</span><span class="s3">\n        </span><span class="s1">let from = -1, to = -1, typeOver = false;</span><span class="s3">\n        </span><span class="s1">for (let record of records) {</span><span class="s3">\n            </span><span class="s1">let range = this.readMutation(record);</span><span class="s3">\n            </span><span class="s1">if (!range)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">if (range.typeOver)</span><span class="s3">\n                </span><span class="s1">typeOver = true;</span><span class="s3">\n            </span><span class="s1">if (from == -1) {</span><span class="s3">\n                </span><span class="s1">({ from, to } = range);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">from = Math.min(range.from, from);</span><span class="s3">\n                </span><span class="s1">to = Math.max(range.to, to);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { from, to, typeOver };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">readChange() {</span><span class="s3">\n        </span><span class="s1">let { from, to, typeOver } = this.processRecords();</span><span class="s3">\n        </span><span class="s1">let newSel = this.selectionChanged &amp;&amp; hasSelection(this.dom, this.selectionRange);</span><span class="s3">\n        </span><span class="s1">if (from &lt; 0 &amp;&amp; !newSel)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">if (from &gt; -1)</span><span class="s3">\n            </span><span class="s1">this.lastChange = Date.now();</span><span class="s3">\n        </span><span class="s1">this.view.inputState.lastFocusTime = 0;</span><span class="s3">\n        </span><span class="s1">this.selectionChanged = false;</span><span class="s3">\n        </span><span class="s1">let change = new DOMChange(this.view, from, to, typeOver);</span><span class="s3">\n        </span><span class="s1">this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };</span><span class="s3">\n        </span><span class="s1">return change;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Apply pending changes, if any</span><span class="s3">\n    </span><span class="s1">flush(readSelection = true) {</span><span class="s3">\n        </span><span class="s1">// Completely hold off flushing when pending keys are setthe code</span><span class="s3">\n        </span><span class="s1">// managing those will make sure processRecords is called and the</span><span class="s3">\n        </span><span class="s1">// view is resynchronized after</span><span class="s3">\n        </span><span class="s1">if (this.delayedFlush &gt;= 0 || this.delayedAndroidKey)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">if (readSelection)</span><span class="s3">\n            </span><span class="s1">this.readSelectionRange();</span><span class="s3">\n        </span><span class="s1">let domChange = this.readChange();</span><span class="s3">\n        </span><span class="s1">if (!domChange) {</span><span class="s3">\n            </span><span class="s1">this.view.requestMeasure();</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let startState = this.view.state;</span><span class="s3">\n        </span><span class="s1">let handled = applyDOMChange(this.view, domChange);</span><span class="s3">\n        </span><span class="s1">// The view wasn't updated but DOM/selection changes were seen. Reset the view.</span><span class="s3">\n        </span><span class="s1">if (this.view.state == startState &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(domChange.domChanged || domChange.newSel &amp;&amp; !domChange.newSel.main.eq(this.view.state.selection.main)))</span><span class="s3">\n            </span><span class="s1">this.view.update([]);</span><span class="s3">\n        </span><span class="s1">return handled;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">readMutation(rec) {</span><span class="s3">\n        </span><span class="s1">let cView = this.view.docView.nearest(rec.target);</span><span class="s3">\n        </span><span class="s1">if (!cView || cView.ignoreMutation(rec))</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">cView.markDirty(rec.type == </span><span class="s3">\&quot;</span><span class="s1">attributes</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (rec.type == </span><span class="s3">\&quot;</span><span class="s1">attributes</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">cView.flags |= 4 /* ViewFlag.AttrsDirty */;</span><span class="s3">\n        </span><span class="s1">if (rec.type == </span><span class="s3">\&quot;</span><span class="s1">childList</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);</span><span class="s3">\n            </span><span class="s1">let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);</span><span class="s3">\n            </span><span class="s1">return { from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,</span><span class="s3">\n                </span><span class="s1">to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd, typeOver: false };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (rec.type == </span><span class="s3">\&quot;</span><span class="s1">characterData</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setWindow(win) {</span><span class="s3">\n        </span><span class="s1">if (win != this.win) {</span><span class="s3">\n            </span><span class="s1">this.removeWindowListeners(this.win);</span><span class="s3">\n            </span><span class="s1">this.win = win;</span><span class="s3">\n            </span><span class="s1">this.addWindowListeners(this.win);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addWindowListeners(win) {</span><span class="s3">\n        </span><span class="s1">win.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">resize</span><span class="s3">\&quot;</span><span class="s1">, this.onResize);</span><span class="s3">\n        </span><span class="s1">if (this.printQuery) {</span><span class="s3">\n            </span><span class="s1">if (this.printQuery.addEventListener)</span><span class="s3">\n                </span><span class="s1">this.printQuery.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">change</span><span class="s3">\&quot;</span><span class="s1">, this.onPrint);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">this.printQuery.addListener(this.onPrint);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">win.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">beforeprint</span><span class="s3">\&quot;</span><span class="s1">, this.onPrint);</span><span class="s3">\n        </span><span class="s1">win.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">scroll</span><span class="s3">\&quot;</span><span class="s1">, this.onScroll);</span><span class="s3">\n        </span><span class="s1">win.document.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">selectionchange</span><span class="s3">\&quot;</span><span class="s1">, this.onSelectionChange);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">removeWindowListeners(win) {</span><span class="s3">\n        </span><span class="s1">win.removeEventListener(</span><span class="s3">\&quot;</span><span class="s1">scroll</span><span class="s3">\&quot;</span><span class="s1">, this.onScroll);</span><span class="s3">\n        </span><span class="s1">win.removeEventListener(</span><span class="s3">\&quot;</span><span class="s1">resize</span><span class="s3">\&quot;</span><span class="s1">, this.onResize);</span><span class="s3">\n        </span><span class="s1">if (this.printQuery) {</span><span class="s3">\n            </span><span class="s1">if (this.printQuery.removeEventListener)</span><span class="s3">\n                </span><span class="s1">this.printQuery.removeEventListener(</span><span class="s3">\&quot;</span><span class="s1">change</span><span class="s3">\&quot;</span><span class="s1">, this.onPrint);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">this.printQuery.removeListener(this.onPrint);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">win.removeEventListener(</span><span class="s3">\&quot;</span><span class="s1">beforeprint</span><span class="s3">\&quot;</span><span class="s1">, this.onPrint);</span><span class="s3">\n        </span><span class="s1">win.document.removeEventListener(</span><span class="s3">\&quot;</span><span class="s1">selectionchange</span><span class="s3">\&quot;</span><span class="s1">, this.onSelectionChange);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">if (this.editContext) {</span><span class="s3">\n            </span><span class="s1">this.editContext.update(update);</span><span class="s3">\n            </span><span class="s1">if (update.startState.facet(editable) != update.state.facet(editable))</span><span class="s3">\n                </span><span class="s1">update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">destroy() {</span><span class="s3">\n        </span><span class="s1">var _a, _b, _c;</span><span class="s3">\n        </span><span class="s1">this.stop();</span><span class="s3">\n        </span><span class="s1">(_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();</span><span class="s3">\n        </span><span class="s1">(_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();</span><span class="s3">\n        </span><span class="s1">(_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();</span><span class="s3">\n        </span><span class="s1">for (let dom of this.scrollTargets)</span><span class="s3">\n            </span><span class="s1">dom.removeEventListener(</span><span class="s3">\&quot;</span><span class="s1">scroll</span><span class="s3">\&quot;</span><span class="s1">, this.onScroll);</span><span class="s3">\n        </span><span class="s1">this.removeWindowListeners(this.win);</span><span class="s3">\n        </span><span class="s1">clearTimeout(this.parentCheck);</span><span class="s3">\n        </span><span class="s1">clearTimeout(this.resizeTimeout);</span><span class="s3">\n        </span><span class="s1">this.win.cancelAnimationFrame(this.delayedFlush);</span><span class="s3">\n        </span><span class="s1">this.win.cancelAnimationFrame(this.flushingAndroidKey);</span><span class="s3">\n        </span><span class="s1">if (this.editContext) {</span><span class="s3">\n            </span><span class="s1">this.view.contentDOM.editContext = null;</span><span class="s3">\n            </span><span class="s1">this.editContext.destroy();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findChild(cView, dom, dir) {</span><span class="s3">\n    </span><span class="s1">while (dom) {</span><span class="s3">\n        </span><span class="s1">let curView = ContentView.get(dom);</span><span class="s3">\n        </span><span class="s1">if (curView &amp;&amp; curView.parent == cView)</span><span class="s3">\n            </span><span class="s1">return curView;</span><span class="s3">\n        </span><span class="s1">let parent = dom.parentNode;</span><span class="s3">\n        </span><span class="s1">dom = parent != cView.dom ? parent : dir &gt; 0 ? dom.nextSibling : dom.previousSibling;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function buildSelectionRangeFromRange(view, range) {</span><span class="s3">\n    </span><span class="s1">let anchorNode = range.startContainer, anchorOffset = range.startOffset;</span><span class="s3">\n    </span><span class="s1">let focusNode = range.endContainer, focusOffset = range.endOffset;</span><span class="s3">\n    </span><span class="s1">let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);</span><span class="s3">\n    </span><span class="s1">// Since such a range doesn't distinguish between anchor and head,</span><span class="s3">\n    </span><span class="s1">// use a heuristic that flips it around if its end matches the</span><span class="s3">\n    </span><span class="s1">// current anchor.</span><span class="s3">\n    </span><span class="s1">if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))</span><span class="s3">\n        </span><span class="s1">[anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];</span><span class="s3">\n    </span><span class="s1">return { anchorNode, anchorOffset, focusNode, focusOffset };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Used to work around a Safari Selection/shadow DOM bug (#414)</span><span class="s3">\n</span><span class="s1">function safariSelectionRangeHack(view, selection) {</span><span class="s3">\n    </span><span class="s1">if (selection.getComposedRanges) {</span><span class="s3">\n        </span><span class="s1">let range = selection.getComposedRanges(view.root)[0];</span><span class="s3">\n        </span><span class="s1">if (range)</span><span class="s3">\n            </span><span class="s1">return buildSelectionRangeFromRange(view, range);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let found = null;</span><span class="s3">\n    </span><span class="s1">// Because Safari (at least in 2018-2021) doesn't provide regular</span><span class="s3">\n    </span><span class="s1">// access to the selection inside a shadowroot, we have to perform a</span><span class="s3">\n    </span><span class="s1">// ridiculous hack to get at itusing `execCommand` to trigger a</span><span class="s3">\n    </span><span class="s1">// `beforeInput` event so that we can read the target range from the</span><span class="s3">\n    </span><span class="s1">// event.</span><span class="s3">\n    </span><span class="s1">function read(event) {</span><span class="s3">\n        </span><span class="s1">event.preventDefault();</span><span class="s3">\n        </span><span class="s1">event.stopImmediatePropagation();</span><span class="s3">\n        </span><span class="s1">found = event.getTargetRanges()[0];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">view.contentDOM.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">beforeinput</span><span class="s3">\&quot;</span><span class="s1">, read, true);</span><span class="s3">\n    </span><span class="s1">view.dom.ownerDocument.execCommand(</span><span class="s3">\&quot;</span><span class="s1">indent</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">view.contentDOM.removeEventListener(</span><span class="s3">\&quot;</span><span class="s1">beforeinput</span><span class="s3">\&quot;</span><span class="s1">, read, true);</span><span class="s3">\n    </span><span class="s1">return found ? buildSelectionRangeFromRange(view, found) : null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class EditContextManager {</span><span class="s3">\n    </span><span class="s1">constructor(view) {</span><span class="s3">\n        </span><span class="s1">// The document window for which the text in the context is</span><span class="s3">\n        </span><span class="s1">// maintained. For large documents, this may be smaller than the</span><span class="s3">\n        </span><span class="s1">// editor document. This window always includes the selection head.</span><span class="s3">\n        </span><span class="s1">this.from = 0;</span><span class="s3">\n        </span><span class="s1">this.to = 0;</span><span class="s3">\n        </span><span class="s1">// When applying a transaction, this is used to compare the change</span><span class="s3">\n        </span><span class="s1">// made to the context content to the change in the transaction in</span><span class="s3">\n        </span><span class="s1">// order to make the minimal changes to the context (since touching</span><span class="s3">\n        </span><span class="s1">// that sometimes breaks series of multiple edits made for a single</span><span class="s3">\n        </span><span class="s1">// user action on some Android keyboards)</span><span class="s3">\n        </span><span class="s1">this.pendingContextChange = null;</span><span class="s3">\n        </span><span class="s1">this.handlers = Object.create(null);</span><span class="s3">\n        </span><span class="s1">// Kludge to work around the fact that EditContext does not respond</span><span class="s3">\n        </span><span class="s1">// well to having its content updated during a composition (see #1472)</span><span class="s3">\n        </span><span class="s1">this.composing = null;</span><span class="s3">\n        </span><span class="s1">this.resetRange(view.state);</span><span class="s3">\n        </span><span class="s1">let context = this.editContext = new window.EditContext({</span><span class="s3">\n            </span><span class="s1">text: view.state.doc.sliceString(this.from, this.to),</span><span class="s3">\n            </span><span class="s1">selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),</span><span class="s3">\n            </span><span class="s1">selectionEnd: this.toContextPos(view.state.selection.main.head)</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.handlers.textupdate = e =&gt; {</span><span class="s3">\n            </span><span class="s1">let { anchor } = view.state.selection.main;</span><span class="s3">\n            </span><span class="s1">let from = this.toEditorPos(e.updateRangeStart), to = this.toEditorPos(e.updateRangeEnd);</span><span class="s3">\n            </span><span class="s1">if (view.inputState.composing &gt;= 0 &amp;&amp; !this.composing)</span><span class="s3">\n                </span><span class="s1">this.composing = { contextBase: e.updateRangeStart, editorBase: from, drifted: false };</span><span class="s3">\n            </span><span class="s1">let change = { from, to, insert: Text.of(e.text.split(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">)) };</span><span class="s3">\n            </span><span class="s1">// If the window doesn't include the anchor, assume changes</span><span class="s3">\n            </span><span class="s1">// adjacent to a side go up to the anchor.</span><span class="s3">\n            </span><span class="s1">if (change.from == this.from &amp;&amp; anchor &lt; this.from)</span><span class="s3">\n                </span><span class="s1">change.from = anchor;</span><span class="s3">\n            </span><span class="s1">else if (change.to == this.to &amp;&amp; anchor &gt; this.to)</span><span class="s3">\n                </span><span class="s1">change.to = anchor;</span><span class="s3">\n            </span><span class="s1">// Edit contexts sometimes fire empty changes</span><span class="s3">\n            </span><span class="s1">if (change.from == change.to &amp;&amp; !change.insert.length)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">this.pendingContextChange = change;</span><span class="s3">\n            </span><span class="s1">if (!view.state.readOnly) {</span><span class="s3">\n                </span><span class="s1">let newLen = this.to - this.from + (change.to - change.from + change.insert.length);</span><span class="s3">\n                </span><span class="s1">applyDOMChangeInner(view, change, EditorSelection.single(this.toEditorPos(e.selectionStart, newLen), this.toEditorPos(e.selectionEnd, newLen)));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// If the transaction didn't flush our change, revert it so</span><span class="s3">\n            </span><span class="s1">// that the context is in sync with the editor state again.</span><span class="s3">\n            </span><span class="s1">if (this.pendingContextChange) {</span><span class="s3">\n                </span><span class="s1">this.revertPending(view.state);</span><span class="s3">\n                </span><span class="s1">this.setSelection(view.state);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this.handlers.characterboundsupdate = e =&gt; {</span><span class="s3">\n            </span><span class="s1">let rects = [], prev = null;</span><span class="s3">\n            </span><span class="s1">for (let i = this.toEditorPos(e.rangeStart), end = this.toEditorPos(e.rangeEnd); i &lt; end; i++) {</span><span class="s3">\n                </span><span class="s1">let rect = view.coordsForChar(i);</span><span class="s3">\n                </span><span class="s1">prev = (rect &amp;&amp; new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top))</span><span class="s3">\n                    </span><span class="s1">|| prev || new DOMRect;</span><span class="s3">\n                </span><span class="s1">rects.push(prev);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">context.updateCharacterBounds(e.rangeStart, rects);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this.handlers.textformatupdate = e =&gt; {</span><span class="s3">\n            </span><span class="s1">let deco = [];</span><span class="s3">\n            </span><span class="s1">for (let format of e.getTextFormats()) {</span><span class="s3">\n                </span><span class="s1">let lineStyle = format.underlineStyle, thickness = format.underlineThickness;</span><span class="s3">\n                </span><span class="s1">if (lineStyle != </span><span class="s3">\&quot;</span><span class="s1">None</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; thickness != </span><span class="s3">\&quot;</span><span class="s1">None</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                    </span><span class="s1">let from = this.toEditorPos(format.rangeStart), to = this.toEditorPos(format.rangeEnd);</span><span class="s3">\n                    </span><span class="s1">if (from &lt; to) {</span><span class="s3">\n                        </span><span class="s1">let style = `text-decoration: underline ${lineStyle == </span><span class="s3">\&quot;</span><span class="s1">Dashed</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">dashed </span><span class="s3">\&quot; </span><span class="s1">: lineStyle == </span><span class="s3">\&quot;</span><span class="s1">Squiggle</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">wavy </span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">}${thickness == </span><span class="s3">\&quot;</span><span class="s1">Thin</span><span class="s3">\&quot; </span><span class="s1">? 1 : 2}px`;</span><span class="s3">\n                        </span><span class="s1">deco.push(Decoration.mark({ attributes: { style } }).range(from, to));</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">view.dispatch({ effects: setEditContextFormatting.of(Decoration.set(deco)) });</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this.handlers.compositionstart = () =&gt; {</span><span class="s3">\n            </span><span class="s1">if (view.inputState.composing &lt; 0) {</span><span class="s3">\n                </span><span class="s1">view.inputState.composing = 0;</span><span class="s3">\n                </span><span class="s1">view.inputState.compositionFirstChange = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this.handlers.compositionend = () =&gt; {</span><span class="s3">\n            </span><span class="s1">view.inputState.composing = -1;</span><span class="s3">\n            </span><span class="s1">view.inputState.compositionFirstChange = null;</span><span class="s3">\n            </span><span class="s1">if (this.composing) {</span><span class="s3">\n                </span><span class="s1">let { drifted } = this.composing;</span><span class="s3">\n                </span><span class="s1">this.composing = null;</span><span class="s3">\n                </span><span class="s1">if (drifted)</span><span class="s3">\n                    </span><span class="s1">this.reset(view.state);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">for (let event in this.handlers)</span><span class="s3">\n            </span><span class="s1">context.addEventListener(event, this.handlers[event]);</span><span class="s3">\n        </span><span class="s1">this.measureReq = { read: view =&gt; {</span><span class="s3">\n                </span><span class="s1">this.editContext.updateControlBounds(view.contentDOM.getBoundingClientRect());</span><span class="s3">\n                </span><span class="s1">let sel = getSelection(view.root);</span><span class="s3">\n                </span><span class="s1">if (sel &amp;&amp; sel.rangeCount)</span><span class="s3">\n                    </span><span class="s1">this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());</span><span class="s3">\n            </span><span class="s1">} };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">applyEdits(update) {</span><span class="s3">\n        </span><span class="s1">let off = 0, abort = false, pending = this.pendingContextChange;</span><span class="s3">\n        </span><span class="s1">update.changes.iterChanges((fromA, toA, _fromB, _toB, insert) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (abort)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">let dLen = insert.length - (toA - fromA);</span><span class="s3">\n            </span><span class="s1">if (pending &amp;&amp; toA &gt;= pending.to) {</span><span class="s3">\n                </span><span class="s1">if (pending.from == fromA &amp;&amp; pending.to == toA &amp;&amp; pending.insert.eq(insert)) {</span><span class="s3">\n                    </span><span class="s1">pending = this.pendingContextChange = null; // Match</span><span class="s3">\n                    </span><span class="s1">off += dLen;</span><span class="s3">\n                    </span><span class="s1">this.to += dLen;</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else { // Mismatch, revert</span><span class="s3">\n                    </span><span class="s1">pending = null;</span><span class="s3">\n                    </span><span class="s1">this.revertPending(update.state);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">fromA += off;</span><span class="s3">\n            </span><span class="s1">toA += off;</span><span class="s3">\n            </span><span class="s1">if (toA &lt;= this.from) { // Before the window</span><span class="s3">\n                </span><span class="s1">this.from += dLen;</span><span class="s3">\n                </span><span class="s1">this.to += dLen;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (fromA &lt; this.to) { // Overlaps with window</span><span class="s3">\n                </span><span class="s1">if (fromA &lt; this.from || toA &gt; this.to || (this.to - this.from) + insert.length &gt; 30000 /* CxVp.MaxSize */) {</span><span class="s3">\n                    </span><span class="s1">abort = true;</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert.toString());</span><span class="s3">\n                </span><span class="s1">this.to += dLen;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">off += dLen;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">if (pending &amp;&amp; !abort)</span><span class="s3">\n            </span><span class="s1">this.revertPending(update.state);</span><span class="s3">\n        </span><span class="s1">return !abort;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">let reverted = this.pendingContextChange;</span><span class="s3">\n        </span><span class="s1">if (this.composing &amp;&amp; (this.composing.drifted || update.transactions.some(tr =&gt; !tr.isUserEvent(</span><span class="s3">\&quot;</span><span class="s1">input.type</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; tr.changes.touchesRange(this.from, this.to)))) {</span><span class="s3">\n            </span><span class="s1">this.composing.drifted = true;</span><span class="s3">\n            </span><span class="s1">this.composing.editorBase = update.changes.mapPos(this.composing.editorBase);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {</span><span class="s3">\n            </span><span class="s1">this.pendingContextChange = null;</span><span class="s3">\n            </span><span class="s1">this.reset(update.state);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (update.docChanged || update.selectionSet || reverted) {</span><span class="s3">\n            </span><span class="s1">this.setSelection(update.state);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (update.geometryChanged || update.docChanged || update.selectionSet)</span><span class="s3">\n            </span><span class="s1">update.view.requestMeasure(this.measureReq);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">resetRange(state) {</span><span class="s3">\n        </span><span class="s1">let { head } = state.selection.main;</span><span class="s3">\n        </span><span class="s1">this.from = Math.max(0, head - 10000 /* CxVp.Margin */);</span><span class="s3">\n        </span><span class="s1">this.to = Math.min(state.doc.length, head + 10000 /* CxVp.Margin */);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">reset(state) {</span><span class="s3">\n        </span><span class="s1">this.resetRange(state);</span><span class="s3">\n        </span><span class="s1">this.editContext.updateText(0, this.editContext.text.length, state.doc.sliceString(this.from, this.to));</span><span class="s3">\n        </span><span class="s1">this.setSelection(state);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">revertPending(state) {</span><span class="s3">\n        </span><span class="s1">let pending = this.pendingContextChange;</span><span class="s3">\n        </span><span class="s1">this.pendingContextChange = null;</span><span class="s3">\n        </span><span class="s1">this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setSelection(state) {</span><span class="s3">\n        </span><span class="s1">let { main } = state.selection;</span><span class="s3">\n        </span><span class="s1">let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));</span><span class="s3">\n        </span><span class="s1">let end = this.toContextPos(main.head);</span><span class="s3">\n        </span><span class="s1">if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end)</span><span class="s3">\n            </span><span class="s1">this.editContext.updateSelection(start, end);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">rangeIsValid(state) {</span><span class="s3">\n        </span><span class="s1">let { head } = state.selection.main;</span><span class="s3">\n        </span><span class="s1">return !(this.from &gt; 0 &amp;&amp; head - this.from &lt; 500 /* CxVp.MinMargin */ ||</span><span class="s3">\n            </span><span class="s1">this.to &lt; state.doc.length &amp;&amp; this.to - head &lt; 500 /* CxVp.MinMargin */ ||</span><span class="s3">\n            </span><span class="s1">this.to - this.from &gt; 10000 /* CxVp.Margin */ * 3);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toEditorPos(contextPos, clipLen = this.to - this.from) {</span><span class="s3">\n        </span><span class="s1">contextPos = Math.min(contextPos, clipLen);</span><span class="s3">\n        </span><span class="s1">let c = this.composing;</span><span class="s3">\n        </span><span class="s1">return c &amp;&amp; c.drifted ? c.editorBase + (contextPos - c.contextBase) : contextPos + this.from;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toContextPos(editorPos) {</span><span class="s3">\n        </span><span class="s1">let c = this.composing;</span><span class="s3">\n        </span><span class="s1">return c &amp;&amp; c.drifted ? c.contextBase + (editorPos - c.editorBase) : editorPos - this.from;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">destroy() {</span><span class="s3">\n        </span><span class="s1">for (let event in this.handlers)</span><span class="s3">\n            </span><span class="s1">this.editContext.removeEventListener(event, this.handlers[event]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// The editor's update state machine looks something like this:</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">//     Idle  Updating  Idle (unchecked)  Measuring  Idle</span><span class="s3">\n</span><span class="s1">//                                               </span><span class="s3">\n</span><span class="s1">//                                         Updating (measure)</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// The difference between 'Idle' and 'Idle (unchecked)' lies in</span><span class="s3">\n</span><span class="s1">// whether a layout check has been scheduled. A regular update through</span><span class="s3">\n</span><span class="s1">// the `update` method updates the DOM in a write-only fashion, and</span><span class="s3">\n</span><span class="s1">// relies on a check (scheduled with `requestAnimationFrame`) to make</span><span class="s3">\n</span><span class="s1">// sure everything is where it should be and the viewport covers the</span><span class="s3">\n</span><span class="s1">// visible code. That check continues to measure and then optionally</span><span class="s3">\n</span><span class="s1">// update until it reaches a coherent state.</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">An editor view represents the editor's user interface. It holds</span><span class="s3">\n</span><span class="s1">the editable DOM surface, and possibly other elements such as the</span><span class="s3">\n</span><span class="s1">line number gutter. It handles events and dispatches state</span><span class="s3">\n</span><span class="s1">transactions for editing actions.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class EditorView {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The current editor state.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get state() { return this.viewState.state; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">To be able to display large documents without consuming too much</span><span class="s3">\n    </span><span class="s1">memory or overloading the browser, CodeMirror only draws the</span><span class="s3">\n    </span><span class="s1">code that is visible (plus a margin around it) to the DOM. This</span><span class="s3">\n    </span><span class="s1">property tells you the extent of the current drawn viewport, in</span><span class="s3">\n    </span><span class="s1">document positions.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get viewport() { return this.viewState.viewport; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">When there are, for example, large collapsed ranges in the</span><span class="s3">\n    </span><span class="s1">viewport, its size can be a lot bigger than the actual visible</span><span class="s3">\n    </span><span class="s1">content. Thus, if you are doing something like styling the</span><span class="s3">\n    </span><span class="s1">content in the viewport, it is preferable to only do so for</span><span class="s3">\n    </span><span class="s1">these ranges, which are the subset of the viewport that is</span><span class="s3">\n    </span><span class="s1">actually drawn.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get visibleRanges() { return this.viewState.visibleRanges; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Returns false when the editor is entirely scrolled out of view</span><span class="s3">\n    </span><span class="s1">or otherwise hidden.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get inView() { return this.viewState.inView; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Indicates whether the user is currently composing text via</span><span class="s3">\n    </span><span class="s1">[IME](https://en.wikipedia.org/wiki/Input_method), and at least</span><span class="s3">\n    </span><span class="s1">one change has been made in the current composition.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get composing() { return this.inputState.composing &gt; 0; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Indicates whether the user is currently in composing state. Note</span><span class="s3">\n    </span><span class="s1">that on some platforms, like Android, this will be the case a</span><span class="s3">\n    </span><span class="s1">lot, since just putting the cursor on a word starts a</span><span class="s3">\n    </span><span class="s1">composition there.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get compositionStarted() { return this.inputState.composing &gt;= 0; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The document or shadow root that the view lives in.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get root() { return this._root; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get win() { return this.dom.ownerDocument.defaultView || window; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Construct a new view. You'll want to either provide a `parent`</span><span class="s3">\n    </span><span class="s1">option, or put `view.dom` into your document after creating a</span><span class="s3">\n    </span><span class="s1">view, so that the user can see the editor.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(config = {}) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">this.plugins = [];</span><span class="s3">\n        </span><span class="s1">this.pluginMap = new Map;</span><span class="s3">\n        </span><span class="s1">this.editorAttrs = {};</span><span class="s3">\n        </span><span class="s1">this.contentAttrs = {};</span><span class="s3">\n        </span><span class="s1">this.bidiCache = [];</span><span class="s3">\n        </span><span class="s1">this.destroyed = false;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">@internal</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.updateState = 2 /* UpdateState.Updating */;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">@internal</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.measureScheduled = -1;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">@internal</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.measureRequests = [];</span><span class="s3">\n        </span><span class="s1">this.contentDOM = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.scrollDOM = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.scrollDOM.tabIndex = -1;</span><span class="s3">\n        </span><span class="s1">this.scrollDOM.className = </span><span class="s3">\&quot;</span><span class="s1">cm-scroller</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.scrollDOM.appendChild(this.contentDOM);</span><span class="s3">\n        </span><span class="s1">this.announceDOM = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.announceDOM.className = </span><span class="s3">\&quot;</span><span class="s1">cm-announced</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.announceDOM.setAttribute(</span><span class="s3">\&quot;</span><span class="s1">aria-live</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">polite</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.dom = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.dom.appendChild(this.announceDOM);</span><span class="s3">\n        </span><span class="s1">this.dom.appendChild(this.scrollDOM);</span><span class="s3">\n        </span><span class="s1">if (config.parent)</span><span class="s3">\n            </span><span class="s1">config.parent.appendChild(this.dom);</span><span class="s3">\n        </span><span class="s1">let { dispatch } = config;</span><span class="s3">\n        </span><span class="s1">this.dispatchTransactions = config.dispatchTransactions ||</span><span class="s3">\n            </span><span class="s1">(dispatch &amp;&amp; ((trs) =&gt; trs.forEach(tr =&gt; dispatch(tr, this)))) ||</span><span class="s3">\n            </span><span class="s1">((trs) =&gt; this.update(trs));</span><span class="s3">\n        </span><span class="s1">this.dispatch = this.dispatch.bind(this);</span><span class="s3">\n        </span><span class="s1">this._root = (config.root || getRoot(config.parent) || document);</span><span class="s3">\n        </span><span class="s1">this.viewState = new ViewState(config.state || EditorState.create(config));</span><span class="s3">\n        </span><span class="s1">if (config.scrollTo &amp;&amp; config.scrollTo.is(scrollIntoView))</span><span class="s3">\n            </span><span class="s1">this.viewState.scrollTarget = config.scrollTo.value.clip(this.viewState.state);</span><span class="s3">\n        </span><span class="s1">this.plugins = this.state.facet(viewPlugin).map(spec =&gt; new PluginInstance(spec));</span><span class="s3">\n        </span><span class="s1">for (let plugin of this.plugins)</span><span class="s3">\n            </span><span class="s1">plugin.update(this);</span><span class="s3">\n        </span><span class="s1">this.observer = new DOMObserver(this);</span><span class="s3">\n        </span><span class="s1">this.inputState = new InputState(this);</span><span class="s3">\n        </span><span class="s1">this.inputState.ensureHandlers(this.plugins);</span><span class="s3">\n        </span><span class="s1">this.docView = new DocView(this);</span><span class="s3">\n        </span><span class="s1">this.mountStyles();</span><span class="s3">\n        </span><span class="s1">this.updateAttrs();</span><span class="s3">\n        </span><span class="s1">this.updateState = 0 /* UpdateState.Idle */;</span><span class="s3">\n        </span><span class="s1">this.requestMeasure();</span><span class="s3">\n        </span><span class="s1">if ((_a = document.fonts) === null || _a === void 0 ? void 0 : _a.ready)</span><span class="s3">\n            </span><span class="s1">document.fonts.ready.then(() =&gt; this.requestMeasure());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dispatch(...input) {</span><span class="s3">\n        </span><span class="s1">let trs = input.length == 1 &amp;&amp; input[0] instanceof Transaction ? input</span><span class="s3">\n            </span><span class="s1">: input.length == 1 &amp;&amp; Array.isArray(input[0]) ? input[0]</span><span class="s3">\n                </span><span class="s1">: [this.state.update(...input)];</span><span class="s3">\n        </span><span class="s1">this.dispatchTransactions(trs, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Update the view for the given array of transactions. This will</span><span class="s3">\n    </span><span class="s1">update the visible document and selection to match the state</span><span class="s3">\n    </span><span class="s1">produced by the transactions, and notify view plugins of the</span><span class="s3">\n    </span><span class="s1">change. You should usually call</span><span class="s3">\n    </span><span class="s1">[`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this</span><span class="s3">\n    </span><span class="s1">as a primitive.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">update(transactions) {</span><span class="s3">\n        </span><span class="s1">if (this.updateState != 0 /* UpdateState.Idle */)</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Calls to EditorView.update are not allowed while an update is in progress</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">let redrawn = false, attrsChanged = false, update;</span><span class="s3">\n        </span><span class="s1">let state = this.state;</span><span class="s3">\n        </span><span class="s1">for (let tr of transactions) {</span><span class="s3">\n            </span><span class="s1">if (tr.startState != state)</span><span class="s3">\n                </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Trying to update state with a transaction that doesn't start from the previous state.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">state = tr.state;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.destroyed) {</span><span class="s3">\n            </span><span class="s1">this.viewState.state = state;</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;</span><span class="s3">\n        </span><span class="s1">if (transactions.some(tr =&gt; tr.annotation(isFocusChange))) {</span><span class="s3">\n            </span><span class="s1">this.inputState.notifiedFocused = focus;</span><span class="s3">\n            </span><span class="s1">// If a focus-change transaction is being dispatched, set this update flag.</span><span class="s3">\n            </span><span class="s1">focusFlag = 1 /* UpdateFlag.Focus */;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (focus != this.inputState.notifiedFocused) {</span><span class="s3">\n            </span><span class="s1">this.inputState.notifiedFocused = focus;</span><span class="s3">\n            </span><span class="s1">// Schedule a separate focus transaction if necessary, otherwise</span><span class="s3">\n            </span><span class="s1">// add a flag to this update</span><span class="s3">\n            </span><span class="s1">dispatchFocus = focusChangeTransaction(state, focus);</span><span class="s3">\n            </span><span class="s1">if (!dispatchFocus)</span><span class="s3">\n                </span><span class="s1">focusFlag = 1 /* UpdateFlag.Focus */;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// If there was a pending DOM change, eagerly read it and try to</span><span class="s3">\n        </span><span class="s1">// apply it after the given transactions.</span><span class="s3">\n        </span><span class="s1">let pendingKey = this.observer.delayedAndroidKey, domChange = null;</span><span class="s3">\n        </span><span class="s1">if (pendingKey) {</span><span class="s3">\n            </span><span class="s1">this.observer.clearDelayedAndroidKey();</span><span class="s3">\n            </span><span class="s1">domChange = this.observer.readChange();</span><span class="s3">\n            </span><span class="s1">// Only try to apply DOM changes if the transactions didn't</span><span class="s3">\n            </span><span class="s1">// change the doc or selection.</span><span class="s3">\n            </span><span class="s1">if (domChange &amp;&amp; !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))</span><span class="s3">\n                </span><span class="s1">domChange = null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.observer.clear();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// When the phrases change, redraw the editor</span><span class="s3">\n        </span><span class="s1">if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))</span><span class="s3">\n            </span><span class="s1">return this.setState(state);</span><span class="s3">\n        </span><span class="s1">update = ViewUpdate.create(this, state, transactions);</span><span class="s3">\n        </span><span class="s1">update.flags |= focusFlag;</span><span class="s3">\n        </span><span class="s1">let scrollTarget = this.viewState.scrollTarget;</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">this.updateState = 2 /* UpdateState.Updating */;</span><span class="s3">\n            </span><span class="s1">for (let tr of transactions) {</span><span class="s3">\n                </span><span class="s1">if (scrollTarget)</span><span class="s3">\n                    </span><span class="s1">scrollTarget = scrollTarget.map(tr.changes);</span><span class="s3">\n                </span><span class="s1">if (tr.scrollIntoView) {</span><span class="s3">\n                    </span><span class="s1">let { main } = tr.state.selection;</span><span class="s3">\n                    </span><span class="s1">scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head &gt; main.anchor ? -1 : 1));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">for (let e of tr.effects)</span><span class="s3">\n                    </span><span class="s1">if (e.is(scrollIntoView))</span><span class="s3">\n                        </span><span class="s1">scrollTarget = e.value.clip(this.state);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.viewState.update(update, scrollTarget);</span><span class="s3">\n            </span><span class="s1">this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);</span><span class="s3">\n            </span><span class="s1">if (!update.empty) {</span><span class="s3">\n                </span><span class="s1">this.updatePlugins(update);</span><span class="s3">\n                </span><span class="s1">this.inputState.update(update);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">redrawn = this.docView.update(update);</span><span class="s3">\n            </span><span class="s1">if (this.state.facet(styleModule) != this.styleModules)</span><span class="s3">\n                </span><span class="s1">this.mountStyles();</span><span class="s3">\n            </span><span class="s1">attrsChanged = this.updateAttrs();</span><span class="s3">\n            </span><span class="s1">this.showAnnouncements(transactions);</span><span class="s3">\n            </span><span class="s1">this.docView.updateSelection(redrawn, transactions.some(tr =&gt; tr.isUserEvent(</span><span class="s3">\&quot;</span><span class="s1">select.pointer</span><span class="s3">\&quot;</span><span class="s1">)));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">finally {</span><span class="s3">\n            </span><span class="s1">this.updateState = 0 /* UpdateState.Idle */;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (update.startState.facet(theme) != update.state.facet(theme))</span><span class="s3">\n            </span><span class="s1">this.viewState.mustMeasureContent = true;</span><span class="s3">\n        </span><span class="s1">if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)</span><span class="s3">\n            </span><span class="s1">this.requestMeasure();</span><span class="s3">\n        </span><span class="s1">if (redrawn)</span><span class="s3">\n            </span><span class="s1">this.docViewUpdate();</span><span class="s3">\n        </span><span class="s1">if (!update.empty)</span><span class="s3">\n            </span><span class="s1">for (let listener of this.state.facet(updateListener)) {</span><span class="s3">\n                </span><span class="s1">try {</span><span class="s3">\n                    </span><span class="s1">listener(update);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">catch (e) {</span><span class="s3">\n                    </span><span class="s1">logException(this.state, e, </span><span class="s3">\&quot;</span><span class="s1">update listener</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (dispatchFocus || domChange)</span><span class="s3">\n            </span><span class="s1">Promise.resolve().then(() =&gt; {</span><span class="s3">\n                </span><span class="s1">if (dispatchFocus &amp;&amp; this.state == dispatchFocus.startState)</span><span class="s3">\n                    </span><span class="s1">this.dispatch(dispatchFocus);</span><span class="s3">\n                </span><span class="s1">if (domChange) {</span><span class="s3">\n                    </span><span class="s1">if (!applyDOMChange(this, domChange) &amp;&amp; pendingKey.force)</span><span class="s3">\n                        </span><span class="s1">dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Reset the view to the given state. (This will cause the entire</span><span class="s3">\n    </span><span class="s1">document to be redrawn and all view plugins to be reinitialized,</span><span class="s3">\n    </span><span class="s1">so you should probably only use it when the new state isn't</span><span class="s3">\n    </span><span class="s1">derived from the old state. Otherwise, use</span><span class="s3">\n    </span><span class="s1">[`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">setState(newState) {</span><span class="s3">\n        </span><span class="s1">if (this.updateState != 0 /* UpdateState.Idle */)</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Calls to EditorView.setState are not allowed while an update is in progress</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (this.destroyed) {</span><span class="s3">\n            </span><span class="s1">this.viewState.state = newState;</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.updateState = 2 /* UpdateState.Updating */;</span><span class="s3">\n        </span><span class="s1">let hadFocus = this.hasFocus;</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">for (let plugin of this.plugins)</span><span class="s3">\n                </span><span class="s1">plugin.destroy(this);</span><span class="s3">\n            </span><span class="s1">this.viewState = new ViewState(newState);</span><span class="s3">\n            </span><span class="s1">this.plugins = newState.facet(viewPlugin).map(spec =&gt; new PluginInstance(spec));</span><span class="s3">\n            </span><span class="s1">this.pluginMap.clear();</span><span class="s3">\n            </span><span class="s1">for (let plugin of this.plugins)</span><span class="s3">\n                </span><span class="s1">plugin.update(this);</span><span class="s3">\n            </span><span class="s1">this.docView.destroy();</span><span class="s3">\n            </span><span class="s1">this.docView = new DocView(this);</span><span class="s3">\n            </span><span class="s1">this.inputState.ensureHandlers(this.plugins);</span><span class="s3">\n            </span><span class="s1">this.mountStyles();</span><span class="s3">\n            </span><span class="s1">this.updateAttrs();</span><span class="s3">\n            </span><span class="s1">this.bidiCache = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">finally {</span><span class="s3">\n            </span><span class="s1">this.updateState = 0 /* UpdateState.Idle */;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (hadFocus)</span><span class="s3">\n            </span><span class="s1">this.focus();</span><span class="s3">\n        </span><span class="s1">this.requestMeasure();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updatePlugins(update) {</span><span class="s3">\n        </span><span class="s1">let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);</span><span class="s3">\n        </span><span class="s1">if (prevSpecs != specs) {</span><span class="s3">\n            </span><span class="s1">let newPlugins = [];</span><span class="s3">\n            </span><span class="s1">for (let spec of specs) {</span><span class="s3">\n                </span><span class="s1">let found = prevSpecs.indexOf(spec);</span><span class="s3">\n                </span><span class="s1">if (found &lt; 0) {</span><span class="s3">\n                    </span><span class="s1">newPlugins.push(new PluginInstance(spec));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">let plugin = this.plugins[found];</span><span class="s3">\n                    </span><span class="s1">plugin.mustUpdate = update;</span><span class="s3">\n                    </span><span class="s1">newPlugins.push(plugin);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">for (let plugin of this.plugins)</span><span class="s3">\n                </span><span class="s1">if (plugin.mustUpdate != update)</span><span class="s3">\n                    </span><span class="s1">plugin.destroy(this);</span><span class="s3">\n            </span><span class="s1">this.plugins = newPlugins;</span><span class="s3">\n            </span><span class="s1">this.pluginMap.clear();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">for (let p of this.plugins)</span><span class="s3">\n                </span><span class="s1">p.mustUpdate = update;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.plugins.length; i++)</span><span class="s3">\n            </span><span class="s1">this.plugins[i].update(this);</span><span class="s3">\n        </span><span class="s1">if (prevSpecs != specs)</span><span class="s3">\n            </span><span class="s1">this.inputState.ensureHandlers(this.plugins);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">docViewUpdate() {</span><span class="s3">\n        </span><span class="s1">for (let plugin of this.plugins) {</span><span class="s3">\n            </span><span class="s1">let val = plugin.value;</span><span class="s3">\n            </span><span class="s1">if (val &amp;&amp; val.docViewUpdate) {</span><span class="s3">\n                </span><span class="s1">try {</span><span class="s3">\n                    </span><span class="s1">val.docViewUpdate(this);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">catch (e) {</span><span class="s3">\n                    </span><span class="s1">logException(this.state, e, </span><span class="s3">\&quot;</span><span class="s1">doc view update listener</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">measure(flush = true) {</span><span class="s3">\n        </span><span class="s1">if (this.destroyed)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">if (this.measureScheduled &gt; -1)</span><span class="s3">\n            </span><span class="s1">this.win.cancelAnimationFrame(this.measureScheduled);</span><span class="s3">\n        </span><span class="s1">if (this.observer.delayedAndroidKey) {</span><span class="s3">\n            </span><span class="s1">this.measureScheduled = -1;</span><span class="s3">\n            </span><span class="s1">this.requestMeasure();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.measureScheduled = 0; // Prevent requestMeasure calls from scheduling another animation frame</span><span class="s3">\n        </span><span class="s1">if (flush)</span><span class="s3">\n            </span><span class="s1">this.observer.forceFlush();</span><span class="s3">\n        </span><span class="s1">let updated = null;</span><span class="s3">\n        </span><span class="s1">let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;</span><span class="s3">\n        </span><span class="s1">let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;</span><span class="s3">\n        </span><span class="s1">if (Math.abs(scrollTop - this.viewState.scrollTop) &gt; 1)</span><span class="s3">\n            </span><span class="s1">scrollAnchorHeight = -1;</span><span class="s3">\n        </span><span class="s1">this.viewState.scrollAnchorHeight = -1;</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">for (let i = 0;; i++) {</span><span class="s3">\n                </span><span class="s1">if (scrollAnchorHeight &lt; 0) {</span><span class="s3">\n                    </span><span class="s1">if (isScrolledToBottom(sDOM)) {</span><span class="s3">\n                        </span><span class="s1">scrollAnchorPos = -1;</span><span class="s3">\n                        </span><span class="s1">scrollAnchorHeight = this.viewState.heightMap.height;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">let block = this.viewState.scrollAnchorAt(scrollTop);</span><span class="s3">\n                        </span><span class="s1">scrollAnchorPos = block.from;</span><span class="s3">\n                        </span><span class="s1">scrollAnchorHeight = block.top;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">this.updateState = 1 /* UpdateState.Measuring */;</span><span class="s3">\n                </span><span class="s1">let changed = this.viewState.measure(this);</span><span class="s3">\n                </span><span class="s1">if (!changed &amp;&amp; !this.measureRequests.length &amp;&amp; this.viewState.scrollTarget == null)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">if (i &gt; 5) {</span><span class="s3">\n                    </span><span class="s1">console.warn(this.measureRequests.length</span><span class="s3">\n                        </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">Measure loop restarted more than 5 times</span><span class="s3">\&quot;\n                        </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">Viewport failed to stabilize</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">let measuring = [];</span><span class="s3">\n                </span><span class="s1">// Only run measure requests in this cycle when the viewport didn't change</span><span class="s3">\n                </span><span class="s1">if (!(changed &amp; 4 /* UpdateFlag.Viewport */))</span><span class="s3">\n                    </span><span class="s1">[this.measureRequests, measuring] = [measuring, this.measureRequests];</span><span class="s3">\n                </span><span class="s1">let measured = measuring.map(m =&gt; {</span><span class="s3">\n                    </span><span class="s1">try {</span><span class="s3">\n                        </span><span class="s1">return m.read(this);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">catch (e) {</span><span class="s3">\n                        </span><span class="s1">logException(this.state, e);</span><span class="s3">\n                        </span><span class="s1">return BadMeasure;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">let update = ViewUpdate.create(this, this.state, []), redrawn = false;</span><span class="s3">\n                </span><span class="s1">update.flags |= changed;</span><span class="s3">\n                </span><span class="s1">if (!updated)</span><span class="s3">\n                    </span><span class="s1">updated = update;</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">updated.flags |= changed;</span><span class="s3">\n                </span><span class="s1">this.updateState = 2 /* UpdateState.Updating */;</span><span class="s3">\n                </span><span class="s1">if (!update.empty) {</span><span class="s3">\n                    </span><span class="s1">this.updatePlugins(update);</span><span class="s3">\n                    </span><span class="s1">this.inputState.update(update);</span><span class="s3">\n                    </span><span class="s1">this.updateAttrs();</span><span class="s3">\n                    </span><span class="s1">redrawn = this.docView.update(update);</span><span class="s3">\n                    </span><span class="s1">if (redrawn)</span><span class="s3">\n                        </span><span class="s1">this.docViewUpdate();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">for (let i = 0; i &lt; measuring.length; i++)</span><span class="s3">\n                    </span><span class="s1">if (measured[i] != BadMeasure) {</span><span class="s3">\n                        </span><span class="s1">try {</span><span class="s3">\n                            </span><span class="s1">let m = measuring[i];</span><span class="s3">\n                            </span><span class="s1">if (m.write)</span><span class="s3">\n                                </span><span class="s1">m.write(measured[i], this);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">catch (e) {</span><span class="s3">\n                            </span><span class="s1">logException(this.state, e);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (redrawn)</span><span class="s3">\n                    </span><span class="s1">this.docView.updateSelection(true);</span><span class="s3">\n                </span><span class="s1">if (!update.viewportChanged &amp;&amp; this.measureRequests.length == 0) {</span><span class="s3">\n                    </span><span class="s1">if (this.viewState.editorHeight) {</span><span class="s3">\n                        </span><span class="s1">if (this.viewState.scrollTarget) {</span><span class="s3">\n                            </span><span class="s1">this.docView.scrollIntoView(this.viewState.scrollTarget);</span><span class="s3">\n                            </span><span class="s1">this.viewState.scrollTarget = null;</span><span class="s3">\n                            </span><span class="s1">scrollAnchorHeight = -1;</span><span class="s3">\n                            </span><span class="s1">continue;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">else {</span><span class="s3">\n                            </span><span class="s1">let newAnchorHeight = scrollAnchorPos &lt; 0 ? this.viewState.heightMap.height :</span><span class="s3">\n                                </span><span class="s1">this.viewState.lineBlockAt(scrollAnchorPos).top;</span><span class="s3">\n                            </span><span class="s1">let diff = newAnchorHeight - scrollAnchorHeight;</span><span class="s3">\n                            </span><span class="s1">if (diff &gt; 1 || diff &lt; -1) {</span><span class="s3">\n                                </span><span class="s1">scrollTop = scrollTop + diff;</span><span class="s3">\n                                </span><span class="s1">sDOM.scrollTop = scrollTop / this.scaleY;</span><span class="s3">\n                                </span><span class="s1">scrollAnchorHeight = -1;</span><span class="s3">\n                                </span><span class="s1">continue;</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">finally {</span><span class="s3">\n            </span><span class="s1">this.updateState = 0 /* UpdateState.Idle */;</span><span class="s3">\n            </span><span class="s1">this.measureScheduled = -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (updated &amp;&amp; !updated.empty)</span><span class="s3">\n            </span><span class="s1">for (let listener of this.state.facet(updateListener))</span><span class="s3">\n                </span><span class="s1">listener(updated);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the CSS classes for the currently active editor themes.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get themeClasses() {</span><span class="s3">\n        </span><span class="s1">return baseThemeID + </span><span class="s3">\&quot; \&quot; </span><span class="s1">+</span><span class="s3">\n            </span><span class="s1">(this.state.facet(darkTheme) ? baseDarkID : baseLightID) + </span><span class="s3">\&quot; \&quot; </span><span class="s1">+</span><span class="s3">\n            </span><span class="s1">this.state.facet(theme);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateAttrs() {</span><span class="s3">\n        </span><span class="s1">let editorAttrs = attrsFromFacet(this, editorAttributes, {</span><span class="s3">\n            </span><span class="s1">class: </span><span class="s3">\&quot;</span><span class="s1">cm-editor</span><span class="s3">\&quot; </span><span class="s1">+ (this.hasFocus ? </span><span class="s3">\&quot; </span><span class="s1">cm-focused </span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot; \&quot;</span><span class="s1">) + this.themeClasses</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">let contentAttrs = {</span><span class="s3">\n            </span><span class="s1">spellcheck: </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">autocorrect: </span><span class="s3">\&quot;</span><span class="s1">off</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">autocapitalize: </span><span class="s3">\&quot;</span><span class="s1">off</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">writingsuggestions: </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">translate: </span><span class="s3">\&quot;</span><span class="s1">no</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">contenteditable: !this.state.facet(editable) ? </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">class: </span><span class="s3">\&quot;</span><span class="s1">cm-content</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">style: `${browser.tabSize}: ${this.state.tabSize}`,</span><span class="s3">\n            </span><span class="s1">role: </span><span class="s3">\&quot;</span><span class="s1">textbox</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">aria-multiline</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (this.state.readOnly)</span><span class="s3">\n            </span><span class="s1">contentAttrs[</span><span class="s3">\&quot;</span><span class="s1">aria-readonly</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">attrsFromFacet(this, contentAttributes, contentAttrs);</span><span class="s3">\n        </span><span class="s1">let changed = this.observer.ignore(() =&gt; {</span><span class="s3">\n            </span><span class="s1">let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);</span><span class="s3">\n            </span><span class="s1">let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);</span><span class="s3">\n            </span><span class="s1">return changedContent || changedEditor;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.editorAttrs = editorAttrs;</span><span class="s3">\n        </span><span class="s1">this.contentAttrs = contentAttrs;</span><span class="s3">\n        </span><span class="s1">return changed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">showAnnouncements(trs) {</span><span class="s3">\n        </span><span class="s1">let first = true;</span><span class="s3">\n        </span><span class="s1">for (let tr of trs)</span><span class="s3">\n            </span><span class="s1">for (let effect of tr.effects)</span><span class="s3">\n                </span><span class="s1">if (effect.is(EditorView.announce)) {</span><span class="s3">\n                    </span><span class="s1">if (first)</span><span class="s3">\n                        </span><span class="s1">this.announceDOM.textContent = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n                    </span><span class="s1">first = false;</span><span class="s3">\n                    </span><span class="s1">let div = this.announceDOM.appendChild(document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n                    </span><span class="s1">div.textContent = effect.value;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mountStyles() {</span><span class="s3">\n        </span><span class="s1">this.styleModules = this.state.facet(styleModule);</span><span class="s3">\n        </span><span class="s1">let nonce = this.state.facet(EditorView.cspNonce);</span><span class="s3">\n        </span><span class="s1">StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : undefined);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">readMeasured() {</span><span class="s3">\n        </span><span class="s1">if (this.updateState == 2 /* UpdateState.Updating */)</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Reading the editor layout isn't allowed during an update</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (this.updateState == 0 /* UpdateState.Idle */ &amp;&amp; this.measureScheduled &gt; -1)</span><span class="s3">\n            </span><span class="s1">this.measure(false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Schedule a layout measurement, optionally providing callbacks to</span><span class="s3">\n    </span><span class="s1">do custom DOM measuring followed by a DOM write phase. Using</span><span class="s3">\n    </span><span class="s1">this is preferable reading DOM layout directly from, for</span><span class="s3">\n    </span><span class="s1">example, an event handler, because it'll make sure measuring and</span><span class="s3">\n    </span><span class="s1">drawing done by other components is synchronized, avoiding</span><span class="s3">\n    </span><span class="s1">unnecessary DOM layout computations.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">requestMeasure(request) {</span><span class="s3">\n        </span><span class="s1">if (this.measureScheduled &lt; 0)</span><span class="s3">\n            </span><span class="s1">this.measureScheduled = this.win.requestAnimationFrame(() =&gt; this.measure());</span><span class="s3">\n        </span><span class="s1">if (request) {</span><span class="s3">\n            </span><span class="s1">if (this.measureRequests.indexOf(request) &gt; -1)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">if (request.key != null)</span><span class="s3">\n                </span><span class="s1">for (let i = 0; i &lt; this.measureRequests.length; i++) {</span><span class="s3">\n                    </span><span class="s1">if (this.measureRequests[i].key === request.key) {</span><span class="s3">\n                        </span><span class="s1">this.measureRequests[i] = request;</span><span class="s3">\n                        </span><span class="s1">return;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.measureRequests.push(request);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the value of a specific plugin, if present. Note that</span><span class="s3">\n    </span><span class="s1">plugins that crash can be dropped from a view, so even when you</span><span class="s3">\n    </span><span class="s1">know you registered a given plugin, it is recommended to check</span><span class="s3">\n    </span><span class="s1">the return value of this method.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">plugin(plugin) {</span><span class="s3">\n        </span><span class="s1">let known = this.pluginMap.get(plugin);</span><span class="s3">\n        </span><span class="s1">if (known === undefined || known &amp;&amp; known.spec != plugin)</span><span class="s3">\n            </span><span class="s1">this.pluginMap.set(plugin, known = this.plugins.find(p =&gt; p.spec == plugin) || null);</span><span class="s3">\n        </span><span class="s1">return known &amp;&amp; known.update(this).value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The top position of the document, in screen coordinates. This</span><span class="s3">\n    </span><span class="s1">may be negative when the editor is scrolled down. Points</span><span class="s3">\n    </span><span class="s1">directly to the top of the first line, not above the padding.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get documentTop() {</span><span class="s3">\n        </span><span class="s1">return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Reports the padding above and below the document.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get documentPadding() {</span><span class="s3">\n        </span><span class="s1">return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">If the editor is transformed with CSS, this provides the scale</span><span class="s3">\n    </span><span class="s1">along the X axis. Otherwise, it will just be 1. Note that</span><span class="s3">\n    </span><span class="s1">transforms other than translation and scaling are not supported.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get scaleX() { return this.viewState.scaleX; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Provide the CSS transformed scale along the Y axis.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get scaleY() { return this.viewState.scaleY; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Find the text line or block widget at the given vertical</span><span class="s3">\n    </span><span class="s1">position (which is interpreted as relative to the [top of the</span><span class="s3">\n    </span><span class="s1">document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">elementAtHeight(height) {</span><span class="s3">\n        </span><span class="s1">this.readMeasured();</span><span class="s3">\n        </span><span class="s1">return this.viewState.elementAtHeight(height);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Find the line block (see</span><span class="s3">\n    </span><span class="s1">[`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given</span><span class="s3">\n    </span><span class="s1">height, again interpreted relative to the [top of the</span><span class="s3">\n    </span><span class="s1">document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">lineBlockAtHeight(height) {</span><span class="s3">\n        </span><span class="s1">this.readMeasured();</span><span class="s3">\n        </span><span class="s1">return this.viewState.lineBlockAtHeight(height);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the extent and vertical position of all [line</span><span class="s3">\n    </span><span class="s1">blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions</span><span class="s3">\n    </span><span class="s1">are relative to the [top of the</span><span class="s3">\n    </span><span class="s1">document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get viewportLineBlocks() {</span><span class="s3">\n        </span><span class="s1">return this.viewState.viewportLines;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Find the line block around the given document position. A line</span><span class="s3">\n    </span><span class="s1">block is a range delimited on both sides by either a</span><span class="s3">\n    </span><span class="s1">non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the</span><span class="s3">\n    </span><span class="s1">start/end of the document. It will usually just hold a line of</span><span class="s3">\n    </span><span class="s1">text, but may be broken into multiple textblocks by block</span><span class="s3">\n    </span><span class="s1">widgets.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">lineBlockAt(pos) {</span><span class="s3">\n        </span><span class="s1">return this.viewState.lineBlockAt(pos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The editor's total content height.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get contentHeight() {</span><span class="s3">\n        </span><span class="s1">return this.viewState.contentHeight;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Move a cursor position by [grapheme</span><span class="s3">\n    </span><span class="s1">cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether</span><span class="s3">\n    </span><span class="s1">the motion is away from the line start, or towards it. In</span><span class="s3">\n    </span><span class="s1">bidirectional text, the line is traversed in visual order, using</span><span class="s3">\n    </span><span class="s1">the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).</span><span class="s3">\n    </span><span class="s1">When the start position was the last one on the line, the</span><span class="s3">\n    </span><span class="s1">returned position will be across the line break. If there is no</span><span class="s3">\n    </span><span class="s1">further line, the original position is returned.</span><span class="s3">\n    \n    </span><span class="s1">By default, this method moves over a single cluster. The</span><span class="s3">\n    </span><span class="s1">optional `by` argument can be used to move across more. It will</span><span class="s3">\n    </span><span class="s1">be called with the first cluster as argument, and should return</span><span class="s3">\n    </span><span class="s1">a predicate that determines, for each subsequent cluster,</span><span class="s3">\n    </span><span class="s1">whether it should also be moved over.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">moveByChar(start, forward, by) {</span><span class="s3">\n        </span><span class="s1">return skipAtoms(this, start, moveByChar(this, start, forward, by));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Move a cursor position across the next group of either</span><span class="s3">\n    </span><span class="s1">[letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter</span><span class="s3">\n    </span><span class="s1">non-whitespace characters.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">moveByGroup(start, forward) {</span><span class="s3">\n        </span><span class="s1">return skipAtoms(this, start, moveByChar(this, start, forward, initial =&gt; byGroup(this, start.head, initial)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the cursor position visually at the start or end of a line.</span><span class="s3">\n    </span><span class="s1">Note that this may differ from the _logical_ position at its</span><span class="s3">\n    </span><span class="s1">start or end (which is simply at `line.from`/`line.to`) if text</span><span class="s3">\n    </span><span class="s1">at the start or end goes against the line's base text direction.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">visualLineSide(line, end) {</span><span class="s3">\n        </span><span class="s1">let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);</span><span class="s3">\n        </span><span class="s1">let span = order[end ? order.length - 1 : 0];</span><span class="s3">\n        </span><span class="s1">return EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Move to the next line boundary in the given direction. If</span><span class="s3">\n    </span><span class="s1">`includeWrap` is true, line wrapping is on, and there is a</span><span class="s3">\n    </span><span class="s1">further wrap point on the current line, the wrap point will be</span><span class="s3">\n    </span><span class="s1">returned. Otherwise this function will return the start or end</span><span class="s3">\n    </span><span class="s1">of the line.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">moveToLineBoundary(start, forward, includeWrap = true) {</span><span class="s3">\n        </span><span class="s1">return moveToLineBoundary(this, start, forward, includeWrap);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Move a cursor position vertically. When `distance` isn't given,</span><span class="s3">\n    </span><span class="s1">it defaults to moving to the next line (including wrapped</span><span class="s3">\n    </span><span class="s1">lines). Otherwise, `distance` should provide a positive distance</span><span class="s3">\n    </span><span class="s1">in pixels.</span><span class="s3">\n    \n    </span><span class="s1">When `start` has a</span><span class="s3">\n    </span><span class="s1">[`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical</span><span class="s3">\n    </span><span class="s1">motion will use that as a target horizontal position. Otherwise,</span><span class="s3">\n    </span><span class="s1">the cursor's own horizontal position is used. The returned</span><span class="s3">\n    </span><span class="s1">cursor will have its goal column set to whichever column was</span><span class="s3">\n    </span><span class="s1">used.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">moveVertically(start, forward, distance) {</span><span class="s3">\n        </span><span class="s1">return skipAtoms(this, start, moveVertically(this, start, forward, distance));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Find the DOM parent node and offset (child offset if `node` is</span><span class="s3">\n    </span><span class="s1">an element, character offset when it is a text node) at the</span><span class="s3">\n    </span><span class="s1">given document position.</span><span class="s3">\n    \n    </span><span class="s1">Note that for positions that aren't currently in</span><span class="s3">\n    </span><span class="s1">`visibleRanges`, the resulting DOM position isn't necessarily</span><span class="s3">\n    </span><span class="s1">meaningful (it may just point before or after a placeholder</span><span class="s3">\n    </span><span class="s1">element).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">domAtPos(pos) {</span><span class="s3">\n        </span><span class="s1">return this.docView.domAtPos(pos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Find the document position at the given DOM node. Can be useful</span><span class="s3">\n    </span><span class="s1">for associating positions with DOM events. Will raise an error</span><span class="s3">\n    </span><span class="s1">when `node` isn't part of the editor content.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">posAtDOM(node, offset = 0) {</span><span class="s3">\n        </span><span class="s1">return this.docView.posFromDOM(node, offset);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">posAtCoords(coords, precise = true) {</span><span class="s3">\n        </span><span class="s1">this.readMeasured();</span><span class="s3">\n        </span><span class="s1">return posAtCoords(this, coords, precise);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the screen coordinates at the given document position.</span><span class="s3">\n    </span><span class="s1">`side` determines whether the coordinates are based on the</span><span class="s3">\n    </span><span class="s1">element before (-1) or after (1) the position (if no element is</span><span class="s3">\n    </span><span class="s1">available on the given side, the method will transparently use</span><span class="s3">\n    </span><span class="s1">another strategy to get reasonable coordinates).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">coordsAtPos(pos, side = 1) {</span><span class="s3">\n        </span><span class="s1">this.readMeasured();</span><span class="s3">\n        </span><span class="s1">let rect = this.docView.coordsAt(pos, side);</span><span class="s3">\n        </span><span class="s1">if (!rect || rect.left == rect.right)</span><span class="s3">\n            </span><span class="s1">return rect;</span><span class="s3">\n        </span><span class="s1">let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);</span><span class="s3">\n        </span><span class="s1">let span = order[BidiSpan.find(order, pos - line.from, -1, side)];</span><span class="s3">\n        </span><span class="s1">return flattenRect(rect, (span.dir == Direction.LTR) == (side &gt; 0));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Return the rectangle around a given character. If `pos` does not</span><span class="s3">\n    </span><span class="s1">point in front of a character that is in the viewport and</span><span class="s3">\n    </span><span class="s1">rendered (i.e. not replaced, not a line break), this will return</span><span class="s3">\n    </span><span class="s1">null. For space characters that are a line wrap point, this will</span><span class="s3">\n    </span><span class="s1">return the position before the line break.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">coordsForChar(pos) {</span><span class="s3">\n        </span><span class="s1">this.readMeasured();</span><span class="s3">\n        </span><span class="s1">return this.docView.coordsForChar(pos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The default width of a character in the editor. May not</span><span class="s3">\n    </span><span class="s1">accurately reflect the width of all characters (given variable</span><span class="s3">\n    </span><span class="s1">width fonts or styling of invididual ranges).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get defaultCharacterWidth() { return this.viewState.heightOracle.charWidth; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The default height of a line in the editor. May not be accurate</span><span class="s3">\n    </span><span class="s1">for all lines.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get defaultLineHeight() { return this.viewState.heightOracle.lineHeight; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The text direction</span><span class="s3">\n    </span><span class="s1">([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)</span><span class="s3">\n    </span><span class="s1">CSS property) of the editor's content element.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get textDirection() { return this.viewState.defaultTextDirection; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Find the text direction of the block at the given position, as</span><span class="s3">\n    </span><span class="s1">assigned by CSS. If</span><span class="s3">\n    </span><span class="s1">[`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)</span><span class="s3">\n    </span><span class="s1">isn't enabled, or the given position is outside of the viewport,</span><span class="s3">\n    </span><span class="s1">this will always return the same as</span><span class="s3">\n    </span><span class="s1">[`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that</span><span class="s3">\n    </span><span class="s1">this may trigger a DOM layout.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">textDirectionAt(pos) {</span><span class="s3">\n        </span><span class="s1">let perLine = this.state.facet(perLineTextDirection);</span><span class="s3">\n        </span><span class="s1">if (!perLine || pos &lt; this.viewport.from || pos &gt; this.viewport.to)</span><span class="s3">\n            </span><span class="s1">return this.textDirection;</span><span class="s3">\n        </span><span class="s1">this.readMeasured();</span><span class="s3">\n        </span><span class="s1">return this.docView.textDirectionAt(pos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)</span><span class="s3">\n    </span><span class="s1">(as determined by the</span><span class="s3">\n    </span><span class="s1">[`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)</span><span class="s3">\n    </span><span class="s1">CSS property of its content element).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get lineWrapping() { return this.viewState.heightOracle.lineWrapping; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Returns the bidirectional text structure of the given line</span><span class="s3">\n    </span><span class="s1">(which should be in the current document) as an array of span</span><span class="s3">\n    </span><span class="s1">objects. The order of these spans matches the [text</span><span class="s3">\n    </span><span class="s1">direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is</span><span class="s3">\n    </span><span class="s1">left-to-right, the leftmost spans come first, otherwise the</span><span class="s3">\n    </span><span class="s1">rightmost spans come first.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">bidiSpans(line) {</span><span class="s3">\n        </span><span class="s1">if (line.length &gt; MaxBidiLine)</span><span class="s3">\n            </span><span class="s1">return trivialOrder(line.length);</span><span class="s3">\n        </span><span class="s1">let dir = this.textDirectionAt(line.from), isolates;</span><span class="s3">\n        </span><span class="s1">for (let entry of this.bidiCache) {</span><span class="s3">\n            </span><span class="s1">if (entry.from == line.from &amp;&amp; entry.dir == dir &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line))))</span><span class="s3">\n                </span><span class="s1">return entry.order;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!isolates)</span><span class="s3">\n            </span><span class="s1">isolates = getIsolatedRanges(this, line);</span><span class="s3">\n        </span><span class="s1">let order = computeOrder(line.text, dir, isolates);</span><span class="s3">\n        </span><span class="s1">this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));</span><span class="s3">\n        </span><span class="s1">return order;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Check whether the editor has focus.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get hasFocus() {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">// Safari return false for hasFocus when the context menu is open</span><span class="s3">\n        </span><span class="s1">// or closing, which leads us to ignore selection changes from the</span><span class="s3">\n        </span><span class="s1">// context menu because it looks like the editor isn't focused.</span><span class="s3">\n        </span><span class="s1">// This kludges around that.</span><span class="s3">\n        </span><span class="s1">return (this.dom.ownerDocument.hasFocus() || browser.safari &amp;&amp; ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) &gt; Date.now() - 3e4) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.root.activeElement == this.contentDOM;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Put focus on the editor.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">focus() {</span><span class="s3">\n        </span><span class="s1">this.observer.ignore(() =&gt; {</span><span class="s3">\n            </span><span class="s1">focusPreventScroll(this.contentDOM);</span><span class="s3">\n            </span><span class="s1">this.docView.updateSelection();</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only</span><span class="s3">\n    </span><span class="s1">necessary when moving the editor's existing DOM to a new window or shadow root.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">setRoot(root) {</span><span class="s3">\n        </span><span class="s1">if (this._root != root) {</span><span class="s3">\n            </span><span class="s1">this._root = root;</span><span class="s3">\n            </span><span class="s1">this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);</span><span class="s3">\n            </span><span class="s1">this.mountStyles();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Clean up this editor view, removing its element from the</span><span class="s3">\n    </span><span class="s1">document, unregistering event handlers, and notifying</span><span class="s3">\n    </span><span class="s1">plugins. The view instance can no longer be used after</span><span class="s3">\n    </span><span class="s1">calling this.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">destroy() {</span><span class="s3">\n        </span><span class="s1">if (this.root.activeElement == this.contentDOM)</span><span class="s3">\n            </span><span class="s1">this.contentDOM.blur();</span><span class="s3">\n        </span><span class="s1">for (let plugin of this.plugins)</span><span class="s3">\n            </span><span class="s1">plugin.destroy(this);</span><span class="s3">\n        </span><span class="s1">this.plugins = [];</span><span class="s3">\n        </span><span class="s1">this.inputState.destroy();</span><span class="s3">\n        </span><span class="s1">this.docView.destroy();</span><span class="s3">\n        </span><span class="s1">this.dom.remove();</span><span class="s3">\n        </span><span class="s1">this.observer.destroy();</span><span class="s3">\n        </span><span class="s1">if (this.measureScheduled &gt; -1)</span><span class="s3">\n            </span><span class="s1">this.win.cancelAnimationFrame(this.measureScheduled);</span><span class="s3">\n        </span><span class="s1">this.destroyed = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Returns an effect that can be</span><span class="s3">\n    </span><span class="s1">[added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to</span><span class="s3">\n    </span><span class="s1">cause it to scroll the given position or range into view.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static scrollIntoView(pos, options = {}) {</span><span class="s3">\n        </span><span class="s1">return scrollIntoView.of(new ScrollTarget(typeof pos == </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">? EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Return an effect that resets the editor to its current (at the</span><span class="s3">\n    </span><span class="s1">time this method was called) scroll position. Note that this</span><span class="s3">\n    </span><span class="s1">only affects the editor's own scrollable element, not parents.</span><span class="s3">\n    </span><span class="s1">See also</span><span class="s3">\n    </span><span class="s1">[`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).</span><span class="s3">\n    \n    </span><span class="s1">The effect should be used with a document identical to the one</span><span class="s3">\n    </span><span class="s1">it was created for. Failing to do so is not an error, but may</span><span class="s3">\n    </span><span class="s1">not scroll to the expected position. You can</span><span class="s3">\n    </span><span class="s1">[map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">scrollSnapshot() {</span><span class="s3">\n        </span><span class="s1">let { scrollTop, scrollLeft } = this.scrollDOM;</span><span class="s3">\n        </span><span class="s1">let ref = this.viewState.scrollAnchorAt(scrollTop);</span><span class="s3">\n        </span><span class="s1">return scrollIntoView.of(new ScrollTarget(EditorSelection.cursor(ref.from), </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot;</span><span class="s1">, ref.top - scrollTop, scrollLeft, true));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Enable or disable tab-focus mode, which disables key bindings</span><span class="s3">\n    </span><span class="s1">for Tab and Shift-Tab, letting the browser's default</span><span class="s3">\n    </span><span class="s1">focus-changing behavior go through instead. This is useful to</span><span class="s3">\n    </span><span class="s1">prevent trapping keyboard users in your editor.</span><span class="s3">\n    \n    </span><span class="s1">Without argument, this toggles the mode. With a boolean, it</span><span class="s3">\n    </span><span class="s1">enables (true) or disables it (false). Given a number, it</span><span class="s3">\n    </span><span class="s1">temporarily enables the mode until that number of milliseconds</span><span class="s3">\n    </span><span class="s1">have passed or another non-Tab key is pressed.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">setTabFocusMode(to) {</span><span class="s3">\n        </span><span class="s1">if (to == null)</span><span class="s3">\n            </span><span class="s1">this.inputState.tabFocusMode = this.inputState.tabFocusMode &lt; 0 ? 0 : -1;</span><span class="s3">\n        </span><span class="s1">else if (typeof to == </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">this.inputState.tabFocusMode = to ? 0 : -1;</span><span class="s3">\n        </span><span class="s1">else if (this.inputState.tabFocusMode != 0)</span><span class="s3">\n            </span><span class="s1">this.inputState.tabFocusMode = Date.now() + to;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Returns an extension that can be used to add DOM event handlers.</span><span class="s3">\n    </span><span class="s1">The value should be an object mapping event names to handler</span><span class="s3">\n    </span><span class="s1">functions. For any given event, such functions are ordered by</span><span class="s3">\n    </span><span class="s1">extension precedence, and the first handler to return true will</span><span class="s3">\n    </span><span class="s1">be assumed to have handled that event, and no other handlers or</span><span class="s3">\n    </span><span class="s1">built-in behavior will be activated for it. These are registered</span><span class="s3">\n    </span><span class="s1">on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except</span><span class="s3">\n    </span><span class="s1">for `scroll` handlers, which will be called any time the</span><span class="s3">\n    </span><span class="s1">editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of</span><span class="s3">\n    </span><span class="s1">its parent nodes is scrolled.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static domEventHandlers(handlers) {</span><span class="s3">\n        </span><span class="s1">return ViewPlugin.define(() =&gt; ({}), { eventHandlers: handlers });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create an extension that registers DOM event observers. Contrary</span><span class="s3">\n    </span><span class="s1">to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),</span><span class="s3">\n    </span><span class="s1">observers can't be prevented from running by a higher-precedence</span><span class="s3">\n    </span><span class="s1">handler returning true. They also don't prevent other handlers</span><span class="s3">\n    </span><span class="s1">and observers from running when they return true, and should not</span><span class="s3">\n    </span><span class="s1">call `preventDefault`.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static domEventObservers(observers) {</span><span class="s3">\n        </span><span class="s1">return ViewPlugin.define(() =&gt; ({}), { eventObservers: observers });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a theme extension. The first argument can be a</span><span class="s3">\n    </span><span class="s1">[`style-mod`](https://github.com/marijnh/style-mod#documentation)</span><span class="s3">\n    </span><span class="s1">style spec providing the styles for the theme. These will be</span><span class="s3">\n    </span><span class="s1">prefixed with a generated class for the style.</span><span class="s3">\n    \n    </span><span class="s1">Because the selectors will be prefixed with a scope class, rule</span><span class="s3">\n    </span><span class="s1">that directly match the editor's [wrapper</span><span class="s3">\n    </span><span class="s1">element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be</span><span class="s3">\n    </span><span class="s1">addedneed to be explicitly differentiated by adding an `&amp;` to</span><span class="s3">\n    </span><span class="s1">the selector for that elementfor example</span><span class="s3">\n    </span><span class="s1">`&amp;.cm-focused`.</span><span class="s3">\n    \n    </span><span class="s1">When `dark` is set to true, the theme will be marked as dark,</span><span class="s3">\n    </span><span class="s1">which will cause the `&amp;dark` rules from [base</span><span class="s3">\n    </span><span class="s1">themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to</span><span class="s3">\n    </span><span class="s1">`&amp;light` when a light theme is active).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static theme(spec, options) {</span><span class="s3">\n        </span><span class="s1">let prefix = StyleModule.newName();</span><span class="s3">\n        </span><span class="s1">let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];</span><span class="s3">\n        </span><span class="s1">if (options &amp;&amp; options.dark)</span><span class="s3">\n            </span><span class="s1">result.push(darkTheme.of(true));</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create an extension that adds styles to the base theme. Like</span><span class="s3">\n    </span><span class="s1">with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&amp;` to indicate the</span><span class="s3">\n    </span><span class="s1">place of the editor wrapper element when directly targeting</span><span class="s3">\n    </span><span class="s1">that. You can also use `&amp;dark` or `&amp;light` instead to only</span><span class="s3">\n    </span><span class="s1">target editors with a dark or light theme.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static baseTheme(spec) {</span><span class="s3">\n        </span><span class="s1">return Prec.lowest(styleModule.of(buildTheme(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">+ baseThemeID, spec, lightDarkIDs)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Retrieve an editor view instance from the view's DOM</span><span class="s3">\n    </span><span class="s1">representation.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static findFromDOM(dom) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">let content = dom.querySelector(</span><span class="s3">\&quot;</span><span class="s1">.cm-content</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">let cView = content &amp;&amp; ContentView.get(content) || ContentView.get(dom);</span><span class="s3">\n        </span><span class="s1">return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Facet to add a [style</span><span class="s3">\n</span><span class="s1">module](https://github.com/marijnh/style-mod#documentation) to</span><span class="s3">\n</span><span class="s1">an editor view. The view will ensure that the module is</span><span class="s3">\n</span><span class="s1">mounted in its [document</span><span class="s3">\n</span><span class="s1">root](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.styleModule = styleModule;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">An input handler can override the way changes to the editable</span><span class="s3">\n</span><span class="s1">DOM content are handled. Handlers are passed the document</span><span class="s3">\n</span><span class="s1">positions between which the change was found, and the new</span><span class="s3">\n</span><span class="s1">content. When one returns true, no further input handlers are</span><span class="s3">\n</span><span class="s1">called and the default behavior is prevented.</span><span class="s3">\n\n</span><span class="s1">The `insert` argument can be used to get the default transaction</span><span class="s3">\n</span><span class="s1">that would be applied for this input. This can be useful when</span><span class="s3">\n</span><span class="s1">dispatching the custom behavior as a separate transaction.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.inputHandler = inputHandler;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Functions provided in this facet will be used to transform text</span><span class="s3">\n</span><span class="s1">pasted or dropped into the editor.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.clipboardInputFilter = clipboardInputFilter;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Transform text copied or dragged from the editor.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.clipboardOutputFilter = clipboardOutputFilter;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Scroll handlers can override how things are scrolled into view.</span><span class="s3">\n</span><span class="s1">If they return `true`, no further handling happens for the</span><span class="s3">\n</span><span class="s1">scrolling. If they return false, the default scroll behavior is</span><span class="s3">\n</span><span class="s1">applied. Scroll handlers should never initiate editor updates.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.scrollHandler = scrollHandler;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">This facet can be used to provide functions that create effects</span><span class="s3">\n</span><span class="s1">to be dispatched when the editor's focus state changes.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.focusChangeEffect = focusChangeEffect;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">By default, the editor assumes all its content has the same</span><span class="s3">\n</span><span class="s1">[text direction](https://codemirror.net/6/docs/ref/#view.Direction). Configure this with a `true`</span><span class="s3">\n</span><span class="s1">value to make it read the text direction of every (rendered)</span><span class="s3">\n</span><span class="s1">line separately.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.perLineTextDirection = perLineTextDirection;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Allows you to provide a function that should be called when the</span><span class="s3">\n</span><span class="s1">library catches an exception from an extension (mostly from view</span><span class="s3">\n</span><span class="s1">plugins, but may be used by other extensions to route exceptions</span><span class="s3">\n</span><span class="s1">from user-code-provided callbacks). This is mostly useful for</span><span class="s3">\n</span><span class="s1">debugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.exceptionSink = exceptionSink;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A facet that can be used to register a function to be called</span><span class="s3">\n</span><span class="s1">every time the view updates.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.updateListener = updateListener;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Facet that controls whether the editor content DOM is editable.</span><span class="s3">\n</span><span class="s1">When its highest-precedence value is `false`, the element will</span><span class="s3">\n</span><span class="s1">not have its `contenteditable` attribute set. (Note that this</span><span class="s3">\n</span><span class="s1">doesn't affect API calls that change the editor content, even</span><span class="s3">\n</span><span class="s1">when those are bound to keys or buttons. See the</span><span class="s3">\n</span><span class="s1">[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.editable = editable;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Allows you to influence the way mouse selection happens. The</span><span class="s3">\n</span><span class="s1">functions in this facet will be called for a `mousedown` event</span><span class="s3">\n</span><span class="s1">on the editor, and can return an object that overrides the way a</span><span class="s3">\n</span><span class="s1">selection is computed from that mouse click or drag.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.mouseSelectionStyle = mouseSelectionStyle;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Facet used to configure whether a given selection drag event</span><span class="s3">\n</span><span class="s1">should move or copy the selection. The given predicate will be</span><span class="s3">\n</span><span class="s1">called with the `mousedown` event, and can return `true` when</span><span class="s3">\n</span><span class="s1">the drag should move the content.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.dragMovesSelection = dragMovesSelection$1;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Facet used to configure whether a given selecting click adds a</span><span class="s3">\n</span><span class="s1">new range to the existing selection or replaces it entirely. The</span><span class="s3">\n</span><span class="s1">default behavior is to check `event.metaKey` on macOS, and</span><span class="s3">\n</span><span class="s1">`event.ctrlKey` elsewhere.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.clickAddsSelectionRange = clickAddsSelectionRange;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)</span><span class="s3">\n</span><span class="s1">are shown in the view. Decorations can be provided in two</span><span class="s3">\n</span><span class="s1">waysdirectly, or via a function that takes an editor view.</span><span class="s3">\n\n</span><span class="s1">Only decoration sets provided directly are allowed to influence</span><span class="s3">\n</span><span class="s1">the editor's vertical layout structure. The ones provided as</span><span class="s3">\n</span><span class="s1">functions are called _after_ the new viewport has been computed,</span><span class="s3">\n</span><span class="s1">and thus **must not** introduce block widgets or replacing</span><span class="s3">\n</span><span class="s1">decorations that cover line breaks.</span><span class="s3">\n\n</span><span class="s1">If you want decorated ranges to behave like atomic units for</span><span class="s3">\n</span><span class="s1">cursor motion and deletion purposes, also provide the range set</span><span class="s3">\n</span><span class="s1">containing the decorations to</span><span class="s3">\n</span><span class="s1">[`EditorView.atomicRanges`](https://codemirror.net/6/docs/ref/#view.EditorView^atomicRanges).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.decorations = decorations;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Facet that works much like</span><span class="s3">\n</span><span class="s1">[`decorations`](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), but puts its</span><span class="s3">\n</span><span class="s1">inputs at the very bottom of the precedence stack, meaning mark</span><span class="s3">\n</span><span class="s1">decorations provided here will only be split by other, partially</span><span class="s3">\n</span><span class="s1">overlapping </span><span class="s3">\\</span><span class="s1">`outerDecorations</span><span class="s3">\\</span><span class="s1">` ranges, and wrap around all</span><span class="s3">\n</span><span class="s1">regular decorations. Use this for mark elements that should, as</span><span class="s3">\n</span><span class="s1">much as possible, remain in one piece.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.outerDecorations = outerDecorations;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Used to provide ranges that should be treated as atoms as far as</span><span class="s3">\n</span><span class="s1">cursor motion is concerned. This causes methods like</span><span class="s3">\n</span><span class="s1">[`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and</span><span class="s3">\n</span><span class="s1">[`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the</span><span class="s3">\n</span><span class="s1">commands built on top of them) to skip across such regions when</span><span class="s3">\n</span><span class="s1">a selection endpoint would enter them. This does _not_ prevent</span><span class="s3">\n</span><span class="s1">direct programmatic [selection</span><span class="s3">\n</span><span class="s1">updates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such</span><span class="s3">\n</span><span class="s1">regions.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.atomicRanges = atomicRanges;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">When range decorations add a `unicode-bidi: isolate` style, they</span><span class="s3">\n</span><span class="s1">should also include a</span><span class="s3">\n</span><span class="s1">[`bidiIsolate`](https://codemirror.net/6/docs/ref/#view.MarkDecorationSpec.bidiIsolate) property</span><span class="s3">\n</span><span class="s1">in their decoration spec, and be exposed through this facet, so</span><span class="s3">\n</span><span class="s1">that the editor can compute the proper text order. (Other values</span><span class="s3">\n</span><span class="s1">for `unicode-bidi`, except of course `normal`, are not</span><span class="s3">\n</span><span class="s1">supported.)</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.bidiIsolatedRanges = bidiIsolatedRanges;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Facet that allows extensions to provide additional scroll</span><span class="s3">\n</span><span class="s1">margins (space around the sides of the scrolling element that</span><span class="s3">\n</span><span class="s1">should be considered invisible). This can be useful when the</span><span class="s3">\n</span><span class="s1">plugin introduces elements that cover part of that element (for</span><span class="s3">\n</span><span class="s1">example a horizontally fixed gutter).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.scrollMargins = scrollMargins;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">This facet records whether a dark theme is active. The extension</span><span class="s3">\n</span><span class="s1">returned by [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme) automatically</span><span class="s3">\n</span><span class="s1">includes an instance of this when the `dark` option is set to</span><span class="s3">\n</span><span class="s1">true.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.darkTheme = darkTheme;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Provides a Content Security Policy nonce to use when creating</span><span class="s3">\n</span><span class="s1">the style sheets for the editor. Holds the empty string when no</span><span class="s3">\n</span><span class="s1">nonce has been provided.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.cspNonce = /*@__PURE__*/Facet.define({ combine: values =&gt; values.length ? values[0] : </span><span class="s3">\&quot;\&quot; </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Facet that provides additional DOM attributes for the editor's</span><span class="s3">\n</span><span class="s1">editable DOM element.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.contentAttributes = contentAttributes;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Facet that provides DOM attributes for the editor's outer</span><span class="s3">\n</span><span class="s1">element.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.editorAttributes = editorAttributes;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">An extension that enables line wrapping in the editor (by</span><span class="s3">\n</span><span class="s1">setting CSS `white-space` to `pre-wrap` in the content).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.lineWrapping = /*@__PURE__*/EditorView.contentAttributes.of({ </span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">cm-lineWrapping</span><span class="s3">\&quot; </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">State effect used to include screen reader announcements in a</span><span class="s3">\n</span><span class="s1">transaction. These will be added to the DOM in a visually hidden</span><span class="s3">\n</span><span class="s1">element with `aria-live=</span><span class="s3">\&quot;</span><span class="s1">polite</span><span class="s3">\&quot;</span><span class="s1">` set, and should be used to</span><span class="s3">\n</span><span class="s1">describe effects that are visually obvious but may not be</span><span class="s3">\n</span><span class="s1">noticed by screen reader users (such as moving to the next</span><span class="s3">\n</span><span class="s1">search match).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorView.announce = /*@__PURE__*/StateEffect.define();</span><span class="s3">\n</span><span class="s1">// Maximum line length for which we compute accurate bidi info</span><span class="s3">\n</span><span class="s1">const MaxBidiLine = 4096;</span><span class="s3">\n</span><span class="s1">const BadMeasure = {};</span><span class="s3">\n</span><span class="s1">class CachedOrder {</span><span class="s3">\n    </span><span class="s1">constructor(from, to, dir, isolates, fresh, order) {</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n        </span><span class="s1">this.dir = dir;</span><span class="s3">\n        </span><span class="s1">this.isolates = isolates;</span><span class="s3">\n        </span><span class="s1">this.fresh = fresh;</span><span class="s3">\n        </span><span class="s1">this.order = order;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static update(cache, changes) {</span><span class="s3">\n        </span><span class="s1">if (changes.empty &amp;&amp; !cache.some(c =&gt; c.fresh))</span><span class="s3">\n            </span><span class="s1">return cache;</span><span class="s3">\n        </span><span class="s1">let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;</span><span class="s3">\n        </span><span class="s1">for (let i = Math.max(0, cache.length - 10); i &lt; cache.length; i++) {</span><span class="s3">\n            </span><span class="s1">let entry = cache[i];</span><span class="s3">\n            </span><span class="s1">if (entry.dir == lastDir &amp;&amp; !changes.touchesRange(entry.from, entry.to))</span><span class="s3">\n                </span><span class="s1">result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function attrsFromFacet(view, facet, base) {</span><span class="s3">\n    </span><span class="s1">for (let sources = view.state.facet(facet), i = sources.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n        </span><span class="s1">let source = sources[i], value = typeof source == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">? source(view) : source;</span><span class="s3">\n        </span><span class="s1">if (value)</span><span class="s3">\n            </span><span class="s1">combineAttrs(value, base);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return base;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const currentPlatform = browser.mac ? </span><span class="s3">\&quot;</span><span class="s1">mac</span><span class="s3">\&quot; </span><span class="s1">: browser.windows ? </span><span class="s3">\&quot;</span><span class="s1">win</span><span class="s3">\&quot; </span><span class="s1">: browser.linux ? </span><span class="s3">\&quot;</span><span class="s1">linux</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">key</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">function normalizeKeyName(name, platform) {</span><span class="s3">\n    </span><span class="s1">const parts = name.split(/-(?!$)/);</span><span class="s3">\n    </span><span class="s1">let result = parts[parts.length - 1];</span><span class="s3">\n    </span><span class="s1">if (result == </span><span class="s3">\&quot;</span><span class="s1">Space</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">result = </span><span class="s3">\&quot; \&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">let alt, ctrl, shift, meta;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; parts.length - 1; ++i) {</span><span class="s3">\n        </span><span class="s1">const mod = parts[i];</span><span class="s3">\n        </span><span class="s1">if (/^(cmd|meta|m)$/i.test(mod))</span><span class="s3">\n            </span><span class="s1">meta = true;</span><span class="s3">\n        </span><span class="s1">else if (/^a(lt)?$/i.test(mod))</span><span class="s3">\n            </span><span class="s1">alt = true;</span><span class="s3">\n        </span><span class="s1">else if (/^(c|ctrl|control)$/i.test(mod))</span><span class="s3">\n            </span><span class="s1">ctrl = true;</span><span class="s3">\n        </span><span class="s1">else if (/^s(hift)?$/i.test(mod))</span><span class="s3">\n            </span><span class="s1">shift = true;</span><span class="s3">\n        </span><span class="s1">else if (/^mod$/i.test(mod)) {</span><span class="s3">\n            </span><span class="s1">if (platform == </span><span class="s3">\&quot;</span><span class="s1">mac</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">meta = true;</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">ctrl = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Unrecognized modifier name: </span><span class="s3">\&quot; </span><span class="s1">+ mod);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (alt)</span><span class="s3">\n        </span><span class="s1">result = </span><span class="s3">\&quot;</span><span class="s1">Alt-</span><span class="s3">\&quot; </span><span class="s1">+ result;</span><span class="s3">\n    </span><span class="s1">if (ctrl)</span><span class="s3">\n        </span><span class="s1">result = </span><span class="s3">\&quot;</span><span class="s1">Ctrl-</span><span class="s3">\&quot; </span><span class="s1">+ result;</span><span class="s3">\n    </span><span class="s1">if (meta)</span><span class="s3">\n        </span><span class="s1">result = </span><span class="s3">\&quot;</span><span class="s1">Meta-</span><span class="s3">\&quot; </span><span class="s1">+ result;</span><span class="s3">\n    </span><span class="s1">if (shift)</span><span class="s3">\n        </span><span class="s1">result = </span><span class="s3">\&quot;</span><span class="s1">Shift-</span><span class="s3">\&quot; </span><span class="s1">+ result;</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function modifiers(name, event, shift) {</span><span class="s3">\n    </span><span class="s1">if (event.altKey)</span><span class="s3">\n        </span><span class="s1">name = </span><span class="s3">\&quot;</span><span class="s1">Alt-</span><span class="s3">\&quot; </span><span class="s1">+ name;</span><span class="s3">\n    </span><span class="s1">if (event.ctrlKey)</span><span class="s3">\n        </span><span class="s1">name = </span><span class="s3">\&quot;</span><span class="s1">Ctrl-</span><span class="s3">\&quot; </span><span class="s1">+ name;</span><span class="s3">\n    </span><span class="s1">if (event.metaKey)</span><span class="s3">\n        </span><span class="s1">name = </span><span class="s3">\&quot;</span><span class="s1">Meta-</span><span class="s3">\&quot; </span><span class="s1">+ name;</span><span class="s3">\n    </span><span class="s1">if (shift !== false &amp;&amp; event.shiftKey)</span><span class="s3">\n        </span><span class="s1">name = </span><span class="s3">\&quot;</span><span class="s1">Shift-</span><span class="s3">\&quot; </span><span class="s1">+ name;</span><span class="s3">\n    </span><span class="s1">return name;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const handleKeyEvents = /*@__PURE__*/Prec.default(/*@__PURE__*/EditorView.domEventHandlers({</span><span class="s3">\n    </span><span class="s1">keydown(event, view) {</span><span class="s3">\n        </span><span class="s1">return runHandlers(getKeymap(view.state), event, view, </span><span class="s3">\&quot;</span><span class="s1">editor</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Facet used for registering keymaps.</span><span class="s3">\n\n</span><span class="s1">You can add multiple keymaps to an editor. Their priorities</span><span class="s3">\n</span><span class="s1">determine their precedence (the ones specified early or with high</span><span class="s3">\n</span><span class="s1">priority get checked first). When a handler has returned `true`</span><span class="s3">\n</span><span class="s1">for a given key, no further handlers are called.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const keymap = /*@__PURE__*/Facet.define({ enables: handleKeyEvents });</span><span class="s3">\n</span><span class="s1">const Keymaps = /*@__PURE__*/new WeakMap();</span><span class="s3">\n</span><span class="s1">// This is hidden behind an indirection, rather than directly computed</span><span class="s3">\n</span><span class="s1">// by the facet, to keep internal types out of the facet's type.</span><span class="s3">\n</span><span class="s1">function getKeymap(state) {</span><span class="s3">\n    </span><span class="s1">let bindings = state.facet(keymap);</span><span class="s3">\n    </span><span class="s1">let map = Keymaps.get(bindings);</span><span class="s3">\n    </span><span class="s1">if (!map)</span><span class="s3">\n        </span><span class="s1">Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) =&gt; a.concat(b), [])));</span><span class="s3">\n    </span><span class="s1">return map;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Run the key handlers registered for a given scope. The event</span><span class="s3">\n</span><span class="s1">object should be a `</span><span class="s3">\&quot;</span><span class="s1">keydown</span><span class="s3">\&quot;</span><span class="s1">` event. Returns true if any of the</span><span class="s3">\n</span><span class="s1">handlers handled it.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function runScopeHandlers(view, event, scope) {</span><span class="s3">\n    </span><span class="s1">return runHandlers(getKeymap(view.state), event, view, scope);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">let storedPrefix = null;</span><span class="s3">\n</span><span class="s1">const PrefixTimeout = 4000;</span><span class="s3">\n</span><span class="s1">function buildKeymap(bindings, platform = currentPlatform) {</span><span class="s3">\n    </span><span class="s1">let bound = Object.create(null);</span><span class="s3">\n    </span><span class="s1">let isPrefix = Object.create(null);</span><span class="s3">\n    </span><span class="s1">let checkPrefix = (name, is) =&gt; {</span><span class="s3">\n        </span><span class="s1">let current = isPrefix[name];</span><span class="s3">\n        </span><span class="s1">if (current == null)</span><span class="s3">\n            </span><span class="s1">isPrefix[name] = is;</span><span class="s3">\n        </span><span class="s1">else if (current != is)</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Key binding </span><span class="s3">\&quot; </span><span class="s1">+ name + </span><span class="s3">\&quot; </span><span class="s1">is used both as a regular binding and as a multi-stroke prefix</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">let add = (scope, key, command, preventDefault, stopPropagation) =&gt; {</span><span class="s3">\n        </span><span class="s1">var _a, _b;</span><span class="s3">\n        </span><span class="s1">let scopeObj = bound[scope] || (bound[scope] = Object.create(null));</span><span class="s3">\n        </span><span class="s1">let parts = key.split(/ (?!$)/).map(k =&gt; normalizeKeyName(k, platform));</span><span class="s3">\n        </span><span class="s1">for (let i = 1; i &lt; parts.length; i++) {</span><span class="s3">\n            </span><span class="s1">let prefix = parts.slice(0, i).join(</span><span class="s3">\&quot; \&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">checkPrefix(prefix, true);</span><span class="s3">\n            </span><span class="s1">if (!scopeObj[prefix])</span><span class="s3">\n                </span><span class="s1">scopeObj[prefix] = {</span><span class="s3">\n                    </span><span class="s1">preventDefault: true,</span><span class="s3">\n                    </span><span class="s1">stopPropagation: false,</span><span class="s3">\n                    </span><span class="s1">run: [(view) =&gt; {</span><span class="s3">\n                            </span><span class="s1">let ourObj = storedPrefix = { view, prefix, scope };</span><span class="s3">\n                            </span><span class="s1">setTimeout(() =&gt; { if (storedPrefix == ourObj)</span><span class="s3">\n                                </span><span class="s1">storedPrefix = null; }, PrefixTimeout);</span><span class="s3">\n                            </span><span class="s1">return true;</span><span class="s3">\n                        </span><span class="s1">}]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let full = parts.join(</span><span class="s3">\&quot; \&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">checkPrefix(full, false);</span><span class="s3">\n        </span><span class="s1">let binding = scopeObj[full] || (scopeObj[full] = {</span><span class="s3">\n            </span><span class="s1">preventDefault: false,</span><span class="s3">\n            </span><span class="s1">stopPropagation: false,</span><span class="s3">\n            </span><span class="s1">run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || []</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">if (command)</span><span class="s3">\n            </span><span class="s1">binding.run.push(command);</span><span class="s3">\n        </span><span class="s1">if (preventDefault)</span><span class="s3">\n            </span><span class="s1">binding.preventDefault = true;</span><span class="s3">\n        </span><span class="s1">if (stopPropagation)</span><span class="s3">\n            </span><span class="s1">binding.stopPropagation = true;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">for (let b of bindings) {</span><span class="s3">\n        </span><span class="s1">let scopes = b.scope ? b.scope.split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">) : [</span><span class="s3">\&quot;</span><span class="s1">editor</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n        </span><span class="s1">if (b.any)</span><span class="s3">\n            </span><span class="s1">for (let scope of scopes) {</span><span class="s3">\n                </span><span class="s1">let scopeObj = bound[scope] || (bound[scope] = Object.create(null));</span><span class="s3">\n                </span><span class="s1">if (!scopeObj._any)</span><span class="s3">\n                    </span><span class="s1">scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };</span><span class="s3">\n                </span><span class="s1">let { any } = b;</span><span class="s3">\n                </span><span class="s1">for (let key in scopeObj)</span><span class="s3">\n                    </span><span class="s1">scopeObj[key].run.push(view =&gt; any(view, currentKeyEvent));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let name = b[platform] || b.key;</span><span class="s3">\n        </span><span class="s1">if (!name)</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">for (let scope of scopes) {</span><span class="s3">\n            </span><span class="s1">add(scope, name, b.run, b.preventDefault, b.stopPropagation);</span><span class="s3">\n            </span><span class="s1">if (b.shift)</span><span class="s3">\n                </span><span class="s1">add(scope, </span><span class="s3">\&quot;</span><span class="s1">Shift-</span><span class="s3">\&quot; </span><span class="s1">+ name, b.shift, b.preventDefault, b.stopPropagation);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return bound;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">let currentKeyEvent = null;</span><span class="s3">\n</span><span class="s1">function runHandlers(map, event, view, scope) {</span><span class="s3">\n    </span><span class="s1">currentKeyEvent = event;</span><span class="s3">\n    </span><span class="s1">let name = keyName(event);</span><span class="s3">\n    </span><span class="s1">let charCode = codePointAt(name, 0), isChar = codePointSize(charCode) == name.length &amp;&amp; name != </span><span class="s3">\&quot; \&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">let prefix = </span><span class="s3">\&quot;\&quot;</span><span class="s1">, handled = false, prevented = false, stopPropagation = false;</span><span class="s3">\n    </span><span class="s1">if (storedPrefix &amp;&amp; storedPrefix.view == view &amp;&amp; storedPrefix.scope == scope) {</span><span class="s3">\n        </span><span class="s1">prefix = storedPrefix.prefix + </span><span class="s3">\&quot; \&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">if (modifierCodes.indexOf(event.keyCode) &lt; 0) {</span><span class="s3">\n            </span><span class="s1">prevented = true;</span><span class="s3">\n            </span><span class="s1">storedPrefix = null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let ran = new Set;</span><span class="s3">\n    </span><span class="s1">let runFor = (binding) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (binding) {</span><span class="s3">\n            </span><span class="s1">for (let cmd of binding.run)</span><span class="s3">\n                </span><span class="s1">if (!ran.has(cmd)) {</span><span class="s3">\n                    </span><span class="s1">ran.add(cmd);</span><span class="s3">\n                    </span><span class="s1">if (cmd(view)) {</span><span class="s3">\n                        </span><span class="s1">if (binding.stopPropagation)</span><span class="s3">\n                            </span><span class="s1">stopPropagation = true;</span><span class="s3">\n                        </span><span class="s1">return true;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (binding.preventDefault) {</span><span class="s3">\n                </span><span class="s1">if (binding.stopPropagation)</span><span class="s3">\n                    </span><span class="s1">stopPropagation = true;</span><span class="s3">\n                </span><span class="s1">prevented = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">let scopeObj = map[scope], baseName, shiftName;</span><span class="s3">\n    </span><span class="s1">if (scopeObj) {</span><span class="s3">\n        </span><span class="s1">if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) {</span><span class="s3">\n            </span><span class="s1">handled = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (isChar &amp;&amp; (event.altKey || event.metaKey || event.ctrlKey) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">// Ctrl-Alt may be used for AltGr on Windows</span><span class="s3">\n            </span><span class="s1">!(browser.windows &amp;&amp; event.ctrlKey &amp;&amp; event.altKey) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(baseName = base[event.keyCode]) &amp;&amp; baseName != name) {</span><span class="s3">\n            </span><span class="s1">if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {</span><span class="s3">\n                </span><span class="s1">handled = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (event.shiftKey &amp;&amp; (shiftName = shift[event.keyCode]) != name &amp;&amp; shiftName != baseName &amp;&amp;</span><span class="s3">\n                </span><span class="s1">runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {</span><span class="s3">\n                </span><span class="s1">handled = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (isChar &amp;&amp; event.shiftKey &amp;&amp;</span><span class="s3">\n            </span><span class="s1">runFor(scopeObj[prefix + modifiers(name, event, true)])) {</span><span class="s3">\n            </span><span class="s1">handled = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!handled &amp;&amp; runFor(scopeObj._any))</span><span class="s3">\n            </span><span class="s1">handled = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (prevented)</span><span class="s3">\n        </span><span class="s1">handled = true;</span><span class="s3">\n    </span><span class="s1">if (handled &amp;&amp; stopPropagation)</span><span class="s3">\n        </span><span class="s1">event.stopPropagation();</span><span class="s3">\n    </span><span class="s1">currentKeyEvent = null;</span><span class="s3">\n    </span><span class="s1">return handled;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Implementation of [`LayerMarker`](https://codemirror.net/6/docs/ref/#view.LayerMarker) that creates</span><span class="s3">\n</span><span class="s1">a rectangle at a given set of coordinates.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class RectangleMarker {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a marker with the given class and dimensions. If `width`</span><span class="s3">\n    </span><span class="s1">is null, the DOM element will get no width style.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(className, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The left position of the marker (in pixels, document-relative).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">left, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The top position of the marker.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">top, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The width of the marker, or null if it shouldn't get a width assigned.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">width, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The height of the marker.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">height) {</span><span class="s3">\n        </span><span class="s1">this.className = className;</span><span class="s3">\n        </span><span class="s1">this.left = left;</span><span class="s3">\n        </span><span class="s1">this.top = top;</span><span class="s3">\n        </span><span class="s1">this.width = width;</span><span class="s3">\n        </span><span class="s1">this.height = height;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">draw() {</span><span class="s3">\n        </span><span class="s1">let elt = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">elt.className = this.className;</span><span class="s3">\n        </span><span class="s1">this.adjust(elt);</span><span class="s3">\n        </span><span class="s1">return elt;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(elt, prev) {</span><span class="s3">\n        </span><span class="s1">if (prev.className != this.className)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">this.adjust(elt);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">adjust(elt) {</span><span class="s3">\n        </span><span class="s1">elt.style.left = this.left + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">elt.style.top = this.top + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">if (this.width != null)</span><span class="s3">\n            </span><span class="s1">elt.style.width = this.width + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">elt.style.height = this.height + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(p) {</span><span class="s3">\n        </span><span class="s1">return this.left == p.left &amp;&amp; this.top == p.top &amp;&amp; this.width == p.width &amp;&amp; this.height == p.height &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.className == p.className;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a set of rectangles for the given selection range,</span><span class="s3">\n    </span><span class="s1">assigning them theclass`className`. Will create a single</span><span class="s3">\n    </span><span class="s1">rectangle for empty ranges, and a set of selection-style</span><span class="s3">\n    </span><span class="s1">rectangles covering the range's content (in a bidi-aware</span><span class="s3">\n    </span><span class="s1">way) for non-empty ones.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static forRange(view, className, range) {</span><span class="s3">\n        </span><span class="s1">if (range.empty) {</span><span class="s3">\n            </span><span class="s1">let pos = view.coordsAtPos(range.head, range.assoc || 1);</span><span class="s3">\n            </span><span class="s1">if (!pos)</span><span class="s3">\n                </span><span class="s1">return [];</span><span class="s3">\n            </span><span class="s1">let base = getBase(view);</span><span class="s3">\n            </span><span class="s1">return [new RectangleMarker(className, pos.left - base.left, pos.top - base.top, null, pos.bottom - pos.top)];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return rectanglesForRange(view, className, range);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getBase(view) {</span><span class="s3">\n    </span><span class="s1">let rect = view.scrollDOM.getBoundingClientRect();</span><span class="s3">\n    </span><span class="s1">let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;</span><span class="s3">\n    </span><span class="s1">return { left: left - view.scrollDOM.scrollLeft * view.scaleX, top: rect.top - view.scrollDOM.scrollTop * view.scaleY };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function wrappedLine(view, pos, side, inside) {</span><span class="s3">\n    </span><span class="s1">let coords = view.coordsAtPos(pos, side * 2);</span><span class="s3">\n    </span><span class="s1">if (!coords)</span><span class="s3">\n        </span><span class="s1">return inside;</span><span class="s3">\n    </span><span class="s1">let editorRect = view.dom.getBoundingClientRect();</span><span class="s3">\n    </span><span class="s1">let y = (coords.top + coords.bottom) / 2;</span><span class="s3">\n    </span><span class="s1">let left = view.posAtCoords({ x: editorRect.left + 1, y });</span><span class="s3">\n    </span><span class="s1">let right = view.posAtCoords({ x: editorRect.right - 1, y });</span><span class="s3">\n    </span><span class="s1">if (left == null || right == null)</span><span class="s3">\n        </span><span class="s1">return inside;</span><span class="s3">\n    </span><span class="s1">return { from: Math.max(inside.from, Math.min(left, right)), to: Math.min(inside.to, Math.max(left, right)) };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function rectanglesForRange(view, className, range) {</span><span class="s3">\n    </span><span class="s1">if (range.to &lt;= view.viewport.from || range.from &gt;= view.viewport.to)</span><span class="s3">\n        </span><span class="s1">return [];</span><span class="s3">\n    </span><span class="s1">let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);</span><span class="s3">\n    </span><span class="s1">let ltr = view.textDirection == Direction.LTR;</span><span class="s3">\n    </span><span class="s1">let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);</span><span class="s3">\n    </span><span class="s1">let lineElt = content.querySelector(</span><span class="s3">\&quot;</span><span class="s1">.cm-line</span><span class="s3">\&quot;</span><span class="s1">), lineStyle = lineElt &amp;&amp; window.getComputedStyle(lineElt);</span><span class="s3">\n    </span><span class="s1">let leftSide = contentRect.left +</span><span class="s3">\n        </span><span class="s1">(lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);</span><span class="s3">\n    </span><span class="s1">let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);</span><span class="s3">\n    </span><span class="s1">let startBlock = blockAt(view, from), endBlock = blockAt(view, to);</span><span class="s3">\n    </span><span class="s1">let visualStart = startBlock.type == BlockType.Text ? startBlock : null;</span><span class="s3">\n    </span><span class="s1">let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;</span><span class="s3">\n    </span><span class="s1">if (visualStart &amp;&amp; (view.lineWrapping || startBlock.widgetLineBreaks))</span><span class="s3">\n        </span><span class="s1">visualStart = wrappedLine(view, from, 1, visualStart);</span><span class="s3">\n    </span><span class="s1">if (visualEnd &amp;&amp; (view.lineWrapping || endBlock.widgetLineBreaks))</span><span class="s3">\n        </span><span class="s1">visualEnd = wrappedLine(view, to, -1, visualEnd);</span><span class="s3">\n    </span><span class="s1">if (visualStart &amp;&amp; visualEnd &amp;&amp; visualStart.from == visualEnd.from &amp;&amp; visualStart.to == visualEnd.to) {</span><span class="s3">\n        </span><span class="s1">return pieces(drawForLine(range.from, range.to, visualStart));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);</span><span class="s3">\n        </span><span class="s1">let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);</span><span class="s3">\n        </span><span class="s1">let between = [];</span><span class="s3">\n        </span><span class="s1">if ((visualStart || startBlock).to &lt; (visualEnd || endBlock).from - (visualStart &amp;&amp; visualEnd ? 1 : 0) ||</span><span class="s3">\n            </span><span class="s1">startBlock.widgetLineBreaks &gt; 1 &amp;&amp; top.bottom + view.defaultLineHeight / 2 &lt; bottom.top)</span><span class="s3">\n            </span><span class="s1">between.push(piece(leftSide, top.bottom, rightSide, bottom.top));</span><span class="s3">\n        </span><span class="s1">else if (top.bottom &lt; bottom.top &amp;&amp; view.elementAtHeight((top.bottom + bottom.top) / 2).type == BlockType.Text)</span><span class="s3">\n            </span><span class="s1">top.bottom = bottom.top = (top.bottom + bottom.top) / 2;</span><span class="s3">\n        </span><span class="s1">return pieces(top).concat(between).concat(pieces(bottom));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function piece(left, top, right, bottom) {</span><span class="s3">\n        </span><span class="s1">return new RectangleMarker(className, left - base.left, top - base.top, right - left, bottom - top);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function pieces({ top, bottom, horizontal }) {</span><span class="s3">\n        </span><span class="s1">let pieces = [];</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; horizontal.length; i += 2)</span><span class="s3">\n            </span><span class="s1">pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));</span><span class="s3">\n        </span><span class="s1">return pieces;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Gets passed from/to in line-local positions</span><span class="s3">\n    </span><span class="s1">function drawForLine(from, to, line) {</span><span class="s3">\n        </span><span class="s1">let top = 1e9, bottom = -1e9, horizontal = [];</span><span class="s3">\n        </span><span class="s1">function addSpan(from, fromOpen, to, toOpen, dir) {</span><span class="s3">\n            </span><span class="s1">// Passing 2/-2 is a kludge to force the view to return</span><span class="s3">\n            </span><span class="s1">// coordinates on the proper side of block widgets, since</span><span class="s3">\n            </span><span class="s1">// normalizing the side there, though appropriate for most</span><span class="s3">\n            </span><span class="s1">// coordsAtPos queries, would break selection drawing.</span><span class="s3">\n            </span><span class="s1">let fromCoords = view.coordsAtPos(from, (from == line.to ? -2 : 2));</span><span class="s3">\n            </span><span class="s1">let toCoords = view.coordsAtPos(to, (to == line.from ? 2 : -2));</span><span class="s3">\n            </span><span class="s1">if (!fromCoords || !toCoords)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">top = Math.min(fromCoords.top, toCoords.top, top);</span><span class="s3">\n            </span><span class="s1">bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);</span><span class="s3">\n            </span><span class="s1">if (dir == Direction.LTR)</span><span class="s3">\n                </span><span class="s1">horizontal.push(ltr &amp;&amp; fromOpen ? leftSide : fromCoords.left, ltr &amp;&amp; toOpen ? rightSide : toCoords.right);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">horizontal.push(!ltr &amp;&amp; toOpen ? leftSide : toCoords.left, !ltr &amp;&amp; fromOpen ? rightSide : fromCoords.right);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let start = from !== null &amp;&amp; from !== void 0 ? from : line.from, end = to !== null &amp;&amp; to !== void 0 ? to : line.to;</span><span class="s3">\n        </span><span class="s1">// Split the range by visible range and document line</span><span class="s3">\n        </span><span class="s1">for (let r of view.visibleRanges)</span><span class="s3">\n            </span><span class="s1">if (r.to &gt; start &amp;&amp; r.from &lt; end) {</span><span class="s3">\n                </span><span class="s1">for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;) {</span><span class="s3">\n                    </span><span class="s1">let docLine = view.state.doc.lineAt(pos);</span><span class="s3">\n                    </span><span class="s1">for (let span of view.bidiSpans(docLine)) {</span><span class="s3">\n                        </span><span class="s1">let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;</span><span class="s3">\n                        </span><span class="s1">if (spanFrom &gt;= endPos)</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">if (spanTo &gt; pos)</span><span class="s3">\n                            </span><span class="s1">addSpan(Math.max(spanFrom, pos), from == null &amp;&amp; spanFrom &lt;= start, Math.min(spanTo, endPos), to == null &amp;&amp; spanTo &gt;= end, span.dir);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">pos = docLine.to + 1;</span><span class="s3">\n                    </span><span class="s1">if (pos &gt;= endPos)</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (horizontal.length == 0)</span><span class="s3">\n            </span><span class="s1">addSpan(start, from == null, end, to == null, view.textDirection);</span><span class="s3">\n        </span><span class="s1">return { top, bottom, horizontal };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function drawForWidget(block, top) {</span><span class="s3">\n        </span><span class="s1">let y = contentRect.top + (top ? block.top : block.bottom);</span><span class="s3">\n        </span><span class="s1">return { top: y, bottom: y, horizontal: [] };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function sameMarker(a, b) {</span><span class="s3">\n    </span><span class="s1">return a.constructor == b.constructor &amp;&amp; a.eq(b);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class LayerView {</span><span class="s3">\n    </span><span class="s1">constructor(view, layer) {</span><span class="s3">\n        </span><span class="s1">this.view = view;</span><span class="s3">\n        </span><span class="s1">this.layer = layer;</span><span class="s3">\n        </span><span class="s1">this.drawn = [];</span><span class="s3">\n        </span><span class="s1">this.scaleX = 1;</span><span class="s3">\n        </span><span class="s1">this.scaleY = 1;</span><span class="s3">\n        </span><span class="s1">this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };</span><span class="s3">\n        </span><span class="s1">this.dom = view.scrollDOM.appendChild(document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">this.dom.classList.add(</span><span class="s3">\&quot;</span><span class="s1">cm-layer</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (layer.above)</span><span class="s3">\n            </span><span class="s1">this.dom.classList.add(</span><span class="s3">\&quot;</span><span class="s1">cm-layer-above</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (layer.class)</span><span class="s3">\n            </span><span class="s1">this.dom.classList.add(layer.class);</span><span class="s3">\n        </span><span class="s1">this.scale();</span><span class="s3">\n        </span><span class="s1">this.dom.setAttribute(</span><span class="s3">\&quot;</span><span class="s1">aria-hidden</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.setOrder(view.state);</span><span class="s3">\n        </span><span class="s1">view.requestMeasure(this.measureReq);</span><span class="s3">\n        </span><span class="s1">if (layer.mount)</span><span class="s3">\n            </span><span class="s1">layer.mount(this.dom, view);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))</span><span class="s3">\n            </span><span class="s1">this.setOrder(update.state);</span><span class="s3">\n        </span><span class="s1">if (this.layer.update(update, this.dom) || update.geometryChanged) {</span><span class="s3">\n            </span><span class="s1">this.scale();</span><span class="s3">\n            </span><span class="s1">update.view.requestMeasure(this.measureReq);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">docViewUpdate(view) {</span><span class="s3">\n        </span><span class="s1">if (this.layer.updateOnDocViewUpdate !== false)</span><span class="s3">\n            </span><span class="s1">view.requestMeasure(this.measureReq);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setOrder(state) {</span><span class="s3">\n        </span><span class="s1">let pos = 0, order = state.facet(layerOrder);</span><span class="s3">\n        </span><span class="s1">while (pos &lt; order.length &amp;&amp; order[pos] != this.layer)</span><span class="s3">\n            </span><span class="s1">pos++;</span><span class="s3">\n        </span><span class="s1">this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">measure() {</span><span class="s3">\n        </span><span class="s1">return this.layer.markers(this.view);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scale() {</span><span class="s3">\n        </span><span class="s1">let { scaleX, scaleY } = this.view;</span><span class="s3">\n        </span><span class="s1">if (scaleX != this.scaleX || scaleY != this.scaleY) {</span><span class="s3">\n            </span><span class="s1">this.scaleX = scaleX;</span><span class="s3">\n            </span><span class="s1">this.scaleY = scaleY;</span><span class="s3">\n            </span><span class="s1">this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">draw(markers) {</span><span class="s3">\n        </span><span class="s1">if (markers.length != this.drawn.length || markers.some((p, i) =&gt; !sameMarker(p, this.drawn[i]))) {</span><span class="s3">\n            </span><span class="s1">let old = this.dom.firstChild, oldI = 0;</span><span class="s3">\n            </span><span class="s1">for (let marker of markers) {</span><span class="s3">\n                </span><span class="s1">if (marker.update &amp;&amp; old &amp;&amp; marker.constructor &amp;&amp; this.drawn[oldI].constructor &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">marker.update(old, this.drawn[oldI])) {</span><span class="s3">\n                    </span><span class="s1">old = old.nextSibling;</span><span class="s3">\n                    </span><span class="s1">oldI++;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">this.dom.insertBefore(marker.draw(), old);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">while (old) {</span><span class="s3">\n                </span><span class="s1">let next = old.nextSibling;</span><span class="s3">\n                </span><span class="s1">old.remove();</span><span class="s3">\n                </span><span class="s1">old = next;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.drawn = markers;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">destroy() {</span><span class="s3">\n        </span><span class="s1">if (this.layer.destroy)</span><span class="s3">\n            </span><span class="s1">this.layer.destroy(this.dom, this.view);</span><span class="s3">\n        </span><span class="s1">this.dom.remove();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const layerOrder = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Define a layer.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function layer(config) {</span><span class="s3">\n    </span><span class="s1">return [</span><span class="s3">\n        </span><span class="s1">ViewPlugin.define(v =&gt; new LayerView(v, config)),</span><span class="s3">\n        </span><span class="s1">layerOrder.of(config)</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const CanHidePrimary = !(browser.ios &amp;&amp; browser.webkit &amp;&amp; browser.webkit_version &lt; 534);</span><span class="s3">\n</span><span class="s1">const selectionConfig = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine(configs) {</span><span class="s3">\n        </span><span class="s1">return combineConfig(configs, {</span><span class="s3">\n            </span><span class="s1">cursorBlinkRate: 1200,</span><span class="s3">\n            </span><span class="s1">drawRangeCursor: true</span><span class="s3">\n        </span><span class="s1">}, {</span><span class="s3">\n            </span><span class="s1">cursorBlinkRate: (a, b) =&gt; Math.min(a, b),</span><span class="s3">\n            </span><span class="s1">drawRangeCursor: (a, b) =&gt; a || b</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Returns an extension that hides the browser's native selection and</span><span class="s3">\n</span><span class="s1">cursor, replacing the selection with a background behind the text</span><span class="s3">\n</span><span class="s1">(with the `cm-selectionBackground` class), and the</span><span class="s3">\n</span><span class="s1">cursors with elements overlaid over the code (using</span><span class="s3">\n</span><span class="s1">`cm-cursor-primary` and `cm-cursor-secondary`).</span><span class="s3">\n\n</span><span class="s1">This allows the editor to display secondary selection ranges, and</span><span class="s3">\n</span><span class="s1">tends to produce a type of selection more in line with that users</span><span class="s3">\n</span><span class="s1">expect in a text editor (the native selection styling will often</span><span class="s3">\n</span><span class="s1">leave gaps between lines and won't fill the horizontal space after</span><span class="s3">\n</span><span class="s1">a line when the selection continues past it).</span><span class="s3">\n\n</span><span class="s1">It does have a performance cost, in that it requires an extra DOM</span><span class="s3">\n</span><span class="s1">layout cycle for many updates (the selection is drawn based on DOM</span><span class="s3">\n</span><span class="s1">layout information that's only available after laying out the</span><span class="s3">\n</span><span class="s1">content).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function drawSelection(config = {}) {</span><span class="s3">\n    </span><span class="s1">return [</span><span class="s3">\n        </span><span class="s1">selectionConfig.of(config),</span><span class="s3">\n        </span><span class="s1">cursorLayer,</span><span class="s3">\n        </span><span class="s1">selectionLayer,</span><span class="s3">\n        </span><span class="s1">hideNativeSelection,</span><span class="s3">\n        </span><span class="s1">nativeSelectionHidden.of(true)</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Retrieve the [`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) configuration</span><span class="s3">\n</span><span class="s1">for this state. (Note that this will return a set of defaults even</span><span class="s3">\n</span><span class="s1">if `drawSelection` isn't enabled.)</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getDrawSelectionConfig(state) {</span><span class="s3">\n    </span><span class="s1">return state.facet(selectionConfig);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function configChanged(update) {</span><span class="s3">\n    </span><span class="s1">return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const cursorLayer = /*@__PURE__*/layer({</span><span class="s3">\n    </span><span class="s1">above: true,</span><span class="s3">\n    </span><span class="s1">markers(view) {</span><span class="s3">\n        </span><span class="s1">let { state } = view, conf = state.facet(selectionConfig);</span><span class="s3">\n        </span><span class="s1">let cursors = [];</span><span class="s3">\n        </span><span class="s1">for (let r of state.selection.ranges) {</span><span class="s3">\n            </span><span class="s1">let prim = r == state.selection.main;</span><span class="s3">\n            </span><span class="s1">if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {</span><span class="s3">\n                </span><span class="s1">let className = prim ? </span><span class="s3">\&quot;</span><span class="s1">cm-cursor cm-cursor-primary</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">cm-cursor cm-cursor-secondary</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">let cursor = r.empty ? r : EditorSelection.cursor(r.head, r.head &gt; r.anchor ? -1 : 1);</span><span class="s3">\n                </span><span class="s1">for (let piece of RectangleMarker.forRange(view, className, cursor))</span><span class="s3">\n                    </span><span class="s1">cursors.push(piece);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return cursors;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">update(update, dom) {</span><span class="s3">\n        </span><span class="s1">if (update.transactions.some(tr =&gt; tr.selection))</span><span class="s3">\n            </span><span class="s1">dom.style.animationName = dom.style.animationName == </span><span class="s3">\&quot;</span><span class="s1">cm-blink</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">cm-blink2</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">cm-blink</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">let confChange = configChanged(update);</span><span class="s3">\n        </span><span class="s1">if (confChange)</span><span class="s3">\n            </span><span class="s1">setBlinkRate(update.state, dom);</span><span class="s3">\n        </span><span class="s1">return update.docChanged || update.selectionSet || confChange;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">mount(dom, view) {</span><span class="s3">\n        </span><span class="s1">setBlinkRate(view.state, dom);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">class: </span><span class="s3">\&quot;</span><span class="s1">cm-cursorLayer</span><span class="s3">\&quot;\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">function setBlinkRate(state, dom) {</span><span class="s3">\n    </span><span class="s1">dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + </span><span class="s3">\&quot;</span><span class="s1">ms</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const selectionLayer = /*@__PURE__*/layer({</span><span class="s3">\n    </span><span class="s1">above: false,</span><span class="s3">\n    </span><span class="s1">markers(view) {</span><span class="s3">\n        </span><span class="s1">return view.state.selection.ranges.map(r =&gt; r.empty ? [] : RectangleMarker.forRange(view, </span><span class="s3">\&quot;</span><span class="s1">cm-selectionBackground</span><span class="s3">\&quot;</span><span class="s1">, r))</span><span class="s3">\n            </span><span class="s1">.reduce((a, b) =&gt; a.concat(b));</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">update(update, dom) {</span><span class="s3">\n        </span><span class="s1">return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">class: </span><span class="s3">\&quot;</span><span class="s1">cm-selectionLayer</span><span class="s3">\&quot;\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const themeSpec = {</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-line</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        \&quot;</span><span class="s1">&amp; ::selection, &amp;::selection</span><span class="s3">\&quot;</span><span class="s1">: { backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">transparent !important</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-content</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        \&quot;</span><span class="s1">&amp; :focus</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">caretColor: </span><span class="s3">\&quot;</span><span class="s1">initial !important</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">&amp;::selection, &amp; ::selection</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n                </span><span class="s1">backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">Highlight !important</span><span class="s3">\&quot;\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">if (CanHidePrimary)</span><span class="s3">\n    </span><span class="s1">themeSpec[</span><span class="s3">\&quot;</span><span class="s1">.cm-line</span><span class="s3">\&quot;</span><span class="s1">].caretColor = themeSpec[</span><span class="s3">\&quot;</span><span class="s1">.cm-content</span><span class="s3">\&quot;</span><span class="s1">].caretColor = </span><span class="s3">\&quot;</span><span class="s1">transparent !important</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const hideNativeSelection = /*@__PURE__*/Prec.highest(/*@__PURE__*/EditorView.theme(themeSpec));</span><span class="s3">\n\n</span><span class="s1">const setDropCursorPos = /*@__PURE__*/StateEffect.define({</span><span class="s3">\n    </span><span class="s1">map(pos, mapping) { return pos == null ? null : mapping.mapPos(pos); }</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const dropCursorPos = /*@__PURE__*/StateField.define({</span><span class="s3">\n    </span><span class="s1">create() { return null; },</span><span class="s3">\n    </span><span class="s1">update(pos, tr) {</span><span class="s3">\n        </span><span class="s1">if (pos != null)</span><span class="s3">\n            </span><span class="s1">pos = tr.changes.mapPos(pos);</span><span class="s3">\n        </span><span class="s1">return tr.effects.reduce((pos, e) =&gt; e.is(setDropCursorPos) ? e.value : pos, pos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const drawDropCursor = /*@__PURE__*/ViewPlugin.fromClass(class {</span><span class="s3">\n    </span><span class="s1">constructor(view) {</span><span class="s3">\n        </span><span class="s1">this.view = view;</span><span class="s3">\n        </span><span class="s1">this.cursor = null;</span><span class="s3">\n        </span><span class="s1">this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">let cursorPos = update.state.field(dropCursorPos);</span><span class="s3">\n        </span><span class="s1">if (cursorPos == null) {</span><span class="s3">\n            </span><span class="s1">if (this.cursor != null) {</span><span class="s3">\n                </span><span class="s1">(_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();</span><span class="s3">\n                </span><span class="s1">this.cursor = null;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">if (!this.cursor) {</span><span class="s3">\n                </span><span class="s1">this.cursor = this.view.scrollDOM.appendChild(document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n                </span><span class="s1">this.cursor.className = </span><span class="s3">\&quot;</span><span class="s1">cm-dropCursor</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)</span><span class="s3">\n                </span><span class="s1">this.view.requestMeasure(this.measureReq);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">readPos() {</span><span class="s3">\n        </span><span class="s1">let { view } = this;</span><span class="s3">\n        </span><span class="s1">let pos = view.state.field(dropCursorPos);</span><span class="s3">\n        </span><span class="s1">let rect = pos != null &amp;&amp; view.coordsAtPos(pos);</span><span class="s3">\n        </span><span class="s1">if (!rect)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">let outer = view.scrollDOM.getBoundingClientRect();</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,</span><span class="s3">\n            </span><span class="s1">top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,</span><span class="s3">\n            </span><span class="s1">height: rect.bottom - rect.top</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">drawCursor(pos) {</span><span class="s3">\n        </span><span class="s1">if (this.cursor) {</span><span class="s3">\n            </span><span class="s1">let { scaleX, scaleY } = this.view;</span><span class="s3">\n            </span><span class="s1">if (pos) {</span><span class="s3">\n                </span><span class="s1">this.cursor.style.left = pos.left / scaleX + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">this.cursor.style.top = pos.top / scaleY + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">this.cursor.style.height = pos.height / scaleY + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this.cursor.style.left = </span><span class="s3">\&quot;</span><span class="s1">-100000px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">destroy() {</span><span class="s3">\n        </span><span class="s1">if (this.cursor)</span><span class="s3">\n            </span><span class="s1">this.cursor.remove();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setDropPos(pos) {</span><span class="s3">\n        </span><span class="s1">if (this.view.state.field(dropCursorPos) != pos)</span><span class="s3">\n            </span><span class="s1">this.view.dispatch({ effects: setDropCursorPos.of(pos) });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">eventObservers: {</span><span class="s3">\n        </span><span class="s1">dragover(event) {</span><span class="s3">\n            </span><span class="s1">this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">dragleave(event) {</span><span class="s3">\n            </span><span class="s1">if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))</span><span class="s3">\n                </span><span class="s1">this.setDropPos(null);</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">dragend() {</span><span class="s3">\n            </span><span class="s1">this.setDropPos(null);</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">drop() {</span><span class="s3">\n            </span><span class="s1">this.setDropPos(null);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Draws a cursor at the current drop position when something is</span><span class="s3">\n</span><span class="s1">dragged over the editor.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function dropCursor() {</span><span class="s3">\n    </span><span class="s1">return [dropCursorPos, drawDropCursor];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function iterMatches(doc, re, from, to, f) {</span><span class="s3">\n    </span><span class="s1">re.lastIndex = 0;</span><span class="s3">\n    </span><span class="s1">for (let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {</span><span class="s3">\n        </span><span class="s1">if (!cursor.lineBreak)</span><span class="s3">\n            </span><span class="s1">while (m = re.exec(cursor.value))</span><span class="s3">\n                </span><span class="s1">f(pos + m.index, m);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function matchRanges(view, maxLength) {</span><span class="s3">\n    </span><span class="s1">let visible = view.visibleRanges;</span><span class="s3">\n    </span><span class="s1">if (visible.length == 1 &amp;&amp; visible[0].from == view.viewport.from &amp;&amp;</span><span class="s3">\n        </span><span class="s1">visible[0].to == view.viewport.to)</span><span class="s3">\n        </span><span class="s1">return visible;</span><span class="s3">\n    </span><span class="s1">let result = [];</span><span class="s3">\n    </span><span class="s1">for (let { from, to } of visible) {</span><span class="s3">\n        </span><span class="s1">from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);</span><span class="s3">\n        </span><span class="s1">to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);</span><span class="s3">\n        </span><span class="s1">if (result.length &amp;&amp; result[result.length - 1].to &gt;= from)</span><span class="s3">\n            </span><span class="s1">result[result.length - 1].to = to;</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">result.push({ from, to });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Helper class used to make it easier to maintain decorations on</span><span class="s3">\n</span><span class="s1">visible code that matches a given regular expression. To be used</span><span class="s3">\n</span><span class="s1">in a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object</span><span class="s3">\n</span><span class="s1">represent a matching configuration.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class MatchDecorator {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a decorator.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(config) {</span><span class="s3">\n        </span><span class="s1">const { regexp, decoration, decorate, boundary, maxLength = 1000 } = config;</span><span class="s3">\n        </span><span class="s1">if (!regexp.global)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">The regular expression given to MatchDecorator should have its 'g' flag set</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.regexp = regexp;</span><span class="s3">\n        </span><span class="s1">if (decorate) {</span><span class="s3">\n            </span><span class="s1">this.addMatch = (match, view, from, add) =&gt; decorate(add, from, from + match[0].length, match, view);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (typeof decoration == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">this.addMatch = (match, view, from, add) =&gt; {</span><span class="s3">\n                </span><span class="s1">let deco = decoration(match, view, from);</span><span class="s3">\n                </span><span class="s1">if (deco)</span><span class="s3">\n                    </span><span class="s1">add(from, from + match[0].length, deco);</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (decoration) {</span><span class="s3">\n            </span><span class="s1">this.addMatch = (match, _view, from, add) =&gt; add(from, from + match[0].length, decoration);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Either 'decorate' or 'decoration' should be provided to MatchDecorator</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.boundary = boundary;</span><span class="s3">\n        </span><span class="s1">this.maxLength = maxLength;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Compute the full set of decorations for matches in the given</span><span class="s3">\n    </span><span class="s1">view's viewport. You'll want to call this when initializing your</span><span class="s3">\n    </span><span class="s1">plugin.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">createDeco(view) {</span><span class="s3">\n        </span><span class="s1">let build = new RangeSetBuilder(), add = build.add.bind(build);</span><span class="s3">\n        </span><span class="s1">for (let { from, to } of matchRanges(view, this.maxLength))</span><span class="s3">\n            </span><span class="s1">iterMatches(view.state.doc, this.regexp, from, to, (from, m) =&gt; this.addMatch(m, view, from, add));</span><span class="s3">\n        </span><span class="s1">return build.finish();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Update a set of decorations for a view update. `deco` _must_ be</span><span class="s3">\n    </span><span class="s1">the set of decorations produced by _this_ `MatchDecorator` for</span><span class="s3">\n    </span><span class="s1">the view state before the update.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">updateDeco(update, deco) {</span><span class="s3">\n        </span><span class="s1">let changeFrom = 1e9, changeTo = -1;</span><span class="s3">\n        </span><span class="s1">if (update.docChanged)</span><span class="s3">\n            </span><span class="s1">update.changes.iterChanges((_f, _t, from, to) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (to &gt;= update.view.viewport.from &amp;&amp; from &lt;= update.view.viewport.to) {</span><span class="s3">\n                    </span><span class="s1">changeFrom = Math.min(from, changeFrom);</span><span class="s3">\n                    </span><span class="s1">changeTo = Math.max(to, changeTo);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">if (update.viewportMoved || changeTo - changeFrom &gt; 1000)</span><span class="s3">\n            </span><span class="s1">return this.createDeco(update.view);</span><span class="s3">\n        </span><span class="s1">if (changeTo &gt; -1)</span><span class="s3">\n            </span><span class="s1">return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);</span><span class="s3">\n        </span><span class="s1">return deco;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateRange(view, deco, updateFrom, updateTo) {</span><span class="s3">\n        </span><span class="s1">for (let r of view.visibleRanges) {</span><span class="s3">\n            </span><span class="s1">let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);</span><span class="s3">\n            </span><span class="s1">if (to &gt; from) {</span><span class="s3">\n                </span><span class="s1">let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to &lt; to ? view.state.doc.lineAt(to) : fromLine;</span><span class="s3">\n                </span><span class="s1">let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);</span><span class="s3">\n                </span><span class="s1">if (this.boundary) {</span><span class="s3">\n                    </span><span class="s1">for (; from &gt; fromLine.from; from--)</span><span class="s3">\n                        </span><span class="s1">if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {</span><span class="s3">\n                            </span><span class="s1">start = from;</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">for (; to &lt; toLine.to; to++)</span><span class="s3">\n                        </span><span class="s1">if (this.boundary.test(toLine.text[to - toLine.from])) {</span><span class="s3">\n                            </span><span class="s1">end = to;</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">let ranges = [], m;</span><span class="s3">\n                </span><span class="s1">let add = (from, to, deco) =&gt; ranges.push(deco.range(from, to));</span><span class="s3">\n                </span><span class="s1">if (fromLine == toLine) {</span><span class="s3">\n                    </span><span class="s1">this.regexp.lastIndex = start - fromLine.from;</span><span class="s3">\n                    </span><span class="s1">while ((m = this.regexp.exec(fromLine.text)) &amp;&amp; m.index &lt; end - fromLine.from)</span><span class="s3">\n                        </span><span class="s1">this.addMatch(m, view, m.index + fromLine.from, add);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">iterMatches(view.state.doc, this.regexp, start, end, (from, m) =&gt; this.addMatch(m, view, from, add));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">deco = deco.update({ filterFrom: start, filterTo: end, filter: (from, to) =&gt; from &lt; start || to &gt; end, add: ranges });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return deco;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const UnicodeRegexpSupport = /x/.unicode != null ? </span><span class="s3">\&quot;</span><span class="s1">gu</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const Specials = /*@__PURE__*/new RegExp(</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">u0000-</span><span class="s3">\\</span><span class="s1">u0008</span><span class="s3">\\</span><span class="s1">u000a-</span><span class="s3">\\</span><span class="s1">u001f</span><span class="s3">\\</span><span class="s1">u007f-</span><span class="s3">\\</span><span class="s1">u009f</span><span class="s3">\\</span><span class="s1">u00ad</span><span class="s3">\\</span><span class="s1">u061c</span><span class="s3">\\</span><span class="s1">u200b</span><span class="s3">\\</span><span class="s1">u200e</span><span class="s3">\\</span><span class="s1">u200f</span><span class="s3">\\</span><span class="s1">u2028</span><span class="s3">\\</span><span class="s1">u2029</span><span class="s3">\\</span><span class="s1">u202d</span><span class="s3">\\</span><span class="s1">u202e</span><span class="s3">\\</span><span class="s1">u2066</span><span class="s3">\\</span><span class="s1">u2067</span><span class="s3">\\</span><span class="s1">u2069</span><span class="s3">\\</span><span class="s1">ufeff</span><span class="s3">\\</span><span class="s1">ufff9-</span><span class="s3">\\</span><span class="s1">ufffc]</span><span class="s3">\&quot;</span><span class="s1">, UnicodeRegexpSupport);</span><span class="s3">\n</span><span class="s1">const Names = {</span><span class="s3">\n    </span><span class="s1">0: </span><span class="s3">\&quot;</span><span class="s1">null</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">7: </span><span class="s3">\&quot;</span><span class="s1">bell</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">8: </span><span class="s3">\&quot;</span><span class="s1">backspace</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">10: </span><span class="s3">\&quot;</span><span class="s1">newline</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">11: </span><span class="s3">\&quot;</span><span class="s1">vertical tab</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">13: </span><span class="s3">\&quot;</span><span class="s1">carriage return</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">27: </span><span class="s3">\&quot;</span><span class="s1">escape</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">8203: </span><span class="s3">\&quot;</span><span class="s1">zero width space</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">8204: </span><span class="s3">\&quot;</span><span class="s1">zero width non-joiner</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">8205: </span><span class="s3">\&quot;</span><span class="s1">zero width joiner</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">8206: </span><span class="s3">\&quot;</span><span class="s1">left-to-right mark</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">8207: </span><span class="s3">\&quot;</span><span class="s1">right-to-left mark</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">8232: </span><span class="s3">\&quot;</span><span class="s1">line separator</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">8237: </span><span class="s3">\&quot;</span><span class="s1">left-to-right override</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">8238: </span><span class="s3">\&quot;</span><span class="s1">right-to-left override</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">8294: </span><span class="s3">\&quot;</span><span class="s1">left-to-right isolate</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">8295: </span><span class="s3">\&quot;</span><span class="s1">right-to-left isolate</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">8297: </span><span class="s3">\&quot;</span><span class="s1">pop directional isolate</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">8233: </span><span class="s3">\&quot;</span><span class="s1">paragraph separator</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">65279: </span><span class="s3">\&quot;</span><span class="s1">zero width no-break space</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">65532: </span><span class="s3">\&quot;</span><span class="s1">object replacement</span><span class="s3">\&quot;\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">let _supportsTabSize = null;</span><span class="s3">\n</span><span class="s1">function supportsTabSize() {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">if (_supportsTabSize == null &amp;&amp; typeof document != </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; document.body) {</span><span class="s3">\n        </span><span class="s1">let styles = document.body.style;</span><span class="s3">\n        </span><span class="s1">_supportsTabSize = ((_a = styles.tabSize) !== null &amp;&amp; _a !== void 0 ? _a : styles.MozTabSize) != null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return _supportsTabSize || false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const specialCharConfig = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine(configs) {</span><span class="s3">\n        </span><span class="s1">let config = combineConfig(configs, {</span><span class="s3">\n            </span><span class="s1">render: null,</span><span class="s3">\n            </span><span class="s1">specialChars: Specials,</span><span class="s3">\n            </span><span class="s1">addSpecialChars: null</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">if (config.replaceTabs = !supportsTabSize())</span><span class="s3">\n            </span><span class="s1">config.specialChars = new RegExp(</span><span class="s3">\&quot;\\</span><span class="s1">t|</span><span class="s3">\&quot; </span><span class="s1">+ config.specialChars.source, UnicodeRegexpSupport);</span><span class="s3">\n        </span><span class="s1">if (config.addSpecialChars)</span><span class="s3">\n            </span><span class="s1">config.specialChars = new RegExp(config.specialChars.source + </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">+ config.addSpecialChars.source, UnicodeRegexpSupport);</span><span class="s3">\n        </span><span class="s1">return config;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Returns an extension that installs highlighting of special</span><span class="s3">\n</span><span class="s1">characters.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function highlightSpecialChars(</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Configuration options.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">config = {}) {</span><span class="s3">\n    </span><span class="s1">return [specialCharConfig.of(config), specialCharPlugin()];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">let _plugin = null;</span><span class="s3">\n</span><span class="s1">function specialCharPlugin() {</span><span class="s3">\n    </span><span class="s1">return _plugin || (_plugin = ViewPlugin.fromClass(class {</span><span class="s3">\n        </span><span class="s1">constructor(view) {</span><span class="s3">\n            </span><span class="s1">this.view = view;</span><span class="s3">\n            </span><span class="s1">this.decorations = Decoration.none;</span><span class="s3">\n            </span><span class="s1">this.decorationCache = Object.create(null);</span><span class="s3">\n            </span><span class="s1">this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));</span><span class="s3">\n            </span><span class="s1">this.decorations = this.decorator.createDeco(view);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">makeDecorator(conf) {</span><span class="s3">\n            </span><span class="s1">return new MatchDecorator({</span><span class="s3">\n                </span><span class="s1">regexp: conf.specialChars,</span><span class="s3">\n                </span><span class="s1">decoration: (m, view, pos) =&gt; {</span><span class="s3">\n                    </span><span class="s1">let { doc } = view.state;</span><span class="s3">\n                    </span><span class="s1">let code = codePointAt(m[0], 0);</span><span class="s3">\n                    </span><span class="s1">if (code == 9) {</span><span class="s3">\n                        </span><span class="s1">let line = doc.lineAt(pos);</span><span class="s3">\n                        </span><span class="s1">let size = view.state.tabSize, col = countColumn(line.text, size, pos - line.from);</span><span class="s3">\n                        </span><span class="s1">return Decoration.replace({</span><span class="s3">\n                            </span><span class="s1">widget: new TabWidget((size - (col % size)) * this.view.defaultCharacterWidth / this.view.scaleX)</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">return this.decorationCache[code] ||</span><span class="s3">\n                        </span><span class="s1">(this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));</span><span class="s3">\n                </span><span class="s1">},</span><span class="s3">\n                </span><span class="s1">boundary: conf.replaceTabs ? undefined : /[^]/</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">update(update) {</span><span class="s3">\n            </span><span class="s1">let conf = update.state.facet(specialCharConfig);</span><span class="s3">\n            </span><span class="s1">if (update.startState.facet(specialCharConfig) != conf) {</span><span class="s3">\n                </span><span class="s1">this.decorator = this.makeDecorator(conf);</span><span class="s3">\n                </span><span class="s1">this.decorations = this.decorator.createDeco(update.view);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this.decorations = this.decorator.updateDeco(update, this.decorations);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">decorations: v =&gt; v.decorations</span><span class="s3">\n    </span><span class="s1">}));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const DefaultPlaceholder = </span><span class="s3">\&quot;\\</span><span class="s1">u2022</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">// Assigns placeholder characters from the Control Pictures block to</span><span class="s3">\n</span><span class="s1">// ASCII control characters</span><span class="s3">\n</span><span class="s1">function placeholder$1(code) {</span><span class="s3">\n    </span><span class="s1">if (code &gt;= 32)</span><span class="s3">\n        </span><span class="s1">return DefaultPlaceholder;</span><span class="s3">\n    </span><span class="s1">if (code == 10)</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;\\</span><span class="s1">u2424</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">return String.fromCharCode(9216 + code);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class SpecialCharWidget extends WidgetType {</span><span class="s3">\n    </span><span class="s1">constructor(options, code) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.options = options;</span><span class="s3">\n        </span><span class="s1">this.code = code;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(other) { return other.code == this.code; }</span><span class="s3">\n    </span><span class="s1">toDOM(view) {</span><span class="s3">\n        </span><span class="s1">let ph = placeholder$1(this.code);</span><span class="s3">\n        </span><span class="s1">let desc = view.state.phrase(</span><span class="s3">\&quot;</span><span class="s1">Control character</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ (Names[this.code] || </span><span class="s3">\&quot;</span><span class="s1">0x</span><span class="s3">\&quot; </span><span class="s1">+ this.code.toString(16));</span><span class="s3">\n        </span><span class="s1">let custom = this.options.render &amp;&amp; this.options.render(this.code, desc, ph);</span><span class="s3">\n        </span><span class="s1">if (custom)</span><span class="s3">\n            </span><span class="s1">return custom;</span><span class="s3">\n        </span><span class="s1">let span = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">span.textContent = ph;</span><span class="s3">\n        </span><span class="s1">span.title = desc;</span><span class="s3">\n        </span><span class="s1">span.setAttribute(</span><span class="s3">\&quot;</span><span class="s1">aria-label</span><span class="s3">\&quot;</span><span class="s1">, desc);</span><span class="s3">\n        </span><span class="s1">span.className = </span><span class="s3">\&quot;</span><span class="s1">cm-specialChar</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">return span;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ignoreEvent() { return false; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class TabWidget extends WidgetType {</span><span class="s3">\n    </span><span class="s1">constructor(width) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.width = width;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(other) { return other.width == this.width; }</span><span class="s3">\n    </span><span class="s1">toDOM() {</span><span class="s3">\n        </span><span class="s1">let span = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">span.textContent = </span><span class="s3">\&quot;\\</span><span class="s1">t</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">span.className = </span><span class="s3">\&quot;</span><span class="s1">cm-tab</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">span.style.width = this.width + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">return span;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ignoreEvent() { return false; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const plugin = /*@__PURE__*/ViewPlugin.fromClass(class {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.height = 1000;</span><span class="s3">\n        </span><span class="s1">this.attrs = { style: </span><span class="s3">\&quot;</span><span class="s1">padding-bottom: 1000px</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">let { view } = update;</span><span class="s3">\n        </span><span class="s1">let height = view.viewState.editorHeight -</span><span class="s3">\n            </span><span class="s1">view.defaultLineHeight - view.documentPadding.top - 0.5;</span><span class="s3">\n        </span><span class="s1">if (height &gt;= 0 &amp;&amp; height != this.height) {</span><span class="s3">\n            </span><span class="s1">this.height = height;</span><span class="s3">\n            </span><span class="s1">this.attrs = { style: `padding-bottom: ${height}px` };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Returns an extension that makes sure the content has a bottom</span><span class="s3">\n</span><span class="s1">margin equivalent to the height of the editor, minus one line</span><span class="s3">\n</span><span class="s1">height, so that every line in the document can be scrolled to the</span><span class="s3">\n</span><span class="s1">top of the editor.</span><span class="s3">\n\n</span><span class="s1">This is only meaningful when the editor is scrollable, and should</span><span class="s3">\n</span><span class="s1">not be enabled in editors that take the size of their content.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function scrollPastEnd() {</span><span class="s3">\n    </span><span class="s1">return [plugin, contentAttributes.of(view =&gt; { var _a; return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null; })];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Mark lines that have a cursor on them with the `</span><span class="s3">\&quot;</span><span class="s1">cm-activeLine</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n</span><span class="s1">DOM class.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function highlightActiveLine() {</span><span class="s3">\n    </span><span class="s1">return activeLineHighlighter;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const lineDeco = /*@__PURE__*/Decoration.line({ class: </span><span class="s3">\&quot;</span><span class="s1">cm-activeLine</span><span class="s3">\&quot; </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const activeLineHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {</span><span class="s3">\n    </span><span class="s1">constructor(view) {</span><span class="s3">\n        </span><span class="s1">this.decorations = this.getDeco(view);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">if (update.docChanged || update.selectionSet)</span><span class="s3">\n            </span><span class="s1">this.decorations = this.getDeco(update.view);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getDeco(view) {</span><span class="s3">\n        </span><span class="s1">let lastLineStart = -1, deco = [];</span><span class="s3">\n        </span><span class="s1">for (let r of view.state.selection.ranges) {</span><span class="s3">\n            </span><span class="s1">let line = view.lineBlockAt(r.head);</span><span class="s3">\n            </span><span class="s1">if (line.from &gt; lastLineStart) {</span><span class="s3">\n                </span><span class="s1">deco.push(lineDeco.range(line.from));</span><span class="s3">\n                </span><span class="s1">lastLineStart = line.from;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return Decoration.set(deco);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">decorations: v =&gt; v.decorations</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">class Placeholder extends WidgetType {</span><span class="s3">\n    </span><span class="s1">constructor(content) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.content = content;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toDOM(view) {</span><span class="s3">\n        </span><span class="s1">let wrap = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">wrap.className = </span><span class="s3">\&quot;</span><span class="s1">cm-placeholder</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">wrap.style.pointerEvents = </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">wrap.appendChild(typeof this.content == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? document.createTextNode(this.content) :</span><span class="s3">\n            </span><span class="s1">typeof this.content == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">? this.content(view) :</span><span class="s3">\n                </span><span class="s1">this.content.cloneNode(true));</span><span class="s3">\n        </span><span class="s1">if (typeof this.content == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">wrap.setAttribute(</span><span class="s3">\&quot;</span><span class="s1">aria-label</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">placeholder </span><span class="s3">\&quot; </span><span class="s1">+ this.content);</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">wrap.setAttribute(</span><span class="s3">\&quot;</span><span class="s1">aria-hidden</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return wrap;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">coordsAt(dom) {</span><span class="s3">\n        </span><span class="s1">let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];</span><span class="s3">\n        </span><span class="s1">if (!rects.length)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">let style = window.getComputedStyle(dom.parentNode);</span><span class="s3">\n        </span><span class="s1">let rect = flattenRect(rects[0], style.direction != </span><span class="s3">\&quot;</span><span class="s1">rtl</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">let lineHeight = parseInt(style.lineHeight);</span><span class="s3">\n        </span><span class="s1">if (rect.bottom - rect.top &gt; lineHeight * 1.5)</span><span class="s3">\n            </span><span class="s1">return { left: rect.left, right: rect.right, top: rect.top, bottom: rect.top + lineHeight };</span><span class="s3">\n        </span><span class="s1">return rect;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ignoreEvent() { return false; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Extension that enables a placeholdera piece of example content</span><span class="s3">\n</span><span class="s1">to show when the editor is empty.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function placeholder(content) {</span><span class="s3">\n    </span><span class="s1">return ViewPlugin.fromClass(class {</span><span class="s3">\n        </span><span class="s1">constructor(view) {</span><span class="s3">\n            </span><span class="s1">this.view = view;</span><span class="s3">\n            </span><span class="s1">this.placeholder = content</span><span class="s3">\n                </span><span class="s1">? Decoration.set([Decoration.widget({ widget: new Placeholder(content), side: 1 }).range(0)])</span><span class="s3">\n                </span><span class="s1">: Decoration.none;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">get decorations() { return this.view.state.doc.length ? Decoration.none : this.placeholder; }</span><span class="s3">\n    </span><span class="s1">}, { decorations: v =&gt; v.decorations });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Don't compute precise column positions for line offsets above this</span><span class="s3">\n</span><span class="s1">// (since it could get expensive). Assume offset==column for them.</span><span class="s3">\n</span><span class="s1">const MaxOff = 2000;</span><span class="s3">\n</span><span class="s1">function rectangleFor(state, a, b) {</span><span class="s3">\n    </span><span class="s1">let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);</span><span class="s3">\n    </span><span class="s1">let ranges = [];</span><span class="s3">\n    </span><span class="s1">if (a.off &gt; MaxOff || b.off &gt; MaxOff || a.col &lt; 0 || b.col &lt; 0) {</span><span class="s3">\n        </span><span class="s1">let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);</span><span class="s3">\n        </span><span class="s1">for (let i = startLine; i &lt;= endLine; i++) {</span><span class="s3">\n            </span><span class="s1">let line = state.doc.line(i);</span><span class="s3">\n            </span><span class="s1">if (line.length &lt;= endOff)</span><span class="s3">\n                </span><span class="s1">ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);</span><span class="s3">\n        </span><span class="s1">for (let i = startLine; i &lt;= endLine; i++) {</span><span class="s3">\n            </span><span class="s1">let line = state.doc.line(i);</span><span class="s3">\n            </span><span class="s1">let start = findColumn(line.text, startCol, state.tabSize, true);</span><span class="s3">\n            </span><span class="s1">if (start &lt; 0) {</span><span class="s3">\n                </span><span class="s1">ranges.push(EditorSelection.cursor(line.to));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let end = findColumn(line.text, endCol, state.tabSize);</span><span class="s3">\n                </span><span class="s1">ranges.push(EditorSelection.range(line.from + start, line.from + end));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ranges;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function absoluteColumn(view, x) {</span><span class="s3">\n    </span><span class="s1">let ref = view.coordsAtPos(view.viewport.from);</span><span class="s3">\n    </span><span class="s1">return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getPos(view, event) {</span><span class="s3">\n    </span><span class="s1">let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);</span><span class="s3">\n    </span><span class="s1">let line = view.state.doc.lineAt(offset), off = offset - line.from;</span><span class="s3">\n    </span><span class="s1">let col = off &gt; MaxOff ? -1</span><span class="s3">\n        </span><span class="s1">: off == line.length ? absoluteColumn(view, event.clientX)</span><span class="s3">\n            </span><span class="s1">: countColumn(line.text, view.state.tabSize, offset - line.from);</span><span class="s3">\n    </span><span class="s1">return { line: line.number, col, off };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function rectangleSelectionStyle(view, event) {</span><span class="s3">\n    </span><span class="s1">let start = getPos(view, event), startSel = view.state.selection;</span><span class="s3">\n    </span><span class="s1">if (!start)</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">update(update) {</span><span class="s3">\n            </span><span class="s1">if (update.docChanged) {</span><span class="s3">\n                </span><span class="s1">let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);</span><span class="s3">\n                </span><span class="s1">let newLine = update.state.doc.lineAt(newStart);</span><span class="s3">\n                </span><span class="s1">start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };</span><span class="s3">\n                </span><span class="s1">startSel = startSel.map(update.changes);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">get(event, _extend, multiple) {</span><span class="s3">\n            </span><span class="s1">let cur = getPos(view, event);</span><span class="s3">\n            </span><span class="s1">if (!cur)</span><span class="s3">\n                </span><span class="s1">return startSel;</span><span class="s3">\n            </span><span class="s1">let ranges = rectangleFor(view.state, start, cur);</span><span class="s3">\n            </span><span class="s1">if (!ranges.length)</span><span class="s3">\n                </span><span class="s1">return startSel;</span><span class="s3">\n            </span><span class="s1">if (multiple)</span><span class="s3">\n                </span><span class="s1">return EditorSelection.create(ranges.concat(startSel.ranges));</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">return EditorSelection.create(ranges);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Create an extension that enables rectangular selections. By</span><span class="s3">\n</span><span class="s1">default, it will react to left mouse drag with the Alt key held</span><span class="s3">\n</span><span class="s1">down. When such a selection occurs, the text within the rectangle</span><span class="s3">\n</span><span class="s1">that was dragged over will be selected, as one selection</span><span class="s3">\n</span><span class="s1">[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function rectangularSelection(options) {</span><span class="s3">\n    </span><span class="s1">let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e =&gt; e.altKey &amp;&amp; e.button == 0);</span><span class="s3">\n    </span><span class="s1">return EditorView.mouseSelectionStyle.of((view, event) =&gt; filter(event) ? rectangleSelectionStyle(view, event) : null);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const keys = {</span><span class="s3">\n    </span><span class="s1">Alt: [18, e =&gt; !!e.altKey],</span><span class="s3">\n    </span><span class="s1">Control: [17, e =&gt; !!e.ctrlKey],</span><span class="s3">\n    </span><span class="s1">Shift: [16, e =&gt; !!e.shiftKey],</span><span class="s3">\n    </span><span class="s1">Meta: [91, e =&gt; !!e.metaKey]</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const showCrosshair = { style: </span><span class="s3">\&quot;</span><span class="s1">cursor: crosshair</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Returns an extension that turns the pointer cursor into a</span><span class="s3">\n</span><span class="s1">crosshair when a given modifier key, defaulting to Alt, is held</span><span class="s3">\n</span><span class="s1">down. Can serve as a visual hint that rectangular selection is</span><span class="s3">\n</span><span class="s1">going to happen when paired with</span><span class="s3">\n</span><span class="s1">[`rectangularSelection`](https://codemirror.net/6/docs/ref/#view.rectangularSelection).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function crosshairCursor(options = {}) {</span><span class="s3">\n    </span><span class="s1">let [code, getter] = keys[options.key || </span><span class="s3">\&quot;</span><span class="s1">Alt</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n    </span><span class="s1">let plugin = ViewPlugin.fromClass(class {</span><span class="s3">\n        </span><span class="s1">constructor(view) {</span><span class="s3">\n            </span><span class="s1">this.view = view;</span><span class="s3">\n            </span><span class="s1">this.isDown = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">set(isDown) {</span><span class="s3">\n            </span><span class="s1">if (this.isDown != isDown) {</span><span class="s3">\n                </span><span class="s1">this.isDown = isDown;</span><span class="s3">\n                </span><span class="s1">this.view.update([]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">eventObservers: {</span><span class="s3">\n            </span><span class="s1">keydown(e) {</span><span class="s3">\n                </span><span class="s1">this.set(e.keyCode == code || getter(e));</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">keyup(e) {</span><span class="s3">\n                </span><span class="s1">if (e.keyCode == code || !getter(e))</span><span class="s3">\n                    </span><span class="s1">this.set(false);</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">mousemove(e) {</span><span class="s3">\n                </span><span class="s1">this.set(getter(e));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return [</span><span class="s3">\n        </span><span class="s1">plugin,</span><span class="s3">\n        </span><span class="s1">EditorView.contentAttributes.of(view =&gt; { var _a; return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null; })</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const Outside = </span><span class="s3">\&quot;</span><span class="s1">-10000px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">class TooltipViewManager {</span><span class="s3">\n    </span><span class="s1">constructor(view, facet, createTooltipView, removeTooltipView) {</span><span class="s3">\n        </span><span class="s1">this.facet = facet;</span><span class="s3">\n        </span><span class="s1">this.createTooltipView = createTooltipView;</span><span class="s3">\n        </span><span class="s1">this.removeTooltipView = removeTooltipView;</span><span class="s3">\n        </span><span class="s1">this.input = view.state.facet(facet);</span><span class="s3">\n        </span><span class="s1">this.tooltips = this.input.filter(t =&gt; t);</span><span class="s3">\n        </span><span class="s1">let prev = null;</span><span class="s3">\n        </span><span class="s1">this.tooltipViews = this.tooltips.map(t =&gt; prev = createTooltipView(t, prev));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update, above) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">let input = update.state.facet(this.facet);</span><span class="s3">\n        </span><span class="s1">let tooltips = input.filter(x =&gt; x);</span><span class="s3">\n        </span><span class="s1">if (input === this.input) {</span><span class="s3">\n            </span><span class="s1">for (let t of this.tooltipViews)</span><span class="s3">\n                </span><span class="s1">if (t.update)</span><span class="s3">\n                    </span><span class="s1">t.update(update);</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let tooltipViews = [], newAbove = above ? [] : null;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; tooltips.length; i++) {</span><span class="s3">\n            </span><span class="s1">let tip = tooltips[i], known = -1;</span><span class="s3">\n            </span><span class="s1">if (!tip)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; this.tooltips.length; i++) {</span><span class="s3">\n                </span><span class="s1">let other = this.tooltips[i];</span><span class="s3">\n                </span><span class="s1">if (other &amp;&amp; other.create == tip.create)</span><span class="s3">\n                    </span><span class="s1">known = i;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (known &lt; 0) {</span><span class="s3">\n                </span><span class="s1">tooltipViews[i] = this.createTooltipView(tip, i ? tooltipViews[i - 1] : null);</span><span class="s3">\n                </span><span class="s1">if (newAbove)</span><span class="s3">\n                    </span><span class="s1">newAbove[i] = !!tip.above;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let tooltipView = tooltipViews[i] = this.tooltipViews[known];</span><span class="s3">\n                </span><span class="s1">if (newAbove)</span><span class="s3">\n                    </span><span class="s1">newAbove[i] = above[known];</span><span class="s3">\n                </span><span class="s1">if (tooltipView.update)</span><span class="s3">\n                    </span><span class="s1">tooltipView.update(update);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let t of this.tooltipViews)</span><span class="s3">\n            </span><span class="s1">if (tooltipViews.indexOf(t) &lt; 0) {</span><span class="s3">\n                </span><span class="s1">this.removeTooltipView(t);</span><span class="s3">\n                </span><span class="s1">(_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (above) {</span><span class="s3">\n            </span><span class="s1">newAbove.forEach((val, i) =&gt; above[i] = val);</span><span class="s3">\n            </span><span class="s1">above.length = newAbove.length;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.input = input;</span><span class="s3">\n        </span><span class="s1">this.tooltips = tooltips;</span><span class="s3">\n        </span><span class="s1">this.tooltipViews = tooltipViews;</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Creates an extension that configures tooltip behavior.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function tooltips(config = {}) {</span><span class="s3">\n    </span><span class="s1">return tooltipConfig.of(config);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function windowSpace(view) {</span><span class="s3">\n    </span><span class="s1">let { win } = view;</span><span class="s3">\n    </span><span class="s1">return { top: 0, left: 0, bottom: win.innerHeight, right: win.innerWidth };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const tooltipConfig = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine: values =&gt; {</span><span class="s3">\n        </span><span class="s1">var _a, _b, _c;</span><span class="s3">\n        </span><span class="s1">return ({</span><span class="s3">\n            </span><span class="s1">position: browser.ios ? </span><span class="s3">\&quot;</span><span class="s1">absolute</span><span class="s3">\&quot; </span><span class="s1">: ((_a = values.find(conf =&gt; conf.position)) === null || _a === void 0 ? void 0 : _a.position) || </span><span class="s3">\&quot;</span><span class="s1">fixed</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">parent: ((_b = values.find(conf =&gt; conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,</span><span class="s3">\n            </span><span class="s1">tooltipSpace: ((_c = values.find(conf =&gt; conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const knownHeight = /*@__PURE__*/new WeakMap();</span><span class="s3">\n</span><span class="s1">const tooltipPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {</span><span class="s3">\n    </span><span class="s1">constructor(view) {</span><span class="s3">\n        </span><span class="s1">this.view = view;</span><span class="s3">\n        </span><span class="s1">this.above = [];</span><span class="s3">\n        </span><span class="s1">this.inView = true;</span><span class="s3">\n        </span><span class="s1">this.madeAbsolute = false;</span><span class="s3">\n        </span><span class="s1">this.lastTransaction = 0;</span><span class="s3">\n        </span><span class="s1">this.measureTimeout = -1;</span><span class="s3">\n        </span><span class="s1">let config = view.state.facet(tooltipConfig);</span><span class="s3">\n        </span><span class="s1">this.position = config.position;</span><span class="s3">\n        </span><span class="s1">this.parent = config.parent;</span><span class="s3">\n        </span><span class="s1">this.classes = view.themeClasses;</span><span class="s3">\n        </span><span class="s1">this.createContainer();</span><span class="s3">\n        </span><span class="s1">this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };</span><span class="s3">\n        </span><span class="s1">this.resizeObserver = typeof ResizeObserver == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">? new ResizeObserver(() =&gt; this.measureSoon()) : null;</span><span class="s3">\n        </span><span class="s1">this.manager = new TooltipViewManager(view, showTooltip, (t, p) =&gt; this.createTooltip(t, p), t =&gt; {</span><span class="s3">\n            </span><span class="s1">if (this.resizeObserver)</span><span class="s3">\n                </span><span class="s1">this.resizeObserver.unobserve(t.dom);</span><span class="s3">\n            </span><span class="s1">t.dom.remove();</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.above = this.manager.tooltips.map(t =&gt; !!t.above);</span><span class="s3">\n        </span><span class="s1">this.intersectionObserver = typeof IntersectionObserver == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">? new IntersectionObserver(entries =&gt; {</span><span class="s3">\n            </span><span class="s1">if (Date.now() &gt; this.lastTransaction - 50 &amp;&amp;</span><span class="s3">\n                </span><span class="s1">entries.length &gt; 0 &amp;&amp; entries[entries.length - 1].intersectionRatio &lt; 1)</span><span class="s3">\n                </span><span class="s1">this.measureSoon();</span><span class="s3">\n        </span><span class="s1">}, { threshold: [1] }) : null;</span><span class="s3">\n        </span><span class="s1">this.observeIntersection();</span><span class="s3">\n        </span><span class="s1">view.win.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">resize</span><span class="s3">\&quot;</span><span class="s1">, this.measureSoon = this.measureSoon.bind(this));</span><span class="s3">\n        </span><span class="s1">this.maybeMeasure();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createContainer() {</span><span class="s3">\n        </span><span class="s1">if (this.parent) {</span><span class="s3">\n            </span><span class="s1">this.container = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">this.container.style.position = </span><span class="s3">\&quot;</span><span class="s1">relative</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">this.container.className = this.view.themeClasses;</span><span class="s3">\n            </span><span class="s1">this.parent.appendChild(this.container);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.container = this.view.dom;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">observeIntersection() {</span><span class="s3">\n        </span><span class="s1">if (this.intersectionObserver) {</span><span class="s3">\n            </span><span class="s1">this.intersectionObserver.disconnect();</span><span class="s3">\n            </span><span class="s1">for (let tooltip of this.manager.tooltipViews)</span><span class="s3">\n                </span><span class="s1">this.intersectionObserver.observe(tooltip.dom);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">measureSoon() {</span><span class="s3">\n        </span><span class="s1">if (this.measureTimeout &lt; 0)</span><span class="s3">\n            </span><span class="s1">this.measureTimeout = setTimeout(() =&gt; {</span><span class="s3">\n                </span><span class="s1">this.measureTimeout = -1;</span><span class="s3">\n                </span><span class="s1">this.maybeMeasure();</span><span class="s3">\n            </span><span class="s1">}, 50);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">if (update.transactions.length)</span><span class="s3">\n            </span><span class="s1">this.lastTransaction = Date.now();</span><span class="s3">\n        </span><span class="s1">let updated = this.manager.update(update, this.above);</span><span class="s3">\n        </span><span class="s1">if (updated)</span><span class="s3">\n            </span><span class="s1">this.observeIntersection();</span><span class="s3">\n        </span><span class="s1">let shouldMeasure = updated || update.geometryChanged;</span><span class="s3">\n        </span><span class="s1">let newConfig = update.state.facet(tooltipConfig);</span><span class="s3">\n        </span><span class="s1">if (newConfig.position != this.position &amp;&amp; !this.madeAbsolute) {</span><span class="s3">\n            </span><span class="s1">this.position = newConfig.position;</span><span class="s3">\n            </span><span class="s1">for (let t of this.manager.tooltipViews)</span><span class="s3">\n                </span><span class="s1">t.dom.style.position = this.position;</span><span class="s3">\n            </span><span class="s1">shouldMeasure = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (newConfig.parent != this.parent) {</span><span class="s3">\n            </span><span class="s1">if (this.parent)</span><span class="s3">\n                </span><span class="s1">this.container.remove();</span><span class="s3">\n            </span><span class="s1">this.parent = newConfig.parent;</span><span class="s3">\n            </span><span class="s1">this.createContainer();</span><span class="s3">\n            </span><span class="s1">for (let t of this.manager.tooltipViews)</span><span class="s3">\n                </span><span class="s1">this.container.appendChild(t.dom);</span><span class="s3">\n            </span><span class="s1">shouldMeasure = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (this.parent &amp;&amp; this.view.themeClasses != this.classes) {</span><span class="s3">\n            </span><span class="s1">this.classes = this.container.className = this.view.themeClasses;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (shouldMeasure)</span><span class="s3">\n            </span><span class="s1">this.maybeMeasure();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createTooltip(tooltip, prev) {</span><span class="s3">\n        </span><span class="s1">let tooltipView = tooltip.create(this.view);</span><span class="s3">\n        </span><span class="s1">let before = prev ? prev.dom : null;</span><span class="s3">\n        </span><span class="s1">tooltipView.dom.classList.add(</span><span class="s3">\&quot;</span><span class="s1">cm-tooltip</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (tooltip.arrow &amp;&amp; !tooltipView.dom.querySelector(</span><span class="s3">\&quot;</span><span class="s1">.cm-tooltip &gt; .cm-tooltip-arrow</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">let arrow = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">arrow.className = </span><span class="s3">\&quot;</span><span class="s1">cm-tooltip-arrow</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">tooltipView.dom.appendChild(arrow);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">tooltipView.dom.style.position = this.position;</span><span class="s3">\n        </span><span class="s1">tooltipView.dom.style.top = Outside;</span><span class="s3">\n        </span><span class="s1">tooltipView.dom.style.left = </span><span class="s3">\&quot;</span><span class="s1">0px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.container.insertBefore(tooltipView.dom, before);</span><span class="s3">\n        </span><span class="s1">if (tooltipView.mount)</span><span class="s3">\n            </span><span class="s1">tooltipView.mount(this.view);</span><span class="s3">\n        </span><span class="s1">if (this.resizeObserver)</span><span class="s3">\n            </span><span class="s1">this.resizeObserver.observe(tooltipView.dom);</span><span class="s3">\n        </span><span class="s1">return tooltipView;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">destroy() {</span><span class="s3">\n        </span><span class="s1">var _a, _b, _c;</span><span class="s3">\n        </span><span class="s1">this.view.win.removeEventListener(</span><span class="s3">\&quot;</span><span class="s1">resize</span><span class="s3">\&quot;</span><span class="s1">, this.measureSoon);</span><span class="s3">\n        </span><span class="s1">for (let tooltipView of this.manager.tooltipViews) {</span><span class="s3">\n            </span><span class="s1">tooltipView.dom.remove();</span><span class="s3">\n            </span><span class="s1">(_a = tooltipView.destroy) === null || _a === void 0 ? void 0 : _a.call(tooltipView);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.parent)</span><span class="s3">\n            </span><span class="s1">this.container.remove();</span><span class="s3">\n        </span><span class="s1">(_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();</span><span class="s3">\n        </span><span class="s1">(_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();</span><span class="s3">\n        </span><span class="s1">clearTimeout(this.measureTimeout);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">readMeasure() {</span><span class="s3">\n        </span><span class="s1">let scaleX = 1, scaleY = 1, makeAbsolute = false;</span><span class="s3">\n        </span><span class="s1">if (this.position == </span><span class="s3">\&quot;</span><span class="s1">fixed</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; this.manager.tooltipViews.length) {</span><span class="s3">\n            </span><span class="s1">let { dom } = this.manager.tooltipViews[0];</span><span class="s3">\n            </span><span class="s1">if (browser.gecko) {</span><span class="s3">\n                </span><span class="s1">// Firefox sets the element's `offsetParent` to the</span><span class="s3">\n                </span><span class="s1">// transformed element when a transform interferes with fixed</span><span class="s3">\n                </span><span class="s1">// positioning.</span><span class="s3">\n                </span><span class="s1">makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (dom.style.top == Outside &amp;&amp; dom.style.left == </span><span class="s3">\&quot;</span><span class="s1">0px</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">// On other browsers, we have to awkwardly try and use other</span><span class="s3">\n                </span><span class="s1">// information to detect a transform.</span><span class="s3">\n                </span><span class="s1">let rect = dom.getBoundingClientRect();</span><span class="s3">\n                </span><span class="s1">makeAbsolute = Math.abs(rect.top + 10000) &gt; 1 || Math.abs(rect.left) &gt; 1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (makeAbsolute || this.position == </span><span class="s3">\&quot;</span><span class="s1">absolute</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">if (this.parent) {</span><span class="s3">\n                </span><span class="s1">let rect = this.parent.getBoundingClientRect();</span><span class="s3">\n                </span><span class="s1">if (rect.width &amp;&amp; rect.height) {</span><span class="s3">\n                    </span><span class="s1">scaleX = rect.width / this.parent.offsetWidth;</span><span class="s3">\n                    </span><span class="s1">scaleY = rect.height / this.parent.offsetHeight;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">({ scaleX, scaleY } = this.view.viewState);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let visible = this.view.scrollDOM.getBoundingClientRect(), margins = getScrollMargins(this.view);</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">visible: {</span><span class="s3">\n                </span><span class="s1">left: visible.left + margins.left, top: visible.top + margins.top,</span><span class="s3">\n                </span><span class="s1">right: visible.right - margins.right, bottom: visible.bottom - margins.bottom</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),</span><span class="s3">\n            </span><span class="s1">pos: this.manager.tooltips.map((t, i) =&gt; {</span><span class="s3">\n                </span><span class="s1">let tv = this.manager.tooltipViews[i];</span><span class="s3">\n                </span><span class="s1">return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);</span><span class="s3">\n            </span><span class="s1">}),</span><span class="s3">\n            </span><span class="s1">size: this.manager.tooltipViews.map(({ dom }) =&gt; dom.getBoundingClientRect()),</span><span class="s3">\n            </span><span class="s1">space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),</span><span class="s3">\n            </span><span class="s1">scaleX, scaleY, makeAbsolute</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">writeMeasure(measured) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">if (measured.makeAbsolute) {</span><span class="s3">\n            </span><span class="s1">this.madeAbsolute = true;</span><span class="s3">\n            </span><span class="s1">this.position = </span><span class="s3">\&quot;</span><span class="s1">absolute</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">for (let t of this.manager.tooltipViews)</span><span class="s3">\n                </span><span class="s1">t.dom.style.position = </span><span class="s3">\&quot;</span><span class="s1">absolute</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let { visible, space, scaleX, scaleY } = measured;</span><span class="s3">\n        </span><span class="s1">let others = [];</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.manager.tooltips.length; i++) {</span><span class="s3">\n            </span><span class="s1">let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;</span><span class="s3">\n            </span><span class="s1">let pos = measured.pos[i], size = measured.size[i];</span><span class="s3">\n            </span><span class="s1">// Hide tooltips that are outside of the editor.</span><span class="s3">\n            </span><span class="s1">if (!pos || tooltip.clip !== false &amp;&amp; (pos.bottom &lt;= Math.max(visible.top, space.top) ||</span><span class="s3">\n                </span><span class="s1">pos.top &gt;= Math.min(visible.bottom, space.bottom) ||</span><span class="s3">\n                </span><span class="s1">pos.right &lt; Math.max(visible.left, space.left) - .1 ||</span><span class="s3">\n                </span><span class="s1">pos.left &gt; Math.min(visible.right, space.right) + .1)) {</span><span class="s3">\n                </span><span class="s1">dom.style.top = Outside;</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let arrow = tooltip.arrow ? tView.dom.querySelector(</span><span class="s3">\&quot;</span><span class="s1">.cm-tooltip-arrow</span><span class="s3">\&quot;</span><span class="s1">) : null;</span><span class="s3">\n            </span><span class="s1">let arrowHeight = arrow ? 7 /* Arrow.Size */ : 0;</span><span class="s3">\n            </span><span class="s1">let width = size.right - size.left, height = (_a = knownHeight.get(tView)) !== null &amp;&amp; _a !== void 0 ? _a : size.bottom - size.top;</span><span class="s3">\n            </span><span class="s1">let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;</span><span class="s3">\n            </span><span class="s1">let left = size.width &gt; space.right - space.left</span><span class="s3">\n                </span><span class="s1">? (ltr ? space.left : space.right - size.width)</span><span class="s3">\n                </span><span class="s1">: ltr ? Math.max(space.left, Math.min(pos.left - (arrow ? 14 /* Arrow.Offset */ : 0) + offset.x, space.right - width))</span><span class="s3">\n                    </span><span class="s1">: Math.min(Math.max(space.left, pos.left - width + (arrow ? 14 /* Arrow.Offset */ : 0) - offset.x), space.right - width);</span><span class="s3">\n            </span><span class="s1">let above = this.above[i];</span><span class="s3">\n            </span><span class="s1">if (!tooltip.strictSide &amp;&amp; (above</span><span class="s3">\n                </span><span class="s1">? pos.top - height - arrowHeight - offset.y &lt; space.top</span><span class="s3">\n                </span><span class="s1">: pos.bottom + height + arrowHeight + offset.y &gt; space.bottom) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">above == (space.bottom - pos.bottom &gt; pos.top - space.top))</span><span class="s3">\n                </span><span class="s1">above = this.above[i] = !above;</span><span class="s3">\n            </span><span class="s1">let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;</span><span class="s3">\n            </span><span class="s1">if (spaceVert &lt; height &amp;&amp; tView.resize !== false) {</span><span class="s3">\n                </span><span class="s1">if (spaceVert &lt; this.view.defaultLineHeight) {</span><span class="s3">\n                    </span><span class="s1">dom.style.top = Outside;</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">knownHeight.set(tView, height);</span><span class="s3">\n                </span><span class="s1">dom.style.height = (height = spaceVert) / scaleY + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (dom.style.height) {</span><span class="s3">\n                </span><span class="s1">dom.style.height = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;</span><span class="s3">\n            </span><span class="s1">let right = left + width;</span><span class="s3">\n            </span><span class="s1">if (tView.overlap !== true)</span><span class="s3">\n                </span><span class="s1">for (let r of others)</span><span class="s3">\n                    </span><span class="s1">if (r.left &lt; right &amp;&amp; r.right &gt; left &amp;&amp; r.top &lt; top + height &amp;&amp; r.bottom &gt; top)</span><span class="s3">\n                        </span><span class="s1">top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;</span><span class="s3">\n            </span><span class="s1">if (this.position == </span><span class="s3">\&quot;</span><span class="s1">absolute</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">dom.style.top = (top - measured.parent.top) / scaleY + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">setLeftStyle(dom, (left - measured.parent.left) / scaleX);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">dom.style.top = top / scaleY + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">setLeftStyle(dom, left / scaleX);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (arrow) {</span><span class="s3">\n                </span><span class="s1">let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 /* Arrow.Offset */ - 7 /* Arrow.Size */);</span><span class="s3">\n                </span><span class="s1">arrow.style.left = arrowLeft / scaleX + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (tView.overlap !== true)</span><span class="s3">\n                </span><span class="s1">others.push({ left, top, right, bottom: top + height });</span><span class="s3">\n            </span><span class="s1">dom.classList.toggle(</span><span class="s3">\&quot;</span><span class="s1">cm-tooltip-above</span><span class="s3">\&quot;</span><span class="s1">, above);</span><span class="s3">\n            </span><span class="s1">dom.classList.toggle(</span><span class="s3">\&quot;</span><span class="s1">cm-tooltip-below</span><span class="s3">\&quot;</span><span class="s1">, !above);</span><span class="s3">\n            </span><span class="s1">if (tView.positioned)</span><span class="s3">\n                </span><span class="s1">tView.positioned(measured.space);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">maybeMeasure() {</span><span class="s3">\n        </span><span class="s1">if (this.manager.tooltips.length) {</span><span class="s3">\n            </span><span class="s1">if (this.view.inView)</span><span class="s3">\n                </span><span class="s1">this.view.requestMeasure(this.measureReq);</span><span class="s3">\n            </span><span class="s1">if (this.inView != this.view.inView) {</span><span class="s3">\n                </span><span class="s1">this.inView = this.view.inView;</span><span class="s3">\n                </span><span class="s1">if (!this.inView)</span><span class="s3">\n                    </span><span class="s1">for (let tv of this.manager.tooltipViews)</span><span class="s3">\n                        </span><span class="s1">tv.dom.style.top = Outside;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">eventObservers: {</span><span class="s3">\n        </span><span class="s1">scroll() { this.maybeMeasure(); }</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">function setLeftStyle(elt, value) {</span><span class="s3">\n    </span><span class="s1">let current = parseInt(elt.style.left, 10);</span><span class="s3">\n    </span><span class="s1">if (isNaN(current) || Math.abs(value - current) &gt; 1)</span><span class="s3">\n        </span><span class="s1">elt.style.left = value + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const baseTheme = /*@__PURE__*/EditorView.baseTheme({</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-tooltip</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">zIndex: 500,</span><span class="s3">\n        </span><span class="s1">boxSizing: </span><span class="s3">\&quot;</span><span class="s1">border-box</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;light .cm-tooltip</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">border: </span><span class="s3">\&quot;</span><span class="s1">1px solid #bbb</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#f5f5f5</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;light .cm-tooltip-section:not(:first-child)</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">borderTop: </span><span class="s3">\&quot;</span><span class="s1">1px solid #bbb</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;dark .cm-tooltip</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#333338</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">white</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-tooltip-arrow</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">height: `${7 /* Arrow.Size */}px`,</span><span class="s3">\n        </span><span class="s1">width: `${7 /* Arrow.Size */ * 2}px`,</span><span class="s3">\n        </span><span class="s1">position: </span><span class="s3">\&quot;</span><span class="s1">absolute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">zIndex: -1,</span><span class="s3">\n        </span><span class="s1">overflow: </span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">&amp;:before, &amp;:after</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">content: </span><span class="s3">\&quot;</span><span class="s1">''</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">position: </span><span class="s3">\&quot;</span><span class="s1">absolute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">width: 0,</span><span class="s3">\n            </span><span class="s1">height: 0,</span><span class="s3">\n            </span><span class="s1">borderLeft: `${7 /* Arrow.Size */}px solid transparent`,</span><span class="s3">\n            </span><span class="s1">borderRight: `${7 /* Arrow.Size */}px solid transparent`,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        \&quot;</span><span class="s1">.cm-tooltip-above &amp;</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">bottom: `-${7 /* Arrow.Size */}px`,</span><span class="s3">\n            \&quot;</span><span class="s1">&amp;:before</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n                </span><span class="s1">borderTop: `${7 /* Arrow.Size */}px solid #bbb`,</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            \&quot;</span><span class="s1">&amp;:after</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n                </span><span class="s1">borderTop: `${7 /* Arrow.Size */}px solid #f5f5f5`,</span><span class="s3">\n                </span><span class="s1">bottom: </span><span class="s3">\&quot;</span><span class="s1">1px</span><span class="s3">\&quot;\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        \&quot;</span><span class="s1">.cm-tooltip-below &amp;</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">top: `-${7 /* Arrow.Size */}px`,</span><span class="s3">\n            \&quot;</span><span class="s1">&amp;:before</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n                </span><span class="s1">borderBottom: `${7 /* Arrow.Size */}px solid #bbb`,</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            \&quot;</span><span class="s1">&amp;:after</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n                </span><span class="s1">borderBottom: `${7 /* Arrow.Size */}px solid #f5f5f5`,</span><span class="s3">\n                </span><span class="s1">top: </span><span class="s3">\&quot;</span><span class="s1">1px</span><span class="s3">\&quot;\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;dark .cm-tooltip .cm-tooltip-arrow</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        \&quot;</span><span class="s1">&amp;:before</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">borderTopColor: </span><span class="s3">\&quot;</span><span class="s1">#333338</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">borderBottomColor: </span><span class="s3">\&quot;</span><span class="s1">#333338</span><span class="s3">\&quot;\n        </span><span class="s1">},</span><span class="s3">\n        \&quot;</span><span class="s1">&amp;:after</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">borderTopColor: </span><span class="s3">\&quot;</span><span class="s1">transparent</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">borderBottomColor: </span><span class="s3">\&quot;</span><span class="s1">transparent</span><span class="s3">\&quot;\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const noOffset = { x: 0, y: 0 };</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Facet to which an extension can add a value to show a tooltip.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const showTooltip = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">enables: [tooltipPlugin, baseTheme]</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const showHoverTooltip = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine: inputs =&gt; inputs.reduce((a, i) =&gt; a.concat(i), [])</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">class HoverTooltipHost {</span><span class="s3">\n    </span><span class="s1">// Needs to be static so that host tooltip instances always match</span><span class="s3">\n    </span><span class="s1">static create(view) {</span><span class="s3">\n        </span><span class="s1">return new HoverTooltipHost(view);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">constructor(view) {</span><span class="s3">\n        </span><span class="s1">this.view = view;</span><span class="s3">\n        </span><span class="s1">this.mounted = false;</span><span class="s3">\n        </span><span class="s1">this.dom = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.dom.classList.add(</span><span class="s3">\&quot;</span><span class="s1">cm-tooltip-hover</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.manager = new TooltipViewManager(view, showHoverTooltip, (t, p) =&gt; this.createHostedView(t, p), t =&gt; t.dom.remove());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createHostedView(tooltip, prev) {</span><span class="s3">\n        </span><span class="s1">let hostedView = tooltip.create(this.view);</span><span class="s3">\n        </span><span class="s1">hostedView.dom.classList.add(</span><span class="s3">\&quot;</span><span class="s1">cm-tooltip-section</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);</span><span class="s3">\n        </span><span class="s1">if (this.mounted &amp;&amp; hostedView.mount)</span><span class="s3">\n            </span><span class="s1">hostedView.mount(this.view);</span><span class="s3">\n        </span><span class="s1">return hostedView;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mount(view) {</span><span class="s3">\n        </span><span class="s1">for (let hostedView of this.manager.tooltipViews) {</span><span class="s3">\n            </span><span class="s1">if (hostedView.mount)</span><span class="s3">\n                </span><span class="s1">hostedView.mount(view);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.mounted = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">positioned(space) {</span><span class="s3">\n        </span><span class="s1">for (let hostedView of this.manager.tooltipViews) {</span><span class="s3">\n            </span><span class="s1">if (hostedView.positioned)</span><span class="s3">\n                </span><span class="s1">hostedView.positioned(space);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">this.manager.update(update);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">destroy() {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">for (let t of this.manager.tooltipViews)</span><span class="s3">\n            </span><span class="s1">(_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">passProp(name) {</span><span class="s3">\n        </span><span class="s1">let value = undefined;</span><span class="s3">\n        </span><span class="s1">for (let view of this.manager.tooltipViews) {</span><span class="s3">\n            </span><span class="s1">let given = view[name];</span><span class="s3">\n            </span><span class="s1">if (given !== undefined) {</span><span class="s3">\n                </span><span class="s1">if (value === undefined)</span><span class="s3">\n                    </span><span class="s1">value = given;</span><span class="s3">\n                </span><span class="s1">else if (value !== given)</span><span class="s3">\n                    </span><span class="s1">return undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get offset() { return this.passProp(</span><span class="s3">\&quot;</span><span class="s1">offset</span><span class="s3">\&quot;</span><span class="s1">); }</span><span class="s3">\n    </span><span class="s1">get getCoords() { return this.passProp(</span><span class="s3">\&quot;</span><span class="s1">getCoords</span><span class="s3">\&quot;</span><span class="s1">); }</span><span class="s3">\n    </span><span class="s1">get overlap() { return this.passProp(</span><span class="s3">\&quot;</span><span class="s1">overlap</span><span class="s3">\&quot;</span><span class="s1">); }</span><span class="s3">\n    </span><span class="s1">get resize() { return this.passProp(</span><span class="s3">\&quot;</span><span class="s1">resize</span><span class="s3">\&quot;</span><span class="s1">); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const showHoverTooltipHost = /*@__PURE__*/showTooltip.compute([showHoverTooltip], state =&gt; {</span><span class="s3">\n    </span><span class="s1">let tooltips = state.facet(showHoverTooltip);</span><span class="s3">\n    </span><span class="s1">if (tooltips.length === 0)</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">pos: Math.min(...tooltips.map(t =&gt; t.pos)),</span><span class="s3">\n        </span><span class="s1">end: Math.max(...tooltips.map(t =&gt; { var _a; return (_a = t.end) !== null &amp;&amp; _a !== void 0 ? _a : t.pos; })),</span><span class="s3">\n        </span><span class="s1">create: HoverTooltipHost.create,</span><span class="s3">\n        </span><span class="s1">above: tooltips[0].above,</span><span class="s3">\n        </span><span class="s1">arrow: tooltips.some(t =&gt; t.arrow),</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">class HoverPlugin {</span><span class="s3">\n    </span><span class="s1">constructor(view, source, field, setHover, hoverTime) {</span><span class="s3">\n        </span><span class="s1">this.view = view;</span><span class="s3">\n        </span><span class="s1">this.source = source;</span><span class="s3">\n        </span><span class="s1">this.field = field;</span><span class="s3">\n        </span><span class="s1">this.setHover = setHover;</span><span class="s3">\n        </span><span class="s1">this.hoverTime = hoverTime;</span><span class="s3">\n        </span><span class="s1">this.hoverTimeout = -1;</span><span class="s3">\n        </span><span class="s1">this.restartTimeout = -1;</span><span class="s3">\n        </span><span class="s1">this.pending = null;</span><span class="s3">\n        </span><span class="s1">this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };</span><span class="s3">\n        </span><span class="s1">this.checkHover = this.checkHover.bind(this);</span><span class="s3">\n        </span><span class="s1">view.dom.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">mouseleave</span><span class="s3">\&quot;</span><span class="s1">, this.mouseleave = this.mouseleave.bind(this));</span><span class="s3">\n        </span><span class="s1">view.dom.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">mousemove</span><span class="s3">\&quot;</span><span class="s1">, this.mousemove = this.mousemove.bind(this));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update() {</span><span class="s3">\n        </span><span class="s1">if (this.pending) {</span><span class="s3">\n            </span><span class="s1">this.pending = null;</span><span class="s3">\n            </span><span class="s1">clearTimeout(this.restartTimeout);</span><span class="s3">\n            </span><span class="s1">this.restartTimeout = setTimeout(() =&gt; this.startHover(), 20);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get active() {</span><span class="s3">\n        </span><span class="s1">return this.view.state.field(this.field);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">checkHover() {</span><span class="s3">\n        </span><span class="s1">this.hoverTimeout = -1;</span><span class="s3">\n        </span><span class="s1">if (this.active.length)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">let hovered = Date.now() - this.lastMove.time;</span><span class="s3">\n        </span><span class="s1">if (hovered &lt; this.hoverTime)</span><span class="s3">\n            </span><span class="s1">this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">this.startHover();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">startHover() {</span><span class="s3">\n        </span><span class="s1">clearTimeout(this.restartTimeout);</span><span class="s3">\n        </span><span class="s1">let { view, lastMove } = this;</span><span class="s3">\n        </span><span class="s1">let desc = view.docView.nearest(lastMove.target);</span><span class="s3">\n        </span><span class="s1">if (!desc)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">let pos, side = 1;</span><span class="s3">\n        </span><span class="s1">if (desc instanceof WidgetView) {</span><span class="s3">\n            </span><span class="s1">pos = desc.posAtStart;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">pos = view.posAtCoords(lastMove);</span><span class="s3">\n            </span><span class="s1">if (pos == null)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">let posCoords = view.coordsAtPos(pos);</span><span class="s3">\n            </span><span class="s1">if (!posCoords ||</span><span class="s3">\n                </span><span class="s1">lastMove.y &lt; posCoords.top || lastMove.y &gt; posCoords.bottom ||</span><span class="s3">\n                </span><span class="s1">lastMove.x &lt; posCoords.left - view.defaultCharacterWidth ||</span><span class="s3">\n                </span><span class="s1">lastMove.x &gt; posCoords.right + view.defaultCharacterWidth)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find(s =&gt; s.from &lt;= pos &amp;&amp; s.to &gt;= pos);</span><span class="s3">\n            </span><span class="s1">let rtl = bidi &amp;&amp; bidi.dir == Direction.RTL ? -1 : 1;</span><span class="s3">\n            </span><span class="s1">side = (lastMove.x &lt; posCoords.left ? -rtl : rtl);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let open = this.source(view, pos, side);</span><span class="s3">\n        </span><span class="s1">if (open === null || open === void 0 ? void 0 : open.then) {</span><span class="s3">\n            </span><span class="s1">let pending = this.pending = { pos };</span><span class="s3">\n            </span><span class="s1">open.then(result =&gt; {</span><span class="s3">\n                </span><span class="s1">if (this.pending == pending) {</span><span class="s3">\n                    </span><span class="s1">this.pending = null;</span><span class="s3">\n                    </span><span class="s1">if (result &amp;&amp; !(Array.isArray(result) &amp;&amp; !result.length))</span><span class="s3">\n                        </span><span class="s1">view.dispatch({ effects: this.setHover.of(Array.isArray(result) ? result : [result]) });</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}, e =&gt; logException(view.state, e, </span><span class="s3">\&quot;</span><span class="s1">hover tooltip</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (open &amp;&amp; !(Array.isArray(open) &amp;&amp; !open.length)) {</span><span class="s3">\n            </span><span class="s1">view.dispatch({ effects: this.setHover.of(Array.isArray(open) ? open : [open]) });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get tooltip() {</span><span class="s3">\n        </span><span class="s1">let plugin = this.view.plugin(tooltipPlugin);</span><span class="s3">\n        </span><span class="s1">let index = plugin ? plugin.manager.tooltips.findIndex(t =&gt; t.create == HoverTooltipHost.create) : -1;</span><span class="s3">\n        </span><span class="s1">return index &gt; -1 ? plugin.manager.tooltipViews[index] : null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mousemove(event) {</span><span class="s3">\n        </span><span class="s1">var _a, _b;</span><span class="s3">\n        </span><span class="s1">this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };</span><span class="s3">\n        </span><span class="s1">if (this.hoverTimeout &lt; 0)</span><span class="s3">\n            </span><span class="s1">this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);</span><span class="s3">\n        </span><span class="s1">let { active, tooltip } = this;</span><span class="s3">\n        </span><span class="s1">if (active.length &amp;&amp; tooltip &amp;&amp; !isInTooltip(tooltip.dom, event) || this.pending) {</span><span class="s3">\n            </span><span class="s1">let { pos } = active[0] || this.pending, end = (_b = (_a = active[0]) === null || _a === void 0 ? void 0 : _a.end) !== null &amp;&amp; _b !== void 0 ? _b : pos;</span><span class="s3">\n            </span><span class="s1">if ((pos == end ? this.view.posAtCoords(this.lastMove) != pos</span><span class="s3">\n                </span><span class="s1">: !isOverRange(this.view, pos, end, event.clientX, event.clientY))) {</span><span class="s3">\n                </span><span class="s1">this.view.dispatch({ effects: this.setHover.of([]) });</span><span class="s3">\n                </span><span class="s1">this.pending = null;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mouseleave(event) {</span><span class="s3">\n        </span><span class="s1">clearTimeout(this.hoverTimeout);</span><span class="s3">\n        </span><span class="s1">this.hoverTimeout = -1;</span><span class="s3">\n        </span><span class="s1">let { active } = this;</span><span class="s3">\n        </span><span class="s1">if (active.length) {</span><span class="s3">\n            </span><span class="s1">let { tooltip } = this;</span><span class="s3">\n            </span><span class="s1">let inTooltip = tooltip &amp;&amp; tooltip.dom.contains(event.relatedTarget);</span><span class="s3">\n            </span><span class="s1">if (!inTooltip)</span><span class="s3">\n                </span><span class="s1">this.view.dispatch({ effects: this.setHover.of([]) });</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">this.watchTooltipLeave(tooltip.dom);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">watchTooltipLeave(tooltip) {</span><span class="s3">\n        </span><span class="s1">let watch = (event) =&gt; {</span><span class="s3">\n            </span><span class="s1">tooltip.removeEventListener(</span><span class="s3">\&quot;</span><span class="s1">mouseleave</span><span class="s3">\&quot;</span><span class="s1">, watch);</span><span class="s3">\n            </span><span class="s1">if (this.active.length &amp;&amp; !this.view.dom.contains(event.relatedTarget))</span><span class="s3">\n                </span><span class="s1">this.view.dispatch({ effects: this.setHover.of([]) });</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">tooltip.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">mouseleave</span><span class="s3">\&quot;</span><span class="s1">, watch);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">destroy() {</span><span class="s3">\n        </span><span class="s1">clearTimeout(this.hoverTimeout);</span><span class="s3">\n        </span><span class="s1">this.view.dom.removeEventListener(</span><span class="s3">\&quot;</span><span class="s1">mouseleave</span><span class="s3">\&quot;</span><span class="s1">, this.mouseleave);</span><span class="s3">\n        </span><span class="s1">this.view.dom.removeEventListener(</span><span class="s3">\&quot;</span><span class="s1">mousemove</span><span class="s3">\&quot;</span><span class="s1">, this.mousemove);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const tooltipMargin = 4;</span><span class="s3">\n</span><span class="s1">function isInTooltip(tooltip, event) {</span><span class="s3">\n    </span><span class="s1">let { left, right, top, bottom } = tooltip.getBoundingClientRect(), arrow;</span><span class="s3">\n    </span><span class="s1">if (arrow = tooltip.querySelector(</span><span class="s3">\&quot;</span><span class="s1">.cm-tooltip-arrow</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">let arrowRect = arrow.getBoundingClientRect();</span><span class="s3">\n        </span><span class="s1">top = Math.min(arrowRect.top, top);</span><span class="s3">\n        </span><span class="s1">bottom = Math.max(arrowRect.bottom, bottom);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return event.clientX &gt;= left - tooltipMargin &amp;&amp; event.clientX &lt;= right + tooltipMargin &amp;&amp;</span><span class="s3">\n        </span><span class="s1">event.clientY &gt;= top - tooltipMargin &amp;&amp; event.clientY &lt;= bottom + tooltipMargin;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isOverRange(view, from, to, x, y, margin) {</span><span class="s3">\n    </span><span class="s1">let rect = view.scrollDOM.getBoundingClientRect();</span><span class="s3">\n    </span><span class="s1">let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;</span><span class="s3">\n    </span><span class="s1">if (rect.left &gt; x || rect.right &lt; x || rect.top &gt; y || Math.min(rect.bottom, docBottom) &lt; y)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let pos = view.posAtCoords({ x, y }, false);</span><span class="s3">\n    </span><span class="s1">return pos &gt;= from &amp;&amp; pos &lt;= to;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Set up a hover tooltip, which shows up when the pointer hovers</span><span class="s3">\n</span><span class="s1">over ranges of text. The callback is called when the mouse hovers</span><span class="s3">\n</span><span class="s1">over the document text. It should, if there is a tooltip</span><span class="s3">\n</span><span class="s1">associated with position `pos`, return the tooltip description</span><span class="s3">\n</span><span class="s1">(either directly or in a promise). The `side` argument indicates</span><span class="s3">\n</span><span class="s1">on which side of the position the pointer isit will be -1 if the</span><span class="s3">\n</span><span class="s1">pointer is before the position, 1 if after the position.</span><span class="s3">\n\n</span><span class="s1">Note that all hover tooltips are hosted within a single tooltip</span><span class="s3">\n</span><span class="s1">container element. This allows multiple tooltips over the same</span><span class="s3">\n</span><span class="s1">range to be </span><span class="s3">\&quot;</span><span class="s1">merged</span><span class="s3">\&quot; </span><span class="s1">together without overlapping.</span><span class="s3">\n\n</span><span class="s1">The return value is a valid [editor extension](https://codemirror.net/6/docs/ref/#state.Extension)</span><span class="s3">\n</span><span class="s1">but also provides an `active` property holding a state field that</span><span class="s3">\n</span><span class="s1">can be used to read the currently active tooltips produced by this</span><span class="s3">\n</span><span class="s1">extension.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function hoverTooltip(source, options = {}) {</span><span class="s3">\n    </span><span class="s1">let setHover = StateEffect.define();</span><span class="s3">\n    </span><span class="s1">let hoverState = StateField.define({</span><span class="s3">\n        </span><span class="s1">create() { return []; },</span><span class="s3">\n        </span><span class="s1">update(value, tr) {</span><span class="s3">\n            </span><span class="s1">if (value.length) {</span><span class="s3">\n                </span><span class="s1">if (options.hideOnChange &amp;&amp; (tr.docChanged || tr.selection))</span><span class="s3">\n                    </span><span class="s1">value = [];</span><span class="s3">\n                </span><span class="s1">else if (options.hideOn)</span><span class="s3">\n                    </span><span class="s1">value = value.filter(v =&gt; !options.hideOn(tr, v));</span><span class="s3">\n                </span><span class="s1">if (tr.docChanged) {</span><span class="s3">\n                    </span><span class="s1">let mapped = [];</span><span class="s3">\n                    </span><span class="s1">for (let tooltip of value) {</span><span class="s3">\n                        </span><span class="s1">let newPos = tr.changes.mapPos(tooltip.pos, -1, MapMode.TrackDel);</span><span class="s3">\n                        </span><span class="s1">if (newPos != null) {</span><span class="s3">\n                            </span><span class="s1">let copy = Object.assign(Object.create(null), tooltip);</span><span class="s3">\n                            </span><span class="s1">copy.pos = newPos;</span><span class="s3">\n                            </span><span class="s1">if (copy.end != null)</span><span class="s3">\n                                </span><span class="s1">copy.end = tr.changes.mapPos(copy.end);</span><span class="s3">\n                            </span><span class="s1">mapped.push(copy);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">value = mapped;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">for (let effect of tr.effects) {</span><span class="s3">\n                </span><span class="s1">if (effect.is(setHover))</span><span class="s3">\n                    </span><span class="s1">value = effect.value;</span><span class="s3">\n                </span><span class="s1">if (effect.is(closeHoverTooltipEffect))</span><span class="s3">\n                    </span><span class="s1">value = [];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return value;</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">provide: f =&gt; showHoverTooltip.from(f)</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">active: hoverState,</span><span class="s3">\n        </span><span class="s1">extension: [</span><span class="s3">\n            </span><span class="s1">hoverState,</span><span class="s3">\n            </span><span class="s1">ViewPlugin.define(view =&gt; new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300 /* Hover.Time */)),</span><span class="s3">\n            </span><span class="s1">showHoverTooltipHost</span><span class="s3">\n        </span><span class="s1">]</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Get the active tooltip view for a given tooltip, if available.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getTooltip(view, tooltip) {</span><span class="s3">\n    </span><span class="s1">let plugin = view.plugin(tooltipPlugin);</span><span class="s3">\n    </span><span class="s1">if (!plugin)</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">let found = plugin.manager.tooltips.indexOf(tooltip);</span><span class="s3">\n    </span><span class="s1">return found &lt; 0 ? null : plugin.manager.tooltipViews[found];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Returns true if any hover tooltips are currently active.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function hasHoverTooltips(state) {</span><span class="s3">\n    </span><span class="s1">return state.facet(showHoverTooltip).some(x =&gt; x);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const closeHoverTooltipEffect = /*@__PURE__*/StateEffect.define();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Transaction effect that closes all hover tooltips.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const closeHoverTooltips = /*@__PURE__*/closeHoverTooltipEffect.of(null);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Tell the tooltip extension to recompute the position of the active</span><span class="s3">\n</span><span class="s1">tooltips. This can be useful when something happens (such as a</span><span class="s3">\n</span><span class="s1">re-positioning or CSS change affecting the editor) that could</span><span class="s3">\n</span><span class="s1">invalidate the existing tooltip positions.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function repositionTooltips(view) {</span><span class="s3">\n    </span><span class="s1">let plugin = view.plugin(tooltipPlugin);</span><span class="s3">\n    </span><span class="s1">if (plugin)</span><span class="s3">\n        </span><span class="s1">plugin.maybeMeasure();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const panelConfig = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine(configs) {</span><span class="s3">\n        </span><span class="s1">let topContainer, bottomContainer;</span><span class="s3">\n        </span><span class="s1">for (let c of configs) {</span><span class="s3">\n            </span><span class="s1">topContainer = topContainer || c.topContainer;</span><span class="s3">\n            </span><span class="s1">bottomContainer = bottomContainer || c.bottomContainer;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { topContainer, bottomContainer };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Configures the panel-managing extension.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function panels(config) {</span><span class="s3">\n    </span><span class="s1">return config ? [panelConfig.of(config)] : [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Get the active panel created by the given constructor, if any.</span><span class="s3">\n</span><span class="s1">This can be useful when you need access to your panels' DOM</span><span class="s3">\n</span><span class="s1">structure.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getPanel(view, panel) {</span><span class="s3">\n    </span><span class="s1">let plugin = view.plugin(panelPlugin);</span><span class="s3">\n    </span><span class="s1">let index = plugin ? plugin.specs.indexOf(panel) : -1;</span><span class="s3">\n    </span><span class="s1">return index &gt; -1 ? plugin.panels[index] : null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const panelPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {</span><span class="s3">\n    </span><span class="s1">constructor(view) {</span><span class="s3">\n        </span><span class="s1">this.input = view.state.facet(showPanel);</span><span class="s3">\n        </span><span class="s1">this.specs = this.input.filter(s =&gt; s);</span><span class="s3">\n        </span><span class="s1">this.panels = this.specs.map(spec =&gt; spec(view));</span><span class="s3">\n        </span><span class="s1">let conf = view.state.facet(panelConfig);</span><span class="s3">\n        </span><span class="s1">this.top = new PanelGroup(view, true, conf.topContainer);</span><span class="s3">\n        </span><span class="s1">this.bottom = new PanelGroup(view, false, conf.bottomContainer);</span><span class="s3">\n        </span><span class="s1">this.top.sync(this.panels.filter(p =&gt; p.top));</span><span class="s3">\n        </span><span class="s1">this.bottom.sync(this.panels.filter(p =&gt; !p.top));</span><span class="s3">\n        </span><span class="s1">for (let p of this.panels) {</span><span class="s3">\n            </span><span class="s1">p.dom.classList.add(</span><span class="s3">\&quot;</span><span class="s1">cm-panel</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">if (p.mount)</span><span class="s3">\n                </span><span class="s1">p.mount();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">let conf = update.state.facet(panelConfig);</span><span class="s3">\n        </span><span class="s1">if (this.top.container != conf.topContainer) {</span><span class="s3">\n            </span><span class="s1">this.top.sync([]);</span><span class="s3">\n            </span><span class="s1">this.top = new PanelGroup(update.view, true, conf.topContainer);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.bottom.container != conf.bottomContainer) {</span><span class="s3">\n            </span><span class="s1">this.bottom.sync([]);</span><span class="s3">\n            </span><span class="s1">this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.top.syncClasses();</span><span class="s3">\n        </span><span class="s1">this.bottom.syncClasses();</span><span class="s3">\n        </span><span class="s1">let input = update.state.facet(showPanel);</span><span class="s3">\n        </span><span class="s1">if (input != this.input) {</span><span class="s3">\n            </span><span class="s1">let specs = input.filter(x =&gt; x);</span><span class="s3">\n            </span><span class="s1">let panels = [], top = [], bottom = [], mount = [];</span><span class="s3">\n            </span><span class="s1">for (let spec of specs) {</span><span class="s3">\n                </span><span class="s1">let known = this.specs.indexOf(spec), panel;</span><span class="s3">\n                </span><span class="s1">if (known &lt; 0) {</span><span class="s3">\n                    </span><span class="s1">panel = spec(update.view);</span><span class="s3">\n                    </span><span class="s1">mount.push(panel);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">panel = this.panels[known];</span><span class="s3">\n                    </span><span class="s1">if (panel.update)</span><span class="s3">\n                        </span><span class="s1">panel.update(update);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">panels.push(panel);</span><span class="s3">\n                </span><span class="s1">(panel.top ? top : bottom).push(panel);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.specs = specs;</span><span class="s3">\n            </span><span class="s1">this.panels = panels;</span><span class="s3">\n            </span><span class="s1">this.top.sync(top);</span><span class="s3">\n            </span><span class="s1">this.bottom.sync(bottom);</span><span class="s3">\n            </span><span class="s1">for (let p of mount) {</span><span class="s3">\n                </span><span class="s1">p.dom.classList.add(</span><span class="s3">\&quot;</span><span class="s1">cm-panel</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">if (p.mount)</span><span class="s3">\n                    </span><span class="s1">p.mount();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">for (let p of this.panels)</span><span class="s3">\n                </span><span class="s1">if (p.update)</span><span class="s3">\n                    </span><span class="s1">p.update(update);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">destroy() {</span><span class="s3">\n        </span><span class="s1">this.top.sync([]);</span><span class="s3">\n        </span><span class="s1">this.bottom.sync([]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">provide: plugin =&gt; EditorView.scrollMargins.of(view =&gt; {</span><span class="s3">\n        </span><span class="s1">let value = view.plugin(plugin);</span><span class="s3">\n        </span><span class="s1">return value &amp;&amp; { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">class PanelGroup {</span><span class="s3">\n    </span><span class="s1">constructor(view, top, container) {</span><span class="s3">\n        </span><span class="s1">this.view = view;</span><span class="s3">\n        </span><span class="s1">this.top = top;</span><span class="s3">\n        </span><span class="s1">this.container = container;</span><span class="s3">\n        </span><span class="s1">this.dom = undefined;</span><span class="s3">\n        </span><span class="s1">this.classes = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.panels = [];</span><span class="s3">\n        </span><span class="s1">this.syncClasses();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">sync(panels) {</span><span class="s3">\n        </span><span class="s1">for (let p of this.panels)</span><span class="s3">\n            </span><span class="s1">if (p.destroy &amp;&amp; panels.indexOf(p) &lt; 0)</span><span class="s3">\n                </span><span class="s1">p.destroy();</span><span class="s3">\n        </span><span class="s1">this.panels = panels;</span><span class="s3">\n        </span><span class="s1">this.syncDOM();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">syncDOM() {</span><span class="s3">\n        </span><span class="s1">if (this.panels.length == 0) {</span><span class="s3">\n            </span><span class="s1">if (this.dom) {</span><span class="s3">\n                </span><span class="s1">this.dom.remove();</span><span class="s3">\n                </span><span class="s1">this.dom = undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!this.dom) {</span><span class="s3">\n            </span><span class="s1">this.dom = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">this.dom.className = this.top ? </span><span class="s3">\&quot;</span><span class="s1">cm-panels cm-panels-top</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">cm-panels cm-panels-bottom</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">this.dom.style[this.top ? </span><span class="s3">\&quot;</span><span class="s1">top</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">bottom</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">let parent = this.container || this.view.dom;</span><span class="s3">\n            </span><span class="s1">parent.insertBefore(this.dom, this.top ? parent.firstChild : null);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let curDOM = this.dom.firstChild;</span><span class="s3">\n        </span><span class="s1">for (let panel of this.panels) {</span><span class="s3">\n            </span><span class="s1">if (panel.dom.parentNode == this.dom) {</span><span class="s3">\n                </span><span class="s1">while (curDOM != panel.dom)</span><span class="s3">\n                    </span><span class="s1">curDOM = rm(curDOM);</span><span class="s3">\n                </span><span class="s1">curDOM = curDOM.nextSibling;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this.dom.insertBefore(panel.dom, curDOM);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">while (curDOM)</span><span class="s3">\n            </span><span class="s1">curDOM = rm(curDOM);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scrollMargin() {</span><span class="s3">\n        </span><span class="s1">return !this.dom || this.container ? 0</span><span class="s3">\n            </span><span class="s1">: Math.max(0, this.top ?</span><span class="s3">\n                </span><span class="s1">this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) :</span><span class="s3">\n                </span><span class="s1">Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">syncClasses() {</span><span class="s3">\n        </span><span class="s1">if (!this.container || this.classes == this.view.themeClasses)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">for (let cls of this.classes.split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">))</span><span class="s3">\n            </span><span class="s1">if (cls)</span><span class="s3">\n                </span><span class="s1">this.container.classList.remove(cls);</span><span class="s3">\n        </span><span class="s1">for (let cls of (this.classes = this.view.themeClasses).split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">))</span><span class="s3">\n            </span><span class="s1">if (cls)</span><span class="s3">\n                </span><span class="s1">this.container.classList.add(cls);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function rm(node) {</span><span class="s3">\n    </span><span class="s1">let next = node.nextSibling;</span><span class="s3">\n    </span><span class="s1">node.remove();</span><span class="s3">\n    </span><span class="s1">return next;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Opening a panel is done by providing a constructor function for</span><span class="s3">\n</span><span class="s1">the panel through this facet. (The panel is closed again when its</span><span class="s3">\n</span><span class="s1">constructor is no longer provided.) Values of `null` are ignored.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const showPanel = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">enables: panelPlugin</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A gutter marker represents a bit of information attached to a line</span><span class="s3">\n</span><span class="s1">in a specific gutter. Your own custom markers have to extend this</span><span class="s3">\n</span><span class="s1">class.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class GutterMarker extends RangeValue {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">compare(other) {</span><span class="s3">\n        </span><span class="s1">return this == other || this.constructor == other.constructor &amp;&amp; this.eq(other);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Compare this marker to another marker of the same type.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">eq(other) { return false; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Called if the marker has a `toDOM` method and its representation</span><span class="s3">\n    </span><span class="s1">was removed from a gutter.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">destroy(dom) { }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">GutterMarker.prototype.elementClass = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">GutterMarker.prototype.toDOM = undefined;</span><span class="s3">\n</span><span class="s1">GutterMarker.prototype.mapMode = MapMode.TrackBefore;</span><span class="s3">\n</span><span class="s1">GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;</span><span class="s3">\n</span><span class="s1">GutterMarker.prototype.point = true;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Facet used to add a class to all gutter elements for a given line.</span><span class="s3">\n</span><span class="s1">Markers given to this facet should _only_ define an</span><span class="s3">\n</span><span class="s1">[`elementclass`](https://codemirror.net/6/docs/ref/#view.GutterMarker.elementClass), not a</span><span class="s3">\n</span><span class="s1">[`toDOM`](https://codemirror.net/6/docs/ref/#view.GutterMarker.toDOM) (or the marker will appear</span><span class="s3">\n</span><span class="s1">in all gutters for the line).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const gutterLineClass = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Facet used to add a class to all gutter elements next to a widget.</span><span class="s3">\n</span><span class="s1">Should not provide widgets with a `toDOM` method.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const gutterWidgetClass = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const defaults = {</span><span class="s3">\n    </span><span class="s1">class: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">renderEmptyElements: false,</span><span class="s3">\n    </span><span class="s1">elementStyle: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">markers: () =&gt; RangeSet.empty,</span><span class="s3">\n    </span><span class="s1">lineMarker: () =&gt; null,</span><span class="s3">\n    </span><span class="s1">widgetMarker: () =&gt; null,</span><span class="s3">\n    </span><span class="s1">lineMarkerChange: null,</span><span class="s3">\n    </span><span class="s1">initialSpacer: null,</span><span class="s3">\n    </span><span class="s1">updateSpacer: null,</span><span class="s3">\n    </span><span class="s1">domEventHandlers: {}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const activeGutters = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Define an editor gutter. The order in which the gutters appear is</span><span class="s3">\n</span><span class="s1">determined by their extension priority.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function gutter(config) {</span><span class="s3">\n    </span><span class="s1">return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const unfixGutters = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine: values =&gt; values.some(x =&gt; x)</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The gutter-drawing plugin is automatically enabled when you add a</span><span class="s3">\n</span><span class="s1">gutter, but you can use this function to explicitly configure it.</span><span class="s3">\n\n</span><span class="s1">Unless `fixed` is explicitly set to `false`, the gutters are</span><span class="s3">\n</span><span class="s1">fixed, meaning they don't scroll along with the content</span><span class="s3">\n</span><span class="s1">horizontally (except on Internet Explorer, which doesn't support</span><span class="s3">\n</span><span class="s1">CSS [`position:</span><span class="s3">\n</span><span class="s1">sticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function gutters(config) {</span><span class="s3">\n    </span><span class="s1">let result = [</span><span class="s3">\n        </span><span class="s1">gutterView,</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n    </span><span class="s1">if (config &amp;&amp; config.fixed === false)</span><span class="s3">\n        </span><span class="s1">result.push(unfixGutters.of(true));</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const gutterView = /*@__PURE__*/ViewPlugin.fromClass(class {</span><span class="s3">\n    </span><span class="s1">constructor(view) {</span><span class="s3">\n        </span><span class="s1">this.view = view;</span><span class="s3">\n        </span><span class="s1">this.prevViewport = view.viewport;</span><span class="s3">\n        </span><span class="s1">this.dom = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.dom.className = </span><span class="s3">\&quot;</span><span class="s1">cm-gutters</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.dom.setAttribute(</span><span class="s3">\&quot;</span><span class="s1">aria-hidden</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.dom.style.minHeight = (this.view.contentHeight / this.view.scaleY) + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.gutters = view.state.facet(activeGutters).map(conf =&gt; new SingleGutterView(view, conf));</span><span class="s3">\n        </span><span class="s1">for (let gutter of this.gutters)</span><span class="s3">\n            </span><span class="s1">this.dom.appendChild(gutter.dom);</span><span class="s3">\n        </span><span class="s1">this.fixed = !view.state.facet(unfixGutters);</span><span class="s3">\n        </span><span class="s1">if (this.fixed) {</span><span class="s3">\n            </span><span class="s1">// FIXME IE11 fallback, which doesn't support position: sticky,</span><span class="s3">\n            </span><span class="s1">// by using position: relative + event handlers that realign the</span><span class="s3">\n            </span><span class="s1">// gutter (or just force fixed=false on IE11?)</span><span class="s3">\n            </span><span class="s1">this.dom.style.position = </span><span class="s3">\&quot;</span><span class="s1">sticky</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.syncGutters(false);</span><span class="s3">\n        </span><span class="s1">view.scrollDOM.insertBefore(this.dom, view.contentDOM);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">if (this.updateGutters(update)) {</span><span class="s3">\n            </span><span class="s1">// Detach during sync when the viewport changed significantly</span><span class="s3">\n            </span><span class="s1">// (such as during scrolling), since for large updates that is</span><span class="s3">\n            </span><span class="s1">// faster.</span><span class="s3">\n            </span><span class="s1">let vpA = this.prevViewport, vpB = update.view.viewport;</span><span class="s3">\n            </span><span class="s1">let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);</span><span class="s3">\n            </span><span class="s1">this.syncGutters(vpOverlap &lt; (vpB.to - vpB.from) * 0.8);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (update.geometryChanged) {</span><span class="s3">\n            </span><span class="s1">this.dom.style.minHeight = (this.view.contentHeight / this.view.scaleY) + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.view.state.facet(unfixGutters) != !this.fixed) {</span><span class="s3">\n            </span><span class="s1">this.fixed = !this.fixed;</span><span class="s3">\n            </span><span class="s1">this.dom.style.position = this.fixed ? </span><span class="s3">\&quot;</span><span class="s1">sticky</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.prevViewport = update.view.viewport;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">syncGutters(detach) {</span><span class="s3">\n        </span><span class="s1">let after = this.dom.nextSibling;</span><span class="s3">\n        </span><span class="s1">if (detach)</span><span class="s3">\n            </span><span class="s1">this.dom.remove();</span><span class="s3">\n        </span><span class="s1">let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);</span><span class="s3">\n        </span><span class="s1">let classSet = [];</span><span class="s3">\n        </span><span class="s1">let contexts = this.gutters.map(gutter =&gt; new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));</span><span class="s3">\n        </span><span class="s1">for (let line of this.view.viewportLineBlocks) {</span><span class="s3">\n            </span><span class="s1">if (classSet.length)</span><span class="s3">\n                </span><span class="s1">classSet = [];</span><span class="s3">\n            </span><span class="s1">if (Array.isArray(line.type)) {</span><span class="s3">\n                </span><span class="s1">let first = true;</span><span class="s3">\n                </span><span class="s1">for (let b of line.type) {</span><span class="s3">\n                    </span><span class="s1">if (b.type == BlockType.Text &amp;&amp; first) {</span><span class="s3">\n                        </span><span class="s1">advanceCursor(lineClasses, classSet, b.from);</span><span class="s3">\n                        </span><span class="s1">for (let cx of contexts)</span><span class="s3">\n                            </span><span class="s1">cx.line(this.view, b, classSet);</span><span class="s3">\n                        </span><span class="s1">first = false;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else if (b.widget) {</span><span class="s3">\n                        </span><span class="s1">for (let cx of contexts)</span><span class="s3">\n                            </span><span class="s1">cx.widget(this.view, b);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (line.type == BlockType.Text) {</span><span class="s3">\n                </span><span class="s1">advanceCursor(lineClasses, classSet, line.from);</span><span class="s3">\n                </span><span class="s1">for (let cx of contexts)</span><span class="s3">\n                    </span><span class="s1">cx.line(this.view, line, classSet);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (line.widget) {</span><span class="s3">\n                </span><span class="s1">for (let cx of contexts)</span><span class="s3">\n                    </span><span class="s1">cx.widget(this.view, line);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let cx of contexts)</span><span class="s3">\n            </span><span class="s1">cx.finish();</span><span class="s3">\n        </span><span class="s1">if (detach)</span><span class="s3">\n            </span><span class="s1">this.view.scrollDOM.insertBefore(this.dom, after);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateGutters(update) {</span><span class="s3">\n        </span><span class="s1">let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);</span><span class="s3">\n        </span><span class="s1">let change = update.docChanged || update.heightChanged || update.viewportChanged ||</span><span class="s3">\n            </span><span class="s1">!RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);</span><span class="s3">\n        </span><span class="s1">if (prev == cur) {</span><span class="s3">\n            </span><span class="s1">for (let gutter of this.gutters)</span><span class="s3">\n                </span><span class="s1">if (gutter.update(update))</span><span class="s3">\n                    </span><span class="s1">change = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">change = true;</span><span class="s3">\n            </span><span class="s1">let gutters = [];</span><span class="s3">\n            </span><span class="s1">for (let conf of cur) {</span><span class="s3">\n                </span><span class="s1">let known = prev.indexOf(conf);</span><span class="s3">\n                </span><span class="s1">if (known &lt; 0) {</span><span class="s3">\n                    </span><span class="s1">gutters.push(new SingleGutterView(this.view, conf));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">this.gutters[known].update(update);</span><span class="s3">\n                    </span><span class="s1">gutters.push(this.gutters[known]);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">for (let g of this.gutters) {</span><span class="s3">\n                </span><span class="s1">g.dom.remove();</span><span class="s3">\n                </span><span class="s1">if (gutters.indexOf(g) &lt; 0)</span><span class="s3">\n                    </span><span class="s1">g.destroy();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">for (let g of gutters)</span><span class="s3">\n                </span><span class="s1">this.dom.appendChild(g.dom);</span><span class="s3">\n            </span><span class="s1">this.gutters = gutters;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return change;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">destroy() {</span><span class="s3">\n        </span><span class="s1">for (let view of this.gutters)</span><span class="s3">\n            </span><span class="s1">view.destroy();</span><span class="s3">\n        </span><span class="s1">this.dom.remove();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">provide: plugin =&gt; EditorView.scrollMargins.of(view =&gt; {</span><span class="s3">\n        </span><span class="s1">let value = view.plugin(plugin);</span><span class="s3">\n        </span><span class="s1">if (!value || value.gutters.length == 0 || !value.fixed)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">return view.textDirection == Direction.LTR</span><span class="s3">\n            </span><span class="s1">? { left: value.dom.offsetWidth * view.scaleX }</span><span class="s3">\n            </span><span class="s1">: { right: value.dom.offsetWidth * view.scaleX };</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">function asArray(val) { return (Array.isArray(val) ? val : [val]); }</span><span class="s3">\n</span><span class="s1">function advanceCursor(cursor, collect, pos) {</span><span class="s3">\n    </span><span class="s1">while (cursor.value &amp;&amp; cursor.from &lt;= pos) {</span><span class="s3">\n        </span><span class="s1">if (cursor.from == pos)</span><span class="s3">\n            </span><span class="s1">collect.push(cursor.value);</span><span class="s3">\n        </span><span class="s1">cursor.next();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class UpdateContext {</span><span class="s3">\n    </span><span class="s1">constructor(gutter, viewport, height) {</span><span class="s3">\n        </span><span class="s1">this.gutter = gutter;</span><span class="s3">\n        </span><span class="s1">this.height = height;</span><span class="s3">\n        </span><span class="s1">this.i = 0;</span><span class="s3">\n        </span><span class="s1">this.cursor = RangeSet.iter(gutter.markers, viewport.from);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addElement(view, block, markers) {</span><span class="s3">\n        </span><span class="s1">let { gutter } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;</span><span class="s3">\n        </span><span class="s1">if (this.i == gutter.elements.length) {</span><span class="s3">\n            </span><span class="s1">let newElt = new GutterElement(view, height, above, markers);</span><span class="s3">\n            </span><span class="s1">gutter.elements.push(newElt);</span><span class="s3">\n            </span><span class="s1">gutter.dom.appendChild(newElt.dom);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">gutter.elements[this.i].update(view, height, above, markers);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.height = block.bottom;</span><span class="s3">\n        </span><span class="s1">this.i++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">line(view, line, extraMarkers) {</span><span class="s3">\n        </span><span class="s1">let localMarkers = [];</span><span class="s3">\n        </span><span class="s1">advanceCursor(this.cursor, localMarkers, line.from);</span><span class="s3">\n        </span><span class="s1">if (extraMarkers.length)</span><span class="s3">\n            </span><span class="s1">localMarkers = localMarkers.concat(extraMarkers);</span><span class="s3">\n        </span><span class="s1">let forLine = this.gutter.config.lineMarker(view, line, localMarkers);</span><span class="s3">\n        </span><span class="s1">if (forLine)</span><span class="s3">\n            </span><span class="s1">localMarkers.unshift(forLine);</span><span class="s3">\n        </span><span class="s1">let gutter = this.gutter;</span><span class="s3">\n        </span><span class="s1">if (localMarkers.length == 0 &amp;&amp; !gutter.config.renderEmptyElements)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">this.addElement(view, line, localMarkers);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">widget(view, block) {</span><span class="s3">\n        </span><span class="s1">let marker = this.gutter.config.widgetMarker(view, block.widget, block), markers = marker ? [marker] : null;</span><span class="s3">\n        </span><span class="s1">for (let cls of view.state.facet(gutterWidgetClass)) {</span><span class="s3">\n            </span><span class="s1">let marker = cls(view, block.widget, block);</span><span class="s3">\n            </span><span class="s1">if (marker)</span><span class="s3">\n                </span><span class="s1">(markers || (markers = [])).push(marker);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (markers)</span><span class="s3">\n            </span><span class="s1">this.addElement(view, block, markers);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">finish() {</span><span class="s3">\n        </span><span class="s1">let gutter = this.gutter;</span><span class="s3">\n        </span><span class="s1">while (gutter.elements.length &gt; this.i) {</span><span class="s3">\n            </span><span class="s1">let last = gutter.elements.pop();</span><span class="s3">\n            </span><span class="s1">gutter.dom.removeChild(last.dom);</span><span class="s3">\n            </span><span class="s1">last.destroy();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class SingleGutterView {</span><span class="s3">\n    </span><span class="s1">constructor(view, config) {</span><span class="s3">\n        </span><span class="s1">this.view = view;</span><span class="s3">\n        </span><span class="s1">this.config = config;</span><span class="s3">\n        </span><span class="s1">this.elements = [];</span><span class="s3">\n        </span><span class="s1">this.spacer = null;</span><span class="s3">\n        </span><span class="s1">this.dom = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.dom.className = </span><span class="s3">\&quot;</span><span class="s1">cm-gutter</span><span class="s3">\&quot; </span><span class="s1">+ (this.config.class ? </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ this.config.class : </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">for (let prop in config.domEventHandlers) {</span><span class="s3">\n            </span><span class="s1">this.dom.addEventListener(prop, (event) =&gt; {</span><span class="s3">\n                </span><span class="s1">let target = event.target, y;</span><span class="s3">\n                </span><span class="s1">if (target != this.dom &amp;&amp; this.dom.contains(target)) {</span><span class="s3">\n                    </span><span class="s1">while (target.parentNode != this.dom)</span><span class="s3">\n                        </span><span class="s1">target = target.parentNode;</span><span class="s3">\n                    </span><span class="s1">let rect = target.getBoundingClientRect();</span><span class="s3">\n                    </span><span class="s1">y = (rect.top + rect.bottom) / 2;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">y = event.clientY;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">let line = view.lineBlockAtHeight(y - view.documentTop);</span><span class="s3">\n                </span><span class="s1">if (config.domEventHandlers[prop](view, line, event))</span><span class="s3">\n                    </span><span class="s1">event.preventDefault();</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.markers = asArray(config.markers(view));</span><span class="s3">\n        </span><span class="s1">if (config.initialSpacer) {</span><span class="s3">\n            </span><span class="s1">this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);</span><span class="s3">\n            </span><span class="s1">this.dom.appendChild(this.spacer.dom);</span><span class="s3">\n            </span><span class="s1">this.spacer.dom.style.cssText += </span><span class="s3">\&quot;</span><span class="s1">visibility: hidden; pointer-events: none</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">let prevMarkers = this.markers;</span><span class="s3">\n        </span><span class="s1">this.markers = asArray(this.config.markers(update.view));</span><span class="s3">\n        </span><span class="s1">if (this.spacer &amp;&amp; this.config.updateSpacer) {</span><span class="s3">\n            </span><span class="s1">let updated = this.config.updateSpacer(this.spacer.markers[0], update);</span><span class="s3">\n            </span><span class="s1">if (updated != this.spacer.markers[0])</span><span class="s3">\n                </span><span class="s1">this.spacer.update(update.view, 0, 0, [updated]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let vp = update.view.viewport;</span><span class="s3">\n        </span><span class="s1">return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) ||</span><span class="s3">\n            </span><span class="s1">(this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">destroy() {</span><span class="s3">\n        </span><span class="s1">for (let elt of this.elements)</span><span class="s3">\n            </span><span class="s1">elt.destroy();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class GutterElement {</span><span class="s3">\n    </span><span class="s1">constructor(view, height, above, markers) {</span><span class="s3">\n        </span><span class="s1">this.height = -1;</span><span class="s3">\n        </span><span class="s1">this.above = 0;</span><span class="s3">\n        </span><span class="s1">this.markers = [];</span><span class="s3">\n        </span><span class="s1">this.dom = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.dom.className = </span><span class="s3">\&quot;</span><span class="s1">cm-gutterElement</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.update(view, height, above, markers);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(view, height, above, markers) {</span><span class="s3">\n        </span><span class="s1">if (this.height != height) {</span><span class="s3">\n            </span><span class="s1">this.height = height;</span><span class="s3">\n            </span><span class="s1">this.dom.style.height = height + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.above != above)</span><span class="s3">\n            </span><span class="s1">this.dom.style.marginTop = (this.above = above) ? above + </span><span class="s3">\&quot;</span><span class="s1">px</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">if (!sameMarkers(this.markers, markers))</span><span class="s3">\n            </span><span class="s1">this.setMarkers(view, markers);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setMarkers(view, markers) {</span><span class="s3">\n        </span><span class="s1">let cls = </span><span class="s3">\&quot;</span><span class="s1">cm-gutterElement</span><span class="s3">\&quot;</span><span class="s1">, domPos = this.dom.firstChild;</span><span class="s3">\n        </span><span class="s1">for (let iNew = 0, iOld = 0;;) {</span><span class="s3">\n            </span><span class="s1">let skipTo = iOld, marker = iNew &lt; markers.length ? markers[iNew++] : null, matched = false;</span><span class="s3">\n            </span><span class="s1">if (marker) {</span><span class="s3">\n                </span><span class="s1">let c = marker.elementClass;</span><span class="s3">\n                </span><span class="s1">if (c)</span><span class="s3">\n                    </span><span class="s1">cls += </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ c;</span><span class="s3">\n                </span><span class="s1">for (let i = iOld; i &lt; this.markers.length; i++)</span><span class="s3">\n                    </span><span class="s1">if (this.markers[i].compare(marker)) {</span><span class="s3">\n                        </span><span class="s1">skipTo = i;</span><span class="s3">\n                        </span><span class="s1">matched = true;</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">skipTo = this.markers.length;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">while (iOld &lt; skipTo) {</span><span class="s3">\n                </span><span class="s1">let next = this.markers[iOld++];</span><span class="s3">\n                </span><span class="s1">if (next.toDOM) {</span><span class="s3">\n                    </span><span class="s1">next.destroy(domPos);</span><span class="s3">\n                    </span><span class="s1">let after = domPos.nextSibling;</span><span class="s3">\n                    </span><span class="s1">domPos.remove();</span><span class="s3">\n                    </span><span class="s1">domPos = after;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!marker)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">if (marker.toDOM) {</span><span class="s3">\n                </span><span class="s1">if (matched)</span><span class="s3">\n                    </span><span class="s1">domPos = domPos.nextSibling;</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">this.dom.insertBefore(marker.toDOM(view), domPos);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (matched)</span><span class="s3">\n                </span><span class="s1">iOld++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.dom.className = cls;</span><span class="s3">\n        </span><span class="s1">this.markers = markers;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">destroy() {</span><span class="s3">\n        </span><span class="s1">this.setMarkers(null, []); // First argument not used unless creating markers</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function sameMarkers(a, b) {</span><span class="s3">\n    </span><span class="s1">if (a.length != b.length)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; a.length; i++)</span><span class="s3">\n        </span><span class="s1">if (!a[i].compare(b[i]))</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Facet used to provide markers to the line number gutter.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const lineNumberMarkers = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Facet used to create markers in the line number gutter next to widgets.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const lineNumberWidgetMarker = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const lineNumberConfig = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine(values) {</span><span class="s3">\n        </span><span class="s1">return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {</span><span class="s3">\n            </span><span class="s1">domEventHandlers(a, b) {</span><span class="s3">\n                </span><span class="s1">let result = Object.assign({}, a);</span><span class="s3">\n                </span><span class="s1">for (let event in b) {</span><span class="s3">\n                    </span><span class="s1">let exists = result[event], add = b[event];</span><span class="s3">\n                    </span><span class="s1">result[event] = exists ? (view, line, event) =&gt; exists(view, line, event) || add(view, line, event) : add;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return result;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">class NumberMarker extends GutterMarker {</span><span class="s3">\n    </span><span class="s1">constructor(number) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.number = number;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(other) { return this.number == other.number; }</span><span class="s3">\n    </span><span class="s1">toDOM() { return document.createTextNode(this.number); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function formatNumber(view, number) {</span><span class="s3">\n    </span><span class="s1">return view.state.facet(lineNumberConfig).formatNumber(number, view.state);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const lineNumberGutter = /*@__PURE__*/activeGutters.compute([lineNumberConfig], state =&gt; ({</span><span class="s3">\n    </span><span class="s1">class: </span><span class="s3">\&quot;</span><span class="s1">cm-lineNumbers</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">renderEmptyElements: false,</span><span class="s3">\n    </span><span class="s1">markers(view) { return view.state.facet(lineNumberMarkers); },</span><span class="s3">\n    </span><span class="s1">lineMarker(view, line, others) {</span><span class="s3">\n        </span><span class="s1">if (others.some(m =&gt; m.toDOM))</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">widgetMarker: (view, widget, block) =&gt; {</span><span class="s3">\n        </span><span class="s1">for (let m of view.state.facet(lineNumberWidgetMarker)) {</span><span class="s3">\n            </span><span class="s1">let result = m(view, widget, block);</span><span class="s3">\n            </span><span class="s1">if (result)</span><span class="s3">\n                </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">lineMarkerChange: update =&gt; update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),</span><span class="s3">\n    </span><span class="s1">initialSpacer(view) {</span><span class="s3">\n        </span><span class="s1">return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">updateSpacer(spacer, update) {</span><span class="s3">\n        </span><span class="s1">let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));</span><span class="s3">\n        </span><span class="s1">return max == spacer.number ? spacer : new NumberMarker(max);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">domEventHandlers: state.facet(lineNumberConfig).domEventHandlers</span><span class="s3">\n</span><span class="s1">}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Create a line number gutter extension.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function lineNumbers(config = {}) {</span><span class="s3">\n    </span><span class="s1">return [</span><span class="s3">\n        </span><span class="s1">lineNumberConfig.of(config),</span><span class="s3">\n        </span><span class="s1">gutters(),</span><span class="s3">\n        </span><span class="s1">lineNumberGutter</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function maxLineNumber(lines) {</span><span class="s3">\n    </span><span class="s1">let last = 9;</span><span class="s3">\n    </span><span class="s1">while (last &lt; lines)</span><span class="s3">\n        </span><span class="s1">last = last * 10 + 9;</span><span class="s3">\n    </span><span class="s1">return last;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const activeLineGutterMarker = /*@__PURE__*/new class extends GutterMarker {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.elementClass = </span><span class="s3">\&quot;</span><span class="s1">cm-activeLineGutter</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const activeLineGutterHighlighter = /*@__PURE__*/gutterLineClass.compute([</span><span class="s3">\&quot;</span><span class="s1">selection</span><span class="s3">\&quot;</span><span class="s1">], state =&gt; {</span><span class="s3">\n    </span><span class="s1">let marks = [], last = -1;</span><span class="s3">\n    </span><span class="s1">for (let range of state.selection.ranges) {</span><span class="s3">\n        </span><span class="s1">let linePos = state.doc.lineAt(range.head).from;</span><span class="s3">\n        </span><span class="s1">if (linePos &gt; last) {</span><span class="s3">\n            </span><span class="s1">last = linePos;</span><span class="s3">\n            </span><span class="s1">marks.push(activeLineGutterMarker.range(linePos));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return RangeSet.of(marks);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Returns an extension that adds a `cm-activeLineGutter` class to</span><span class="s3">\n</span><span class="s1">all gutter elements on the [active</span><span class="s3">\n</span><span class="s1">line](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function highlightActiveLineGutter() {</span><span class="s3">\n    </span><span class="s1">return activeLineGutterHighlighter;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function matcher(decorator) {</span><span class="s3">\n    </span><span class="s1">return ViewPlugin.define(view =&gt; ({</span><span class="s3">\n        </span><span class="s1">decorations: decorator.createDeco(view),</span><span class="s3">\n        </span><span class="s1">update(u) {</span><span class="s3">\n            </span><span class="s1">this.decorations = decorator.updateDeco(u, this.decorations);</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">}), {</span><span class="s3">\n        </span><span class="s1">decorations: v =&gt; v.decorations</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const tabDeco = /*@__PURE__*/Decoration.mark({ class: </span><span class="s3">\&quot;</span><span class="s1">cm-highlightTab</span><span class="s3">\&quot; </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const spaceDeco = /*@__PURE__*/Decoration.mark({ class: </span><span class="s3">\&quot;</span><span class="s1">cm-highlightSpace</span><span class="s3">\&quot; </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const whitespaceHighlighter = /*@__PURE__*/matcher(/*@__PURE__*/new MatchDecorator({</span><span class="s3">\n    </span><span class="s1">regexp: /</span><span class="s3">\\</span><span class="s1">t| /g,</span><span class="s3">\n    </span><span class="s1">decoration: match =&gt; match[0] == </span><span class="s3">\&quot;\\</span><span class="s1">t</span><span class="s3">\&quot; </span><span class="s1">? tabDeco : spaceDeco,</span><span class="s3">\n    </span><span class="s1">boundary: /</span><span class="s3">\\</span><span class="s1">S/,</span><span class="s3">\n</span><span class="s1">}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Returns an extension that highlights whitespace, adding a</span><span class="s3">\n</span><span class="s1">`cm-highlightSpace` class to stretches of spaces, and a</span><span class="s3">\n</span><span class="s1">`cm-highlightTab` class to individual tab characters. By default,</span><span class="s3">\n</span><span class="s1">the former are shown as faint dots, and the latter as arrows.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function highlightWhitespace() {</span><span class="s3">\n    </span><span class="s1">return whitespaceHighlighter;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const trailingHighlighter = /*@__PURE__*/matcher(/*@__PURE__*/new MatchDecorator({</span><span class="s3">\n    </span><span class="s1">regexp: /</span><span class="s3">\\</span><span class="s1">s+$/g,</span><span class="s3">\n    </span><span class="s1">decoration: /*@__PURE__*/Decoration.mark({ class: </span><span class="s3">\&quot;</span><span class="s1">cm-trailingSpace</span><span class="s3">\&quot; </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">boundary: /</span><span class="s3">\\</span><span class="s1">S/,</span><span class="s3">\n</span><span class="s1">}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Returns an extension that adds a `cm-trailingSpace` class to all</span><span class="s3">\n</span><span class="s1">trailing whitespace.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function highlightTrailingWhitespace() {</span><span class="s3">\n    </span><span class="s1">return trailingHighlighter;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">@internal</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const __test = { HeightMap, HeightOracle, MeasuredHeights, QueryType, ChangedRange, computeOrder,</span><span class="s3">\n    </span><span class="s1">moveVisually, clearHeightChangeFlag, getHeightChangeFlag: () =&gt; heightChangeFlag };</span><span class="s3">\n\n</span><span class="s1">export { BidiSpan, BlockInfo, BlockType, Decoration, Direction, EditorView, GutterMarker, MatchDecorator, RectangleMarker, ViewPlugin, ViewUpdate, WidgetType, __test, closeHoverTooltips, crosshairCursor, drawSelection, dropCursor, getDrawSelectionConfig, getPanel, getTooltip, gutter, gutterLineClass, gutterWidgetClass, gutters, hasHoverTooltips, highlightActiveLine, highlightActiveLineGutter, highlightSpecialChars, highlightTrailingWhitespace, highlightWhitespace, hoverTooltip, keymap, layer, lineNumberMarkers, lineNumberWidgetMarker, lineNumbers, logException, panels, placeholder, rectangularSelection, repositionTooltips, runScopeHandlers, scrollPastEnd, showPanel, showTooltip, tooltips };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const C = </span><span class="s3">\&quot;\\</span><span class="s1">u037c</span><span class="s3">\&quot;\n</span><span class="s1">const COUNT = typeof Symbol == </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">__</span><span class="s3">\&quot; </span><span class="s1">+ C : Symbol.for(C)</span><span class="s3">\n</span><span class="s1">const SET = typeof Symbol == </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">__styleSet</span><span class="s3">\&quot; </span><span class="s1">+ Math.floor(Math.random() * 1e8) : Symbol(</span><span class="s3">\&quot;</span><span class="s1">styleSet</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">const top = typeof globalThis != </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">? globalThis : typeof window != </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">? window : {}</span><span class="s3">\n\n</span><span class="s1">// :: - Style modules encapsulate a set of CSS rules defined from</span><span class="s3">\n</span><span class="s1">// JavaScript. Their definitions are only available in a given DOM</span><span class="s3">\n</span><span class="s1">// root after it has been _mounted_ there with `StyleModule.mount`.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Style modules should be created once and stored somewhere, as</span><span class="s3">\n</span><span class="s1">// opposed to re-creating them every time you need them. The amount of</span><span class="s3">\n</span><span class="s1">// CSS rules generated for a given DOM root is bounded by the amount</span><span class="s3">\n</span><span class="s1">// of style modules that were used. So to avoid leaking rules, don't</span><span class="s3">\n</span><span class="s1">// create these dynamically, but treat them as one-time allocations.</span><span class="s3">\n</span><span class="s1">export class StyleModule {</span><span class="s3">\n  </span><span class="s1">// :: (Object&lt;Style&gt;, ?{finish: ?(string)  string})</span><span class="s3">\n  </span><span class="s1">// Create a style module from the given spec.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// When `finish` is given, it is called on regular (non-`@`)</span><span class="s3">\n  </span><span class="s1">// selectors (after `&amp;` expansion) to compute the final selector.</span><span class="s3">\n  </span><span class="s1">constructor(spec, options) {</span><span class="s3">\n    </span><span class="s1">this.rules = []</span><span class="s3">\n    </span><span class="s1">let {finish} = options || {}</span><span class="s3">\n\n    </span><span class="s1">function splitSelector(selector) {</span><span class="s3">\n      </span><span class="s1">return /^@/.test(selector) ? [selector] : selector.split(/,</span><span class="s3">\\</span><span class="s1">s*/)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">function render(selectors, spec, target, isKeyframes) {</span><span class="s3">\n      </span><span class="s1">let local = [], isAt = /^@(</span><span class="s3">\\</span><span class="s1">w+)</span><span class="s3">\\</span><span class="s1">b/.exec(selectors[0]), keyframes = isAt &amp;&amp; isAt[1] == </span><span class="s3">\&quot;</span><span class="s1">keyframes</span><span class="s3">\&quot;\n      </span><span class="s1">if (isAt &amp;&amp; spec == null) return target.push(selectors[0] + </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">for (let prop in spec) {</span><span class="s3">\n        </span><span class="s1">let value = spec[prop]</span><span class="s3">\n        </span><span class="s1">if (/&amp;/.test(prop)) {</span><span class="s3">\n          </span><span class="s1">render(prop.split(/,</span><span class="s3">\\</span><span class="s1">s*/).map(part =&gt; selectors.map(sel =&gt; part.replace(/&amp;/, sel))).reduce((a, b) =&gt; a.concat(b)),</span><span class="s3">\n                 </span><span class="s1">value, target)</span><span class="s3">\n        </span><span class="s1">} else if (value &amp;&amp; typeof value == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">if (!isAt) throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">The value of a property (</span><span class="s3">\&quot; </span><span class="s1">+ prop + </span><span class="s3">\&quot;</span><span class="s1">) should be a primitive value.</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">render(splitSelector(prop), value, local, keyframes)</span><span class="s3">\n        </span><span class="s1">} else if (value != null) {</span><span class="s3">\n          </span><span class="s1">local.push(prop.replace(/_.*/, </span><span class="s3">\&quot;\&quot;</span><span class="s1">).replace(/[A-Z]/g, l =&gt; </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot; </span><span class="s1">+ l.toLowerCase()) + </span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot; </span><span class="s1">+ value + </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (local.length || keyframes) {</span><span class="s3">\n        </span><span class="s1">target.push((finish &amp;&amp; !isAt &amp;&amp; !isKeyframes ? selectors.map(finish) : selectors).join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">) +</span><span class="s3">\n                    \&quot; </span><span class="s1">{</span><span class="s3">\&quot; </span><span class="s1">+ local.join(</span><span class="s3">\&quot; \&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// :: ()  string</span><span class="s3">\n  </span><span class="s1">// Returns a string containing the module's CSS rules.</span><span class="s3">\n  </span><span class="s1">getRules() { return this.rules.join(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">) }</span><span class="s3">\n\n  </span><span class="s1">// :: ()  string</span><span class="s3">\n  </span><span class="s1">// Generate a new unique CSS class name.</span><span class="s3">\n  </span><span class="s1">static newName() {</span><span class="s3">\n    </span><span class="s1">let id = top[COUNT] || 1</span><span class="s3">\n    </span><span class="s1">top[COUNT] = id + 1</span><span class="s3">\n    </span><span class="s1">return C + id.toString(36)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// :: (union&lt;Document, ShadowRoot&gt;, union&lt;[StyleModule], StyleModule&gt;, ?{nonce: ?string})</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Mount the given set of modules in the given DOM root, which ensures</span><span class="s3">\n  </span><span class="s1">// that the CSS rules defined by the module are available in that</span><span class="s3">\n  </span><span class="s1">// context.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Rules are only added to the document once per root.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Rule order will follow the order of the modules, so that rules from</span><span class="s3">\n  </span><span class="s1">// modules later in the array take precedence of those from earlier</span><span class="s3">\n  </span><span class="s1">// modules. If you call this function multiple times for the same root</span><span class="s3">\n  </span><span class="s1">// in a way that changes the order of already mounted modules, the old</span><span class="s3">\n  </span><span class="s1">// order will be changed.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// If a Content Security Policy nonce is provided, it is added to</span><span class="s3">\n  </span><span class="s1">// the `&lt;style&gt;` tag generated by the library.</span><span class="s3">\n  </span><span class="s1">static mount(root, modules, options) {</span><span class="s3">\n    </span><span class="s1">let set = root[SET], nonce = options &amp;&amp; options.nonce</span><span class="s3">\n    </span><span class="s1">if (!set) set = new StyleSet(root, nonce)</span><span class="s3">\n    </span><span class="s1">else if (nonce) set.setNonce(nonce)</span><span class="s3">\n    </span><span class="s1">set.mount(Array.isArray(modules) ? modules : [modules])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">let adoptedSet = new Map //&lt;Document, StyleSet&gt;</span><span class="s3">\n\n</span><span class="s1">class StyleSet {</span><span class="s3">\n  </span><span class="s1">constructor(root, nonce) {</span><span class="s3">\n    </span><span class="s1">let doc = root.ownerDocument || root, win = doc.defaultView</span><span class="s3">\n    </span><span class="s1">if (!root.head &amp;&amp; root.adoptedStyleSheets &amp;&amp; win.CSSStyleSheet) {</span><span class="s3">\n      </span><span class="s1">let adopted = adoptedSet.get(doc)</span><span class="s3">\n      </span><span class="s1">if (adopted) {</span><span class="s3">\n        </span><span class="s1">root.adoptedStyleSheets = [adopted.sheet, ...root.adoptedStyleSheets]</span><span class="s3">\n        </span><span class="s1">return root[SET] = adopted</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.sheet = new win.CSSStyleSheet</span><span class="s3">\n      </span><span class="s1">root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets]</span><span class="s3">\n      </span><span class="s1">adoptedSet.set(doc, this)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.styleTag = doc.createElement(</span><span class="s3">\&quot;</span><span class="s1">style</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">if (nonce) this.styleTag.setAttribute(</span><span class="s3">\&quot;</span><span class="s1">nonce</span><span class="s3">\&quot;</span><span class="s1">, nonce)</span><span class="s3">\n      </span><span class="s1">let target = root.head || root</span><span class="s3">\n      </span><span class="s1">target.insertBefore(this.styleTag, target.firstChild)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.modules = []</span><span class="s3">\n    </span><span class="s1">root[SET] = this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">mount(modules) {</span><span class="s3">\n    </span><span class="s1">let sheet = this.sheet</span><span class="s3">\n    </span><span class="s1">let pos = 0 /* Current rule offset */, j = 0 /* Index into this.modules */</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; modules.length; i++) {</span><span class="s3">\n      </span><span class="s1">let mod = modules[i], index = this.modules.indexOf(mod)</span><span class="s3">\n      </span><span class="s1">if (index &lt; j &amp;&amp; index &gt; -1) { // Ordering conflict</span><span class="s3">\n        </span><span class="s1">this.modules.splice(index, 1)</span><span class="s3">\n        </span><span class="s1">j--</span><span class="s3">\n        </span><span class="s1">index = -1</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (index == -1) {</span><span class="s3">\n        </span><span class="s1">this.modules.splice(j++, 0, mod)</span><span class="s3">\n        </span><span class="s1">if (sheet) for (let k = 0; k &lt; mod.rules.length; k++)</span><span class="s3">\n          </span><span class="s1">sheet.insertRule(mod.rules[k], pos++)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">while (j &lt; index) pos += this.modules[j++].rules.length</span><span class="s3">\n        </span><span class="s1">pos += mod.rules.length</span><span class="s3">\n        </span><span class="s1">j++</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!sheet) {</span><span class="s3">\n      </span><span class="s1">let text = </span><span class="s3">\&quot;\&quot;\n      </span><span class="s1">for (let i = 0; i &lt; this.modules.length; i++)</span><span class="s3">\n        </span><span class="s1">text += this.modules[i].getRules() + </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;\n      </span><span class="s1">this.styleTag.textContent = text</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">setNonce(nonce) {</span><span class="s3">\n    </span><span class="s1">if (this.styleTag &amp;&amp; this.styleTag.getAttribute(</span><span class="s3">\&quot;</span><span class="s1">nonce</span><span class="s3">\&quot;</span><span class="s1">) != nonce)</span><span class="s3">\n      </span><span class="s1">this.styleTag.setAttribute(</span><span class="s3">\&quot;</span><span class="s1">nonce</span><span class="s3">\&quot;</span><span class="s1">, nonce)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Style::Object&lt;union&lt;Style,string&gt;&gt;</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// A style is an object that, in the simple case, maps CSS property</span><span class="s3">\n</span><span class="s1">// names to strings holding their values, as in `{color: </span><span class="s3">\&quot;</span><span class="s1">red</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">// fontWeight: </span><span class="s3">\&quot;</span><span class="s1">bold</span><span class="s3">\&quot;</span><span class="s1">}`. The property names can be given in</span><span class="s3">\n</span><span class="s1">// camel-casethe library will insert a dash before capital letters</span><span class="s3">\n</span><span class="s1">// when converting them to CSS.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// If you include an underscore in a property name, it and everything</span><span class="s3">\n</span><span class="s1">// after it will be removed from the output, which can be useful when</span><span class="s3">\n</span><span class="s1">// providing a property multiple times, for browser compatibility</span><span class="s3">\n</span><span class="s1">// reasons.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// A property in a style object can also be a sub-selector, which</span><span class="s3">\n</span><span class="s1">// extends the current context to add a pseudo-selector or a child</span><span class="s3">\n</span><span class="s1">// selector. Such a property should contain a `&amp;` character, which</span><span class="s3">\n</span><span class="s1">// will be replaced by the current selector. For example `{</span><span class="s3">\&quot;</span><span class="s1">&amp;:before</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n</span><span class="s1">// {content: '</span><span class="s3">\&quot;</span><span class="s1">hi</span><span class="s3">\&quot;</span><span class="s1">'}}`. Sub-selectors and regular properties can</span><span class="s3">\n</span><span class="s1">// freely be mixed in a given object. Any property containing a `&amp;` is</span><span class="s3">\n</span><span class="s1">// assumed to be a sub-selector.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Finally, a property can specify an @-block to be wrapped around the</span><span class="s3">\n</span><span class="s1">// styles defined inside the object that's the property's value. For</span><span class="s3">\n</span><span class="s1">// example to create a media query you can do `{</span><span class="s3">\&quot;</span><span class="s1">@media screen and</span><span class="s3">\n</span><span class="s1">// (min-width: 400px)</span><span class="s3">\&quot;</span><span class="s1">: {...}}`.</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>