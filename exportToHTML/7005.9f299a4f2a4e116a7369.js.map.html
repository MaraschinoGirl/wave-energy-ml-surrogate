<html>
<head>
<title>7005.9f299a4f2a4e116a7369.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
7005.9f299a4f2a4e116a7369.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;7005.9f299a4f2a4e116a7369.js?v=9f299a4f2a4e116a7369&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;AAAA;AACA;AACA;AACA,wBAAwB,4DAA4D;;AAEpF;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,2BAA2B,sBAAsB;AACjD,mDAAmD;AACnD,6DAA6D;AAC7D,iDAAiD,IAAI,cAAc;;AAEnE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,IAAI;AACvD;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,IAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/legacy-modes/mode/puppet.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// Stores the words from the define method</span><span class="s3">\n</span><span class="s1">var words = {};</span><span class="s3">\n</span><span class="s1">// Taken, mostly, from the Puppet official variable standards regex</span><span class="s3">\n</span><span class="s1">var variable_regex = /({)?([a-z][a-z0-9_]*)?((::[a-z][a-z0-9_]*)*::)?[a-zA-Z0-9_]+(})?/;</span><span class="s3">\n\n</span><span class="s1">// Takes a string of words separated by spaces and adds them as</span><span class="s3">\n</span><span class="s1">// keys with the value of the first argument 'style'</span><span class="s3">\n</span><span class="s1">function define(style, string) {</span><span class="s3">\n  </span><span class="s1">var split = string.split(' ');</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; split.length; i++) {</span><span class="s3">\n    </span><span class="s1">words[split[i]] = style;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Takes commonly known puppet types/words and classifies them to a style</span><span class="s3">\n</span><span class="s1">define('keyword', 'class define site node include import inherits');</span><span class="s3">\n</span><span class="s1">define('keyword', 'case if else in and elsif default or');</span><span class="s3">\n</span><span class="s1">define('atom', 'false true running present absent file directory undef');</span><span class="s3">\n</span><span class="s1">define('builtin', 'action augeas burst chain computer cron destination dport exec ' +</span><span class="s3">\n       </span><span class="s1">'file filebucket group host icmp iniface interface jump k5login limit log_level ' +</span><span class="s3">\n       </span><span class="s1">'log_prefix macauthorization mailalias maillist mcx mount nagios_command ' +</span><span class="s3">\n       </span><span class="s1">'nagios_contact nagios_contactgroup nagios_host nagios_hostdependency ' +</span><span class="s3">\n       </span><span class="s1">'nagios_hostescalation nagios_hostextinfo nagios_hostgroup nagios_service ' +</span><span class="s3">\n       </span><span class="s1">'nagios_servicedependency nagios_serviceescalation nagios_serviceextinfo ' +</span><span class="s3">\n       </span><span class="s1">'nagios_servicegroup nagios_timeperiod name notify outiface package proto reject ' +</span><span class="s3">\n       </span><span class="s1">'resources router schedule scheduled_task selboolean selmodule service source ' +</span><span class="s3">\n       </span><span class="s1">'sport ssh_authorized_key sshkey stage state table tidy todest toports tosource ' +</span><span class="s3">\n       </span><span class="s1">'user vlan yumrepo zfs zone zpool');</span><span class="s3">\n\n</span><span class="s1">// After finding a start of a string ('|</span><span class="s3">\&quot;</span><span class="s1">) this function attempts to find the end;</span><span class="s3">\n</span><span class="s1">// If a variable is encountered along the way, we display it differently when it</span><span class="s3">\n</span><span class="s1">// is encapsulated in a double-quoted string.</span><span class="s3">\n</span><span class="s1">function tokenString(stream, state) {</span><span class="s3">\n  </span><span class="s1">var current, prev, found_var = false;</span><span class="s3">\n  </span><span class="s1">while (!stream.eol() &amp;&amp; (current = stream.next()) != state.pending) {</span><span class="s3">\n    </span><span class="s1">if (current === '$' &amp;&amp; prev != '</span><span class="s3">\\\\</span><span class="s1">' &amp;&amp; state.pending == '</span><span class="s3">\&quot;</span><span class="s1">') {</span><span class="s3">\n      </span><span class="s1">found_var = true;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">prev = current;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (found_var) {</span><span class="s3">\n    </span><span class="s1">stream.backUp(1);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (current == state.pending) {</span><span class="s3">\n    </span><span class="s1">state.continueString = false;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">state.continueString = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Main function</span><span class="s3">\n</span><span class="s1">function tokenize(stream, state) {</span><span class="s3">\n  </span><span class="s1">// Matches one whole word</span><span class="s3">\n  </span><span class="s1">var word = stream.match(/[</span><span class="s3">\\</span><span class="s1">w]+/, false);</span><span class="s3">\n  </span><span class="s1">// Matches attributes (i.e. ensure =&gt; present ; 'ensure' would be matched)</span><span class="s3">\n  </span><span class="s1">var attribute = stream.match(/(</span><span class="s3">\\</span><span class="s1">s+)?</span><span class="s3">\\</span><span class="s1">w+</span><span class="s3">\\</span><span class="s1">s+=&gt;.*/, false);</span><span class="s3">\n  </span><span class="s1">// Matches non-builtin resource declarations</span><span class="s3">\n  </span><span class="s1">// (i.e. </span><span class="s3">\&quot;</span><span class="s1">apache::vhost {</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">mycustomclasss {</span><span class="s3">\&quot; </span><span class="s1">would be matched)</span><span class="s3">\n  </span><span class="s1">var resource = stream.match(/(</span><span class="s3">\\</span><span class="s1">s+)?[</span><span class="s3">\\</span><span class="s1">w:_]+(</span><span class="s3">\\</span><span class="s1">s+)?{/, false);</span><span class="s3">\n  </span><span class="s1">// Matches virtual and exported resources (i.e. @@user { ; and the like)</span><span class="s3">\n  </span><span class="s1">var special_resource = stream.match(/(</span><span class="s3">\\</span><span class="s1">s+)?[@]{1,2}[</span><span class="s3">\\</span><span class="s1">w:_]+(</span><span class="s3">\\</span><span class="s1">s+)?{/, false);</span><span class="s3">\n\n  </span><span class="s1">// Finally advance the stream</span><span class="s3">\n  </span><span class="s1">var ch = stream.next();</span><span class="s3">\n\n  </span><span class="s1">// Have we found a variable?</span><span class="s3">\n  </span><span class="s1">if (ch === '$') {</span><span class="s3">\n    </span><span class="s1">if (stream.match(variable_regex)) {</span><span class="s3">\n      </span><span class="s1">// If so, and its in a string, assign it a different color</span><span class="s3">\n      </span><span class="s1">return state.continueString ? 'variableName.special' : 'variable';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Otherwise return an invalid variable</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Should we still be looking for the end of a string?</span><span class="s3">\n  </span><span class="s1">if (state.continueString) {</span><span class="s3">\n    </span><span class="s1">// If so, go through the loop again</span><span class="s3">\n    </span><span class="s1">stream.backUp(1);</span><span class="s3">\n    </span><span class="s1">return tokenString(stream, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Are we in a definition (class, node, define)?</span><span class="s3">\n  </span><span class="s1">if (state.inDefinition) {</span><span class="s3">\n    </span><span class="s1">// If so, return def (i.e. for 'class myclass {' ; 'myclass' would be matched)</span><span class="s3">\n    </span><span class="s1">if (stream.match(/(</span><span class="s3">\\</span><span class="s1">s+)?[</span><span class="s3">\\</span><span class="s1">w:_]+(</span><span class="s3">\\</span><span class="s1">s+)?/)) {</span><span class="s3">\n      </span><span class="s1">return 'def';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Match the rest it the next time around</span><span class="s3">\n    </span><span class="s1">stream.match(/</span><span class="s3">\\</span><span class="s1">s+{/);</span><span class="s3">\n    </span><span class="s1">state.inDefinition = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Are we in an 'include' statement?</span><span class="s3">\n  </span><span class="s1">if (state.inInclude) {</span><span class="s3">\n    </span><span class="s1">// Match and return the included class</span><span class="s3">\n    </span><span class="s1">stream.match(/(</span><span class="s3">\\</span><span class="s1">s+)?</span><span class="s3">\\</span><span class="s1">S+(</span><span class="s3">\\</span><span class="s1">s+)?/);</span><span class="s3">\n    </span><span class="s1">state.inInclude = false;</span><span class="s3">\n    </span><span class="s1">return 'def';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Do we just have a function on our hands?</span><span class="s3">\n  </span><span class="s1">// In 'ensure_resource(</span><span class="s3">\&quot;</span><span class="s1">myclass</span><span class="s3">\&quot;</span><span class="s1">)', 'ensure_resource' is matched</span><span class="s3">\n  </span><span class="s1">if (stream.match(/(</span><span class="s3">\\</span><span class="s1">s+)?</span><span class="s3">\\</span><span class="s1">w+</span><span class="s3">\\</span><span class="s1">(/)) {</span><span class="s3">\n    </span><span class="s1">stream.backUp(1);</span><span class="s3">\n    </span><span class="s1">return 'def';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Have we matched the prior attribute regex?</span><span class="s3">\n  </span><span class="s1">if (attribute) {</span><span class="s3">\n    </span><span class="s1">stream.match(/(</span><span class="s3">\\</span><span class="s1">s+)?</span><span class="s3">\\</span><span class="s1">w+/);</span><span class="s3">\n    </span><span class="s1">return 'tag';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Do we have Puppet specific words?</span><span class="s3">\n  </span><span class="s1">if (word &amp;&amp; words.hasOwnProperty(word)) {</span><span class="s3">\n    </span><span class="s1">// Negates the initial next()</span><span class="s3">\n    </span><span class="s1">stream.backUp(1);</span><span class="s3">\n    </span><span class="s1">// rs move the stream</span><span class="s3">\n    </span><span class="s1">stream.match(/[</span><span class="s3">\\</span><span class="s1">w]+/);</span><span class="s3">\n    </span><span class="s1">// We want to process these words differently</span><span class="s3">\n    </span><span class="s1">// do to the importance they have in Puppet</span><span class="s3">\n    </span><span class="s1">if (stream.match(/</span><span class="s3">\\</span><span class="s1">s+</span><span class="s3">\\</span><span class="s1">S+</span><span class="s3">\\</span><span class="s1">s+{/, false)) {</span><span class="s3">\n      </span><span class="s1">state.inDefinition = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (word == 'include') {</span><span class="s3">\n      </span><span class="s1">state.inInclude = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Returns their value as state in the prior define methods</span><span class="s3">\n    </span><span class="s1">return words[word];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Is there a match on a reference?</span><span class="s3">\n  </span><span class="s1">if (/(^|</span><span class="s3">\\</span><span class="s1">s+)[A-Z][</span><span class="s3">\\</span><span class="s1">w:_]+/.test(word)) {</span><span class="s3">\n    </span><span class="s1">// Negate the next()</span><span class="s3">\n    </span><span class="s1">stream.backUp(1);</span><span class="s3">\n    </span><span class="s1">// Match the full reference</span><span class="s3">\n    </span><span class="s1">stream.match(/(^|</span><span class="s3">\\</span><span class="s1">s+)[A-Z][</span><span class="s3">\\</span><span class="s1">w:_]+/);</span><span class="s3">\n    </span><span class="s1">return 'def';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Have we matched the prior resource regex?</span><span class="s3">\n  </span><span class="s1">if (resource) {</span><span class="s3">\n    </span><span class="s1">stream.match(/(</span><span class="s3">\\</span><span class="s1">s+)?[</span><span class="s3">\\</span><span class="s1">w:_]+/);</span><span class="s3">\n    </span><span class="s1">return 'def';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Have we matched the prior special_resource regex?</span><span class="s3">\n  </span><span class="s1">if (special_resource) {</span><span class="s3">\n    </span><span class="s1">stream.match(/(</span><span class="s3">\\</span><span class="s1">s+)?[@]{1,2}/);</span><span class="s3">\n    </span><span class="s1">return 'atom';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Match all the comments. All of them.</span><span class="s3">\n  </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">stream.skipToEnd();</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Have we found a string?</span><span class="s3">\n  </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot; </span><span class="s1">|| ch == '</span><span class="s3">\&quot;</span><span class="s1">') {</span><span class="s3">\n    </span><span class="s1">// Store the type (single or double)</span><span class="s3">\n    </span><span class="s1">state.pending = ch;</span><span class="s3">\n    </span><span class="s1">// Perform the looping function to find the end</span><span class="s3">\n    </span><span class="s1">return tokenString(stream, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Match all the brackets</span><span class="s3">\n  </span><span class="s1">if (ch == '{' || ch == '}') {</span><span class="s3">\n    </span><span class="s1">return 'bracket';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Match characters that we are going to assume</span><span class="s3">\n  </span><span class="s1">// are trying to be regex</span><span class="s3">\n  </span><span class="s1">if (ch == '/') {</span><span class="s3">\n    </span><span class="s1">stream.match(/^[^</span><span class="s3">\\</span><span class="s1">/]*</span><span class="s3">\\</span><span class="s1">//);</span><span class="s3">\n    </span><span class="s1">return 'string.special';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Match all the numbers</span><span class="s3">\n  </span><span class="s1">if (ch.match(/[0-9]/)) {</span><span class="s3">\n    </span><span class="s1">stream.eatWhile(/[0-9]+/);</span><span class="s3">\n    </span><span class="s1">return 'number';</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Match the '=' and '=&gt;' operators</span><span class="s3">\n  </span><span class="s1">if (ch == '=') {</span><span class="s3">\n    </span><span class="s1">if (stream.peek() == '&gt;') {</span><span class="s3">\n      </span><span class="s1">stream.next();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Keep advancing through all the rest</span><span class="s3">\n  </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w-]/);</span><span class="s3">\n  </span><span class="s1">// Return a blank line for everything else</span><span class="s3">\n  </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Start it all</span><span class="s3">\n</span><span class="s1">export const puppet = {</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">puppet</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\n  </span><span class="s1">startState: function () {</span><span class="s3">\n    </span><span class="s1">var state = {};</span><span class="s3">\n    </span><span class="s1">state.inDefinition = false;</span><span class="s3">\n    </span><span class="s1">state.inInclude = false;</span><span class="s3">\n    </span><span class="s1">state.continueString = false;</span><span class="s3">\n    </span><span class="s1">state.pending = false;</span><span class="s3">\n    </span><span class="s1">return state;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">token: function (stream, state) {</span><span class="s3">\n    </span><span class="s1">// Strip the spaces, but regex will account for them eitherway</span><span class="s3">\n    </span><span class="s1">if (stream.eatSpace()) return null;</span><span class="s3">\n    </span><span class="s1">// Go through the main process</span><span class="s3">\n    </span><span class="s1">return tokenize(stream, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>