<html>
<head>
<title>6271.4fc234c8efd9c3936791.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
6271.4fc234c8efd9c3936791.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;6271.4fc234c8efd9c3936791.js?v=4fc234c8efd9c3936791&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAsF;AAC9B;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8BAAQ;AAClC;AACA;AACA,uBAAuB,8BAAQ;AAC/B,wBAAwB,0BAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAAI;AACvB,2DAA2D,0BAAI,CAAC,8BAAQ;AACxE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oBAAoB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uCAAuC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB;AACxB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wBAAwB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,OAAO;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gDAAgD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2FAA2F;AACxH,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,eAAe;AACf,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO,UAAU,YAAY;AAC3C;AACA;AACA,eAAe,gCAAgC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAAI;AACnB;AACA;AACA,6BAA6B,4BAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6BAA6B;AAC3C;AACA;AACA,gDAAgD;AAChD;AACA;AACA,sBAAsB,gCAAgC,2BAA2B,UAAU;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAAQ;AACvC;AACA;AACA,sCAAsC,8BAAQ;AAC9C,iBAAiB;AACjB;AACA;AACA;AACA,iEAAiE,4BAAG;AACpE;AACA;AACA;AACA;AACA;AACA,0BAA0B,6BAAO;AACjC;AACA,yCAAyC,sCAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,KAAK;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,aAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,KAAK;AACnF;AACA;AACA,iBAAiB,8BAAQ;AACzB,sBAAsB,gBAAgB;AACtC,mBAAmB,8BAAQ;AAC3B;AACA;AACA,yCAAyC,8BAAQ;AACjD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAAI;AACnB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,iBAAiB;AACjB,qBAAqB;AACrB;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,2BAA2B;AAC3B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,aAAa,EAAE;AACpD,uCAAuC,eAAe,EAAE;AACxD;AACA,mCAAmC,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mEAAmE,EAAE,wBAAwB,KAAK,iCAAiC,KAAK;AACxI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,mBAAmB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,WAAW;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8BAAQ;AACzC;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA,gCAAgC,0BAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sCAAS;AACtC,sBAAsB,6BAAI;AAC1B,oBAAoB,6BAAI;AACxB,0CAA0C,6BAAI;AAC9C,0CAA0C,6BAAI;AAC9C,uBAAuB,6BAAI;AAC3B,uBAAuB,6BAAI;AAC3B,uBAAuB,6BAAI;AAC3B,uBAAuB,6BAAI;AAC3B,4BAA4B,6BAAI;AAChC,YAAY,6BAAI;AAChB,YAAY,6BAAI;AAChB,oBAAoB,6BAAI;AACxB,0BAA0B,6BAAI;AAC9B,0BAA0B,6BAAI;AAC9B,sCAAsC,6BAAI;AAC1C,sBAAsB,6BAAI;AAC1B,2BAA2B,6BAAI;AAC/B,oBAAoB,6BAAI;AACxB,8EAA8E,6BAAI;AAClF,0BAA0B,6BAAI;AAC9B,eAAe,6BAAI;AACnB,eAAe,6BAAI;AACnB,CAAC;AACD;AACA,sCAAsC,6BAAO;;AAE7C;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,0BAA0B,wBAAwB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,yBAAyB;AACnC,eAAe,oCAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,KAAK;AACL,aAAa;AACb;;AAEA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB,6BAAI;AAC9C,SAAS;AACT;AACA,mBAAmB,6BAAI;AACvB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,4BAA4B;AACtC,UAAU,8BAA8B,mBAAmB,6BAAI,YAAY;AAC3E;AACA,UAAU,0BAA0B,6BAAI,UAAU;AAClD,UAAU,+BAA+B,6BAAI,wBAAwB;AACrE;AACA;AACA;AACA,4BAA4B,2DAA2D;AACvF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kCAAkC,6BAAI,OAAO;AACvD,UAAU,2BAA2B,6BAAI;AACzC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,4BAA4B,6BAAI,SAAS,6BAAI,WAAW;AAClE,UAAU,gCAAgC,6BAAI;AAC9C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,0BAA0B,6BAAI,SAAS,6BAAI,WAAW;AAChE,UAAU,8BAA8B,6BAAI;AAC5C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB,6BAAI,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEkL;;;;;ACjjE9F;AAC1C;AACoK;AACjJ;AAC2C;AACrC;AAC1B;;AAEzC,0BAA0B,+CAAmB,GAAG,iBAAiB,SAAS,gCAAgC;AAC1G,qCAAqC,8BAAQ;AAC7C,gCAAgC,MAAM;AACtC;AACA,qBAAqB,oCAAY;AACjC;AACA,sCAAsC,mDAAmD;AACzF,SAAS;AACT;AACA,qBAAqB,sCAAc;AACnC;AACA,SAAS;AACT,qBAAqB,wCAAgB;AACrC;AACA,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mCAAW;AAC7C,oBAAoB,sCAAU,+BAA+B,MAAM;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,CAAC;AACD;AACA,eAAe,gCAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,oDAAoD,GAAG,EAAE,SAAS,EAAE,WAAW,EAAE,KAAK;AACtF;AACA,yBAAyB,oCAAY;AACrC,2CAA2C,mDAAmD;AAC9F,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2CAAmB;AAC3C,iCAAiC,2CAAmB;AACpD,uEAAuE,oCAAY;AACnF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,OAAO;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,KAAK;AAC9B;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,IAAI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+FAA+F;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kCAAU;AACxC;AACA,cAAc,yBAAW;AACzB;AACA,sBAAsB,MAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,iBAAiB;AACxD,eAAe,sCAAU,WAAW,MAAM;AAC1C;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8BAA8B;AAC/D;AACA;AACA;AACA;AACA,yBAAyB,OAAO,yBAAe;AAC/C;AACA,mBAAmB;AACnB;AACA,yBAAyB,OAAO,yBAAe;AAC/C,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qDAAqD;AACpG,sBAAsB,2CAA2C;AACjE,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA,+CAA+C,yBAAW;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAiD;AACxE,iBAAiB,OAAO,yBAAe;AACvC,KAAK;AACL;AACA;AACA,qCAAqC,0CAA0C;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD,2CAA2C,yBAAW;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD,eAAe,sCAAU;AACzB;AACA,gCAAgC,MAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO,yBAAe;AACnD,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yBAAW,2BAA2B,yBAAW;AAClG;AACA;AACA,iCAAiC,OAAO,yBAAe;AACvD,uCAAuC;AACvC;AACA;AACA;AACA,iCAAiC,OAAO,yBAAe,2BAA2B;AAClF;AACA;AACA;AACA,wBAAwB;AACxB,KAAK;AACL;AACA;AACA,qCAAqC,2CAA2C;AAChF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,gDAAgD;AACtD,MAAM;AACN;AACA,iCAAiC,uBAAI,GAAG,yBAAyB;AACjE;AACA;AACA;AACA,6BAA6B;AAC7B,UAAU,8DAA8D,SAAS,+EAA+E;AAChK,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA,uCAAuC,uCAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS,GAAG,yDAAyD;AACzF;AACA,qBAAqB,cAAI,MAAM,qBAAM;AACrC;AACA;AACA,oCAAoC,iCAAiC;AACrE,eAAe,uCAAe;AAC9B;AACA;AACA,UAAU,aAAa;AACvB;AACA;AACA,eAAe,sCAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uCAAoB,KAAK,8BAAiB,CAAC,qBAAW,UAAU,yBAAyB;AAC1G;AACA;;AAE6H&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lezer/markdown/dist/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/lang-markdown/dist/index.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { NodeType, NodeProp, NodeSet, Tree, Parser, parseMixed } from '@lezer/common';</span><span class="s3">\n</span><span class="s1">import { styleTags, tags, Tag } from '@lezer/highlight';</span><span class="s3">\n\n</span><span class="s1">class CompositeBlock {</span><span class="s3">\n    </span><span class="s1">static create(type, value, from, parentHash, end) {</span><span class="s3">\n        </span><span class="s1">let hash = (parentHash + (parentHash &lt;&lt; 8) + type + (value &lt;&lt; 4)) | 0;</span><span class="s3">\n        </span><span class="s1">return new CompositeBlock(type, value, from, hash, end, [], []);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">constructor(type, </span><span class="s3">\n    </span><span class="s1">// Used for indentation in list items, markup character in lists</span><span class="s3">\n    </span><span class="s1">value, from, hash, end, children, positions) {</span><span class="s3">\n        </span><span class="s1">this.type = type;</span><span class="s3">\n        </span><span class="s1">this.value = value;</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.hash = hash;</span><span class="s3">\n        </span><span class="s1">this.end = end;</span><span class="s3">\n        </span><span class="s1">this.children = children;</span><span class="s3">\n        </span><span class="s1">this.positions = positions;</span><span class="s3">\n        </span><span class="s1">this.hashProp = [[NodeProp.contextHash, hash]];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addChild(child, pos) {</span><span class="s3">\n        </span><span class="s1">if (child.prop(NodeProp.contextHash) != this.hash)</span><span class="s3">\n            </span><span class="s1">child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);</span><span class="s3">\n        </span><span class="s1">this.children.push(child);</span><span class="s3">\n        </span><span class="s1">this.positions.push(pos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toTree(nodeSet, end = this.end) {</span><span class="s3">\n        </span><span class="s1">let last = this.children.length - 1;</span><span class="s3">\n        </span><span class="s1">if (last &gt;= 0)</span><span class="s3">\n            </span><span class="s1">end = Math.max(end, this.positions[last] + this.children[last].length + this.from);</span><span class="s3">\n        </span><span class="s1">return new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({</span><span class="s3">\n            </span><span class="s1">makeTree: (children, positions, length) =&gt; new Tree(NodeType.none, children, positions, length, this.hashProp)</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var Type;</span><span class="s3">\n</span><span class="s1">(function (Type) {</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">Document</span><span class="s3">\&quot;</span><span class="s1">] = 1] = </span><span class="s3">\&quot;</span><span class="s1">Document</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">CodeBlock</span><span class="s3">\&quot;</span><span class="s1">] = 2] = </span><span class="s3">\&quot;</span><span class="s1">CodeBlock</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">FencedCode</span><span class="s3">\&quot;</span><span class="s1">] = 3] = </span><span class="s3">\&quot;</span><span class="s1">FencedCode</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">Blockquote</span><span class="s3">\&quot;</span><span class="s1">] = 4] = </span><span class="s3">\&quot;</span><span class="s1">Blockquote</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">HorizontalRule</span><span class="s3">\&quot;</span><span class="s1">] = 5] = </span><span class="s3">\&quot;</span><span class="s1">HorizontalRule</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">BulletList</span><span class="s3">\&quot;</span><span class="s1">] = 6] = </span><span class="s3">\&quot;</span><span class="s1">BulletList</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">OrderedList</span><span class="s3">\&quot;</span><span class="s1">] = 7] = </span><span class="s3">\&quot;</span><span class="s1">OrderedList</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">ListItem</span><span class="s3">\&quot;</span><span class="s1">] = 8] = </span><span class="s3">\&quot;</span><span class="s1">ListItem</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">ATXHeading1</span><span class="s3">\&quot;</span><span class="s1">] = 9] = </span><span class="s3">\&quot;</span><span class="s1">ATXHeading1</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">ATXHeading2</span><span class="s3">\&quot;</span><span class="s1">] = 10] = </span><span class="s3">\&quot;</span><span class="s1">ATXHeading2</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">ATXHeading3</span><span class="s3">\&quot;</span><span class="s1">] = 11] = </span><span class="s3">\&quot;</span><span class="s1">ATXHeading3</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">ATXHeading4</span><span class="s3">\&quot;</span><span class="s1">] = 12] = </span><span class="s3">\&quot;</span><span class="s1">ATXHeading4</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">ATXHeading5</span><span class="s3">\&quot;</span><span class="s1">] = 13] = </span><span class="s3">\&quot;</span><span class="s1">ATXHeading5</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">ATXHeading6</span><span class="s3">\&quot;</span><span class="s1">] = 14] = </span><span class="s3">\&quot;</span><span class="s1">ATXHeading6</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">SetextHeading1</span><span class="s3">\&quot;</span><span class="s1">] = 15] = </span><span class="s3">\&quot;</span><span class="s1">SetextHeading1</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">SetextHeading2</span><span class="s3">\&quot;</span><span class="s1">] = 16] = </span><span class="s3">\&quot;</span><span class="s1">SetextHeading2</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">HTMLBlock</span><span class="s3">\&quot;</span><span class="s1">] = 17] = </span><span class="s3">\&quot;</span><span class="s1">HTMLBlock</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">LinkReference</span><span class="s3">\&quot;</span><span class="s1">] = 18] = </span><span class="s3">\&quot;</span><span class="s1">LinkReference</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">Paragraph</span><span class="s3">\&quot;</span><span class="s1">] = 19] = </span><span class="s3">\&quot;</span><span class="s1">Paragraph</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">CommentBlock</span><span class="s3">\&quot;</span><span class="s1">] = 20] = </span><span class="s3">\&quot;</span><span class="s1">CommentBlock</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">ProcessingInstructionBlock</span><span class="s3">\&quot;</span><span class="s1">] = 21] = </span><span class="s3">\&quot;</span><span class="s1">ProcessingInstructionBlock</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">// Inline</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">Escape</span><span class="s3">\&quot;</span><span class="s1">] = 22] = </span><span class="s3">\&quot;</span><span class="s1">Escape</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">Entity</span><span class="s3">\&quot;</span><span class="s1">] = 23] = </span><span class="s3">\&quot;</span><span class="s1">Entity</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">HardBreak</span><span class="s3">\&quot;</span><span class="s1">] = 24] = </span><span class="s3">\&quot;</span><span class="s1">HardBreak</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">Emphasis</span><span class="s3">\&quot;</span><span class="s1">] = 25] = </span><span class="s3">\&quot;</span><span class="s1">Emphasis</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">StrongEmphasis</span><span class="s3">\&quot;</span><span class="s1">] = 26] = </span><span class="s3">\&quot;</span><span class="s1">StrongEmphasis</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">Link</span><span class="s3">\&quot;</span><span class="s1">] = 27] = </span><span class="s3">\&quot;</span><span class="s1">Link</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">Image</span><span class="s3">\&quot;</span><span class="s1">] = 28] = </span><span class="s3">\&quot;</span><span class="s1">Image</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">InlineCode</span><span class="s3">\&quot;</span><span class="s1">] = 29] = </span><span class="s3">\&quot;</span><span class="s1">InlineCode</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">HTMLTag</span><span class="s3">\&quot;</span><span class="s1">] = 30] = </span><span class="s3">\&quot;</span><span class="s1">HTMLTag</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">Comment</span><span class="s3">\&quot;</span><span class="s1">] = 31] = </span><span class="s3">\&quot;</span><span class="s1">Comment</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">ProcessingInstruction</span><span class="s3">\&quot;</span><span class="s1">] = 32] = </span><span class="s3">\&quot;</span><span class="s1">ProcessingInstruction</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">Autolink</span><span class="s3">\&quot;</span><span class="s1">] = 33] = </span><span class="s3">\&quot;</span><span class="s1">Autolink</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">// Smaller tokens</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">HeaderMark</span><span class="s3">\&quot;</span><span class="s1">] = 34] = </span><span class="s3">\&quot;</span><span class="s1">HeaderMark</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">QuoteMark</span><span class="s3">\&quot;</span><span class="s1">] = 35] = </span><span class="s3">\&quot;</span><span class="s1">QuoteMark</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">ListMark</span><span class="s3">\&quot;</span><span class="s1">] = 36] = </span><span class="s3">\&quot;</span><span class="s1">ListMark</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">LinkMark</span><span class="s3">\&quot;</span><span class="s1">] = 37] = </span><span class="s3">\&quot;</span><span class="s1">LinkMark</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">EmphasisMark</span><span class="s3">\&quot;</span><span class="s1">] = 38] = </span><span class="s3">\&quot;</span><span class="s1">EmphasisMark</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">CodeMark</span><span class="s3">\&quot;</span><span class="s1">] = 39] = </span><span class="s3">\&quot;</span><span class="s1">CodeMark</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">CodeText</span><span class="s3">\&quot;</span><span class="s1">] = 40] = </span><span class="s3">\&quot;</span><span class="s1">CodeText</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">CodeInfo</span><span class="s3">\&quot;</span><span class="s1">] = 41] = </span><span class="s3">\&quot;</span><span class="s1">CodeInfo</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">LinkTitle</span><span class="s3">\&quot;</span><span class="s1">] = 42] = </span><span class="s3">\&quot;</span><span class="s1">LinkTitle</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">LinkLabel</span><span class="s3">\&quot;</span><span class="s1">] = 43] = </span><span class="s3">\&quot;</span><span class="s1">LinkLabel</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">Type[Type[</span><span class="s3">\&quot;</span><span class="s1">URL</span><span class="s3">\&quot;</span><span class="s1">] = 44] = </span><span class="s3">\&quot;</span><span class="s1">URL</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">})(Type || (Type = {}));</span><span class="s3">\n</span><span class="s1">/// Data structure used to accumulate a block's content during [leaf</span><span class="s3">\n</span><span class="s1">/// block parsing](#BlockParser.leaf).</span><span class="s3">\n</span><span class="s1">class LeafBlock {</span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/// The start position of the block.</span><span class="s3">\n    </span><span class="s1">start, </span><span class="s3">\n    </span><span class="s1">/// The block's text content.</span><span class="s3">\n    </span><span class="s1">content) {</span><span class="s3">\n        </span><span class="s1">this.start = start;</span><span class="s3">\n        </span><span class="s1">this.content = content;</span><span class="s3">\n        </span><span class="s1">/// @internal</span><span class="s3">\n        </span><span class="s1">this.marks = [];</span><span class="s3">\n        </span><span class="s1">/// The block parsers active for this block.</span><span class="s3">\n        </span><span class="s1">this.parsers = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/// Data structure used during block-level per-line parsing.</span><span class="s3">\n</span><span class="s1">class Line {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">/// The line's full text.</span><span class="s3">\n        </span><span class="s1">this.text = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">/// The base indent provided by the composite contexts (that have</span><span class="s3">\n        </span><span class="s1">/// been handled so far).</span><span class="s3">\n        </span><span class="s1">this.baseIndent = 0;</span><span class="s3">\n        </span><span class="s1">/// The string position corresponding to the base indent.</span><span class="s3">\n        </span><span class="s1">this.basePos = 0;</span><span class="s3">\n        </span><span class="s1">/// The number of contexts handled @internal</span><span class="s3">\n        </span><span class="s1">this.depth = 0;</span><span class="s3">\n        </span><span class="s1">/// Any markers (i.e. block quote markers) parsed for the contexts. @internal</span><span class="s3">\n        </span><span class="s1">this.markers = [];</span><span class="s3">\n        </span><span class="s1">/// The position of the next non-whitespace character beyond any</span><span class="s3">\n        </span><span class="s1">/// list, blockquote, or other composite block markers.</span><span class="s3">\n        </span><span class="s1">this.pos = 0;</span><span class="s3">\n        </span><span class="s1">/// The column of the next non-whitespace character.</span><span class="s3">\n        </span><span class="s1">this.indent = 0;</span><span class="s3">\n        </span><span class="s1">/// The character code of the character after `pos`.</span><span class="s3">\n        </span><span class="s1">this.next = -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">forward() {</span><span class="s3">\n        </span><span class="s1">if (this.basePos &gt; this.pos)</span><span class="s3">\n            </span><span class="s1">this.forwardInner();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">forwardInner() {</span><span class="s3">\n        </span><span class="s1">let newPos = this.skipSpace(this.basePos);</span><span class="s3">\n        </span><span class="s1">this.indent = this.countIndent(newPos, this.pos, this.indent);</span><span class="s3">\n        </span><span class="s1">this.pos = newPos;</span><span class="s3">\n        </span><span class="s1">this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Skip whitespace after the given position, return the position of</span><span class="s3">\n    </span><span class="s1">/// the next non-space character or the end of the line if there's</span><span class="s3">\n    </span><span class="s1">/// only space after `from`.</span><span class="s3">\n    </span><span class="s1">skipSpace(from) { return skipSpace(this.text, from); }</span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">reset(text) {</span><span class="s3">\n        </span><span class="s1">this.text = text;</span><span class="s3">\n        </span><span class="s1">this.baseIndent = this.basePos = this.pos = this.indent = 0;</span><span class="s3">\n        </span><span class="s1">this.forwardInner();</span><span class="s3">\n        </span><span class="s1">this.depth = 1;</span><span class="s3">\n        </span><span class="s1">while (this.markers.length)</span><span class="s3">\n            </span><span class="s1">this.markers.pop();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Move the line's base position forward to the given position.</span><span class="s3">\n    </span><span class="s1">/// This should only be called by composite [block</span><span class="s3">\n    </span><span class="s1">/// parsers](#BlockParser.parse) or [markup skipping</span><span class="s3">\n    </span><span class="s1">/// functions](#NodeSpec.composite).</span><span class="s3">\n    </span><span class="s1">moveBase(to) {</span><span class="s3">\n        </span><span class="s1">this.basePos = to;</span><span class="s3">\n        </span><span class="s1">this.baseIndent = this.countIndent(to, this.pos, this.indent);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Move the line's base position forward to the given _column_.</span><span class="s3">\n    </span><span class="s1">moveBaseColumn(indent) {</span><span class="s3">\n        </span><span class="s1">this.baseIndent = indent;</span><span class="s3">\n        </span><span class="s1">this.basePos = this.findColumn(indent);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Store a composite-block-level marker. Should be called from</span><span class="s3">\n    </span><span class="s1">/// [markup skipping functions](#NodeSpec.composite) when they</span><span class="s3">\n    </span><span class="s1">/// consume any non-whitespace characters.</span><span class="s3">\n    </span><span class="s1">addMarker(elt) {</span><span class="s3">\n        </span><span class="s1">this.markers.push(elt);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Find the column position at `to`, optionally starting at a given</span><span class="s3">\n    </span><span class="s1">/// position and column.</span><span class="s3">\n    </span><span class="s1">countIndent(to, from = 0, indent = 0) {</span><span class="s3">\n        </span><span class="s1">for (let i = from; i &lt; to; i++)</span><span class="s3">\n            </span><span class="s1">indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;</span><span class="s3">\n        </span><span class="s1">return indent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Find the position corresponding to the given column.</span><span class="s3">\n    </span><span class="s1">findColumn(goal) {</span><span class="s3">\n        </span><span class="s1">let i = 0;</span><span class="s3">\n        </span><span class="s1">for (let indent = 0; i &lt; this.text.length &amp;&amp; indent &lt; goal; i++)</span><span class="s3">\n            </span><span class="s1">indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;</span><span class="s3">\n        </span><span class="s1">return i;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">scrub() {</span><span class="s3">\n        </span><span class="s1">if (!this.baseIndent)</span><span class="s3">\n            </span><span class="s1">return this.text;</span><span class="s3">\n        </span><span class="s1">let result = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.basePos; i++)</span><span class="s3">\n            </span><span class="s1">result += </span><span class="s3">\&quot; \&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">return result + this.text.slice(this.basePos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function skipForList(bl, cx, line) {</span><span class="s3">\n    </span><span class="s1">if (line.pos == line.text.length ||</span><span class="s3">\n        </span><span class="s1">(bl != cx.block &amp;&amp; line.indent &gt;= cx.stack[line.depth + 1].value + line.baseIndent))</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">if (line.indent &gt;= line.baseIndent + 4)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);</span><span class="s3">\n    </span><span class="s1">return size &gt; 0 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(bl.type != Type.BulletList || isHorizontalRule(line, cx, false) &lt; 0) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">line.text.charCodeAt(line.pos + size - 1) == bl.value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const DefaultSkipMarkup = {</span><span class="s3">\n    </span><span class="s1">[Type.Blockquote](bl, cx, line) {</span><span class="s3">\n        </span><span class="s1">if (line.next != 62 /* '&gt;' */)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));</span><span class="s3">\n        </span><span class="s1">line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));</span><span class="s3">\n        </span><span class="s1">bl.end = cx.lineStart + line.text.length;</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">[Type.ListItem](bl, _cx, line) {</span><span class="s3">\n        </span><span class="s1">if (line.indent &lt; line.baseIndent + bl.value &amp;&amp; line.next &gt; -1)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">line.moveBaseColumn(line.baseIndent + bl.value);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">[Type.OrderedList]: skipForList,</span><span class="s3">\n    </span><span class="s1">[Type.BulletList]: skipForList,</span><span class="s3">\n    </span><span class="s1">[Type.Document]() { return true; }</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function space(ch) { return ch == 32 || ch == 9 || ch == 10 || ch == 13; }</span><span class="s3">\n</span><span class="s1">function skipSpace(line, i = 0) {</span><span class="s3">\n    </span><span class="s1">while (i &lt; line.length &amp;&amp; space(line.charCodeAt(i)))</span><span class="s3">\n        </span><span class="s1">i++;</span><span class="s3">\n    </span><span class="s1">return i;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function skipSpaceBack(line, i, to) {</span><span class="s3">\n    </span><span class="s1">while (i &gt; to &amp;&amp; space(line.charCodeAt(i - 1)))</span><span class="s3">\n        </span><span class="s1">i--;</span><span class="s3">\n    </span><span class="s1">return i;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isFencedCode(line) {</span><span class="s3">\n    </span><span class="s1">if (line.next != 96 &amp;&amp; line.next != 126 /* '`~' */)</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">let pos = line.pos + 1;</span><span class="s3">\n    </span><span class="s1">while (pos &lt; line.text.length &amp;&amp; line.text.charCodeAt(pos) == line.next)</span><span class="s3">\n        </span><span class="s1">pos++;</span><span class="s3">\n    </span><span class="s1">if (pos &lt; line.pos + 3)</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">if (line.next == 96)</span><span class="s3">\n        </span><span class="s1">for (let i = pos; i &lt; line.text.length; i++)</span><span class="s3">\n            </span><span class="s1">if (line.text.charCodeAt(i) == 96)</span><span class="s3">\n                </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">return pos;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isBlockquote(line) {</span><span class="s3">\n    </span><span class="s1">return line.next != 62 /* '&gt;' */ ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isHorizontalRule(line, cx, breaking) {</span><span class="s3">\n    </span><span class="s1">if (line.next != 42 &amp;&amp; line.next != 45 &amp;&amp; line.next != 95 /* '_-*' */)</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">let count = 1;</span><span class="s3">\n    </span><span class="s1">for (let pos = line.pos + 1; pos &lt; line.text.length; pos++) {</span><span class="s3">\n        </span><span class="s1">let ch = line.text.charCodeAt(pos);</span><span class="s3">\n        </span><span class="s1">if (ch == line.next)</span><span class="s3">\n            </span><span class="s1">count++;</span><span class="s3">\n        </span><span class="s1">else if (!space(ch))</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Setext headers take precedence</span><span class="s3">\n    </span><span class="s1">if (breaking &amp;&amp; line.next == 45 &amp;&amp; isSetextUnderline(line) &gt; -1 &amp;&amp; line.depth == cx.stack.length)</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">return count &lt; 3 ? -1 : 1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function inList(cx, type) {</span><span class="s3">\n    </span><span class="s1">for (let i = cx.stack.length - 1; i &gt;= 0; i--)</span><span class="s3">\n        </span><span class="s1">if (cx.stack[i].type == type)</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isBulletList(line, cx, breaking) {</span><span class="s3">\n    </span><span class="s1">return (line.next == 45 || line.next == 43 || line.next == 42 /* '-+*' */) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) &lt; line.text.length) ? 1 : -1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isOrderedList(line, cx, breaking) {</span><span class="s3">\n    </span><span class="s1">let pos = line.pos, next = line.next;</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">if (next &gt;= 48 &amp;&amp; next &lt;= 57 /* '0-9' */)</span><span class="s3">\n            </span><span class="s1">pos++;</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">if (pos == line.text.length)</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">next = line.text.charCodeAt(pos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (pos == line.pos || pos &gt; line.pos + 9 ||</span><span class="s3">\n        </span><span class="s1">(next != 46 &amp;&amp; next != 41 /* '.)' */) ||</span><span class="s3">\n        </span><span class="s1">(pos &lt; line.text.length - 1 &amp;&amp; !space(line.text.charCodeAt(pos + 1))) ||</span><span class="s3">\n        </span><span class="s1">breaking &amp;&amp; !inList(cx, Type.OrderedList) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(line.skipSpace(pos + 1) == line.text.length || pos &gt; line.pos + 1 || line.next != 49 /* '1' */))</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">return pos + 1 - line.pos;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isAtxHeading(line) {</span><span class="s3">\n    </span><span class="s1">if (line.next != 35 /* '#' */)</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">let pos = line.pos + 1;</span><span class="s3">\n    </span><span class="s1">while (pos &lt; line.text.length &amp;&amp; line.text.charCodeAt(pos) == 35)</span><span class="s3">\n        </span><span class="s1">pos++;</span><span class="s3">\n    </span><span class="s1">if (pos &lt; line.text.length &amp;&amp; line.text.charCodeAt(pos) != 32)</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">let size = pos - line.pos;</span><span class="s3">\n    </span><span class="s1">return size &gt; 6 ? -1 : size;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isSetextUnderline(line) {</span><span class="s3">\n    </span><span class="s1">if (line.next != 45 &amp;&amp; line.next != 61 /* '-=' */ || line.indent &gt;= line.baseIndent + 4)</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">let pos = line.pos + 1;</span><span class="s3">\n    </span><span class="s1">while (pos &lt; line.text.length &amp;&amp; line.text.charCodeAt(pos) == line.next)</span><span class="s3">\n        </span><span class="s1">pos++;</span><span class="s3">\n    </span><span class="s1">let end = pos;</span><span class="s3">\n    </span><span class="s1">while (pos &lt; line.text.length &amp;&amp; space(line.text.charCodeAt(pos)))</span><span class="s3">\n        </span><span class="s1">pos++;</span><span class="s3">\n    </span><span class="s1">return pos == line.text.length ? end : -1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const EmptyLine = /^[ </span><span class="s3">\\</span><span class="s1">t]*$/, CommentEnd = /--&gt;/, ProcessingEnd = /</span><span class="s3">\\</span><span class="s1">?&gt;/;</span><span class="s3">\n</span><span class="s1">const HTMLBlockStyle = [</span><span class="s3">\n    </span><span class="s1">[/^&lt;(?:script|pre|style)(?:</span><span class="s3">\\</span><span class="s1">s|&gt;|$)/i, /&lt;</span><span class="s3">\\</span><span class="s1">/(?:script|pre|style)&gt;/i],</span><span class="s3">\n    </span><span class="s1">[/^</span><span class="s3">\\</span><span class="s1">s*&lt;!--/, CommentEnd],</span><span class="s3">\n    </span><span class="s1">[/^</span><span class="s3">\\</span><span class="s1">s*&lt;</span><span class="s3">\\</span><span class="s1">?/, ProcessingEnd],</span><span class="s3">\n    </span><span class="s1">[/^</span><span class="s3">\\</span><span class="s1">s*&lt;![A-Z]/, /&gt;/],</span><span class="s3">\n    </span><span class="s1">[/^</span><span class="s3">\\</span><span class="s1">s*&lt;!</span><span class="s3">\\</span><span class="s1">[CDATA</span><span class="s3">\\</span><span class="s1">[/, /</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">]&gt;/],</span><span class="s3">\n    </span><span class="s1">[/^</span><span class="s3">\\</span><span class="s1">s*&lt;</span><span class="s3">\\</span><span class="s1">/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:</span><span class="s3">\\</span><span class="s1">s|</span><span class="s3">\\</span><span class="s1">/?&gt;|$)/i, EmptyLine],</span><span class="s3">\n    </span><span class="s1">[/^</span><span class="s3">\\</span><span class="s1">s*(?:&lt;</span><span class="s3">\\</span><span class="s1">/[a-z][</span><span class="s3">\\</span><span class="s1">w-]*</span><span class="s3">\\</span><span class="s1">s*&gt;|&lt;[a-z][</span><span class="s3">\\</span><span class="s1">w-]*(</span><span class="s3">\\</span><span class="s1">s+[a-z:_][</span><span class="s3">\\</span><span class="s1">w-.]*(?:</span><span class="s3">\\</span><span class="s1">s*=</span><span class="s3">\\</span><span class="s1">s*(?:[^</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\&quot;</span><span class="s1">'=&lt;&gt;`]+|'[^']*'|</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\&quot;</span><span class="s1">]*</span><span class="s3">\&quot;</span><span class="s1">))?)*</span><span class="s3">\\</span><span class="s1">s*&gt;)</span><span class="s3">\\</span><span class="s1">s*$/i, EmptyLine]</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">function isHTMLBlock(line, _cx, breaking) {</span><span class="s3">\n    </span><span class="s1">if (line.next != 60 /* '&lt;' */)</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">let rest = line.text.slice(line.pos);</span><span class="s3">\n    </span><span class="s1">for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i &lt; e; i++)</span><span class="s3">\n        </span><span class="s1">if (HTMLBlockStyle[i][0].test(rest))</span><span class="s3">\n            </span><span class="s1">return i;</span><span class="s3">\n    </span><span class="s1">return -1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getListIndent(line, pos) {</span><span class="s3">\n    </span><span class="s1">let indentAfter = line.countIndent(pos, line.pos, line.indent);</span><span class="s3">\n    </span><span class="s1">let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);</span><span class="s3">\n    </span><span class="s1">return indented &gt;= indentAfter + 5 ? indentAfter + 1 : indented;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addCodeText(marks, from, to) {</span><span class="s3">\n    </span><span class="s1">let last = marks.length - 1;</span><span class="s3">\n    </span><span class="s1">if (last &gt;= 0 &amp;&amp; marks[last].to == from &amp;&amp; marks[last].type == Type.CodeText)</span><span class="s3">\n        </span><span class="s1">marks[last].to = to;</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">marks.push(elt(Type.CodeText, from, to));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Rules for parsing blocks. A return value of false means the rule</span><span class="s3">\n</span><span class="s1">// doesn't apply here, true means it does. When true is returned and</span><span class="s3">\n</span><span class="s1">// `p.line` has been updated, the rule is assumed to have consumed a</span><span class="s3">\n</span><span class="s1">// leaf block. Otherwise, it is assumed to have opened a context.</span><span class="s3">\n</span><span class="s1">const DefaultBlockParsers = {</span><span class="s3">\n    </span><span class="s1">LinkReference: undefined,</span><span class="s3">\n    </span><span class="s1">IndentedCode(cx, line) {</span><span class="s3">\n        </span><span class="s1">let base = line.baseIndent + 4;</span><span class="s3">\n        </span><span class="s1">if (line.indent &lt; base)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">let start = line.findColumn(base);</span><span class="s3">\n        </span><span class="s1">let from = cx.lineStart + start, to = cx.lineStart + line.text.length;</span><span class="s3">\n        </span><span class="s1">let marks = [], pendingMarks = [];</span><span class="s3">\n        </span><span class="s1">addCodeText(marks, from, to);</span><span class="s3">\n        </span><span class="s1">while (cx.nextLine() &amp;&amp; line.depth &gt;= cx.stack.length) {</span><span class="s3">\n            </span><span class="s1">if (line.pos == line.text.length) { // Empty</span><span class="s3">\n                </span><span class="s1">addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);</span><span class="s3">\n                </span><span class="s1">for (let m of line.markers)</span><span class="s3">\n                    </span><span class="s1">pendingMarks.push(m);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (line.indent &lt; base) {</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">if (pendingMarks.length) {</span><span class="s3">\n                    </span><span class="s1">for (let m of pendingMarks) {</span><span class="s3">\n                        </span><span class="s1">if (m.type == Type.CodeText)</span><span class="s3">\n                            </span><span class="s1">addCodeText(marks, m.from, m.to);</span><span class="s3">\n                        </span><span class="s1">else</span><span class="s3">\n                            </span><span class="s1">marks.push(m);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">pendingMarks = [];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">addCodeText(marks, cx.lineStart - 1, cx.lineStart);</span><span class="s3">\n                </span><span class="s1">for (let m of line.markers)</span><span class="s3">\n                    </span><span class="s1">marks.push(m);</span><span class="s3">\n                </span><span class="s1">to = cx.lineStart + line.text.length;</span><span class="s3">\n                </span><span class="s1">let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);</span><span class="s3">\n                </span><span class="s1">if (codeStart &lt; to)</span><span class="s3">\n                    </span><span class="s1">addCodeText(marks, codeStart, to);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (pendingMarks.length) {</span><span class="s3">\n            </span><span class="s1">pendingMarks = pendingMarks.filter(m =&gt; m.type != Type.CodeText);</span><span class="s3">\n            </span><span class="s1">if (pendingMarks.length)</span><span class="s3">\n                </span><span class="s1">line.markers = pendingMarks.concat(line.markers);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">FencedCode(cx, line) {</span><span class="s3">\n        </span><span class="s1">let fenceEnd = isFencedCode(line);</span><span class="s3">\n        </span><span class="s1">if (fenceEnd &lt; 0)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;</span><span class="s3">\n        </span><span class="s1">let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);</span><span class="s3">\n        </span><span class="s1">let marks = [elt(Type.CodeMark, from, from + len)];</span><span class="s3">\n        </span><span class="s1">if (infoFrom &lt; infoTo)</span><span class="s3">\n            </span><span class="s1">marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));</span><span class="s3">\n        </span><span class="s1">for (let first = true; cx.nextLine() &amp;&amp; line.depth &gt;= cx.stack.length; first = false) {</span><span class="s3">\n            </span><span class="s1">let i = line.pos;</span><span class="s3">\n            </span><span class="s1">if (line.indent - line.baseIndent &lt; 4)</span><span class="s3">\n                </span><span class="s1">while (i &lt; line.text.length &amp;&amp; line.text.charCodeAt(i) == ch)</span><span class="s3">\n                    </span><span class="s1">i++;</span><span class="s3">\n            </span><span class="s1">if (i - line.pos &gt;= len &amp;&amp; line.skipSpace(i) == line.text.length) {</span><span class="s3">\n                </span><span class="s1">for (let m of line.markers)</span><span class="s3">\n                    </span><span class="s1">marks.push(m);</span><span class="s3">\n                </span><span class="s1">marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));</span><span class="s3">\n                </span><span class="s1">cx.nextLine();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">if (!first)</span><span class="s3">\n                    </span><span class="s1">addCodeText(marks, cx.lineStart - 1, cx.lineStart);</span><span class="s3">\n                </span><span class="s1">for (let m of line.markers)</span><span class="s3">\n                    </span><span class="s1">marks.push(m);</span><span class="s3">\n                </span><span class="s1">let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;</span><span class="s3">\n                </span><span class="s1">if (textStart &lt; textEnd)</span><span class="s3">\n                    </span><span class="s1">addCodeText(marks, textStart, textEnd);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">cx.addNode(cx.buffer.writeElements(marks, -from)</span><span class="s3">\n            </span><span class="s1">.finish(Type.FencedCode, cx.prevLineEnd() - from), from);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">Blockquote(cx, line) {</span><span class="s3">\n        </span><span class="s1">let size = isBlockquote(line);</span><span class="s3">\n        </span><span class="s1">if (size &lt; 0)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">cx.startContext(Type.Blockquote, line.pos);</span><span class="s3">\n        </span><span class="s1">cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);</span><span class="s3">\n        </span><span class="s1">line.moveBase(line.pos + size);</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">HorizontalRule(cx, line) {</span><span class="s3">\n        </span><span class="s1">if (isHorizontalRule(line, cx, false) &lt; 0)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">let from = cx.lineStart + line.pos;</span><span class="s3">\n        </span><span class="s1">cx.nextLine();</span><span class="s3">\n        </span><span class="s1">cx.addNode(Type.HorizontalRule, from);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">BulletList(cx, line) {</span><span class="s3">\n        </span><span class="s1">let size = isBulletList(line, cx, false);</span><span class="s3">\n        </span><span class="s1">if (size &lt; 0)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">if (cx.block.type != Type.BulletList)</span><span class="s3">\n            </span><span class="s1">cx.startContext(Type.BulletList, line.basePos, line.next);</span><span class="s3">\n        </span><span class="s1">let newBase = getListIndent(line, line.pos + 1);</span><span class="s3">\n        </span><span class="s1">cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);</span><span class="s3">\n        </span><span class="s1">cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);</span><span class="s3">\n        </span><span class="s1">line.moveBaseColumn(newBase);</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">OrderedList(cx, line) {</span><span class="s3">\n        </span><span class="s1">let size = isOrderedList(line, cx, false);</span><span class="s3">\n        </span><span class="s1">if (size &lt; 0)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">if (cx.block.type != Type.OrderedList)</span><span class="s3">\n            </span><span class="s1">cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));</span><span class="s3">\n        </span><span class="s1">let newBase = getListIndent(line, line.pos + size);</span><span class="s3">\n        </span><span class="s1">cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);</span><span class="s3">\n        </span><span class="s1">cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);</span><span class="s3">\n        </span><span class="s1">line.moveBaseColumn(newBase);</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">ATXHeading(cx, line) {</span><span class="s3">\n        </span><span class="s1">let size = isAtxHeading(line);</span><span class="s3">\n        </span><span class="s1">if (size &lt; 0)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">let off = line.pos, from = cx.lineStart + off;</span><span class="s3">\n        </span><span class="s1">let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;</span><span class="s3">\n        </span><span class="s1">while (after &gt; off &amp;&amp; line.text.charCodeAt(after - 1) == line.next)</span><span class="s3">\n            </span><span class="s1">after--;</span><span class="s3">\n        </span><span class="s1">if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))</span><span class="s3">\n            </span><span class="s1">after = line.text.length;</span><span class="s3">\n        </span><span class="s1">let buf = cx.buffer</span><span class="s3">\n            </span><span class="s1">.write(Type.HeaderMark, 0, size)</span><span class="s3">\n            </span><span class="s1">.writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);</span><span class="s3">\n        </span><span class="s1">if (after &lt; line.text.length)</span><span class="s3">\n            </span><span class="s1">buf.write(Type.HeaderMark, after - off, endOfSpace - off);</span><span class="s3">\n        </span><span class="s1">let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);</span><span class="s3">\n        </span><span class="s1">cx.nextLine();</span><span class="s3">\n        </span><span class="s1">cx.addNode(node, from);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">HTMLBlock(cx, line) {</span><span class="s3">\n        </span><span class="s1">let type = isHTMLBlock(line, cx, false);</span><span class="s3">\n        </span><span class="s1">if (type &lt; 0)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];</span><span class="s3">\n        </span><span class="s1">let marks = [], trailing = end != EmptyLine;</span><span class="s3">\n        </span><span class="s1">while (!end.test(line.text) &amp;&amp; cx.nextLine()) {</span><span class="s3">\n            </span><span class="s1">if (line.depth &lt; cx.stack.length) {</span><span class="s3">\n                </span><span class="s1">trailing = false;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">for (let m of line.markers)</span><span class="s3">\n                </span><span class="s1">marks.push(m);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (trailing)</span><span class="s3">\n            </span><span class="s1">cx.nextLine();</span><span class="s3">\n        </span><span class="s1">let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;</span><span class="s3">\n        </span><span class="s1">let to = cx.prevLineEnd();</span><span class="s3">\n        </span><span class="s1">cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">SetextHeading: undefined // Specifies relative precedence for block-continue function</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">// This implements a state machine that incrementally parses link references. At each</span><span class="s3">\n</span><span class="s1">// next line, it looks ahead to see if the line continues the reference or not. If it</span><span class="s3">\n</span><span class="s1">// doesn't and a valid link is available ending before that line, it finishes that.</span><span class="s3">\n</span><span class="s1">// Similarly, on `finish` (when the leaf is terminated by external circumstances), it</span><span class="s3">\n</span><span class="s1">// creates a link reference if there's a valid reference up to the current point.</span><span class="s3">\n</span><span class="s1">class LinkReferenceParser {</span><span class="s3">\n    </span><span class="s1">constructor(leaf) {</span><span class="s3">\n        </span><span class="s1">this.stage = 0 /* RefStage.Start */;</span><span class="s3">\n        </span><span class="s1">this.elts = [];</span><span class="s3">\n        </span><span class="s1">this.pos = 0;</span><span class="s3">\n        </span><span class="s1">this.start = leaf.start;</span><span class="s3">\n        </span><span class="s1">this.advance(leaf.content);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nextLine(cx, line, leaf) {</span><span class="s3">\n        </span><span class="s1">if (this.stage == -1 /* RefStage.Failed */)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">let content = leaf.content + </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+ line.scrub();</span><span class="s3">\n        </span><span class="s1">let finish = this.advance(content);</span><span class="s3">\n        </span><span class="s1">if (finish &gt; -1 &amp;&amp; finish &lt; content.length)</span><span class="s3">\n            </span><span class="s1">return this.complete(cx, leaf, finish);</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">finish(cx, leaf) {</span><span class="s3">\n        </span><span class="s1">if ((this.stage == 2 /* RefStage.Link */ || this.stage == 3 /* RefStage.Title */) &amp;&amp; skipSpace(leaf.content, this.pos) == leaf.content.length)</span><span class="s3">\n            </span><span class="s1">return this.complete(cx, leaf, leaf.content.length);</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">complete(cx, leaf, len) {</span><span class="s3">\n        </span><span class="s1">cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nextStage(elt) {</span><span class="s3">\n        </span><span class="s1">if (elt) {</span><span class="s3">\n            </span><span class="s1">this.pos = elt.to - this.start;</span><span class="s3">\n            </span><span class="s1">this.elts.push(elt);</span><span class="s3">\n            </span><span class="s1">this.stage++;</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (elt === false)</span><span class="s3">\n            </span><span class="s1">this.stage = -1 /* RefStage.Failed */;</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">advance(content) {</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">if (this.stage == -1 /* RefStage.Failed */) {</span><span class="s3">\n                </span><span class="s1">return -1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (this.stage == 0 /* RefStage.Start */) {</span><span class="s3">\n                </span><span class="s1">if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))</span><span class="s3">\n                    </span><span class="s1">return -1;</span><span class="s3">\n                </span><span class="s1">if (content.charCodeAt(this.pos) != 58 /* ':' */)</span><span class="s3">\n                    </span><span class="s1">return this.stage = -1 /* RefStage.Failed */;</span><span class="s3">\n                </span><span class="s1">this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));</span><span class="s3">\n                </span><span class="s1">this.pos++;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (this.stage == 1 /* RefStage.Label */) {</span><span class="s3">\n                </span><span class="s1">if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))</span><span class="s3">\n                    </span><span class="s1">return -1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (this.stage == 2 /* RefStage.Link */) {</span><span class="s3">\n                </span><span class="s1">let skip = skipSpace(content, this.pos), end = 0;</span><span class="s3">\n                </span><span class="s1">if (skip &gt; this.pos) {</span><span class="s3">\n                    </span><span class="s1">let title = parseLinkTitle(content, skip, this.start);</span><span class="s3">\n                    </span><span class="s1">if (title) {</span><span class="s3">\n                        </span><span class="s1">let titleEnd = lineEnd(content, title.to - this.start);</span><span class="s3">\n                        </span><span class="s1">if (titleEnd &gt; 0) {</span><span class="s3">\n                            </span><span class="s1">this.nextStage(title);</span><span class="s3">\n                            </span><span class="s1">end = titleEnd;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (!end)</span><span class="s3">\n                    </span><span class="s1">end = lineEnd(content, this.pos);</span><span class="s3">\n                </span><span class="s1">return end &gt; 0 &amp;&amp; end &lt; content.length ? end : -1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else { // RefStage.Title</span><span class="s3">\n                </span><span class="s1">return lineEnd(content, this.pos);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function lineEnd(text, pos) {</span><span class="s3">\n    </span><span class="s1">for (; pos &lt; text.length; pos++) {</span><span class="s3">\n        </span><span class="s1">let next = text.charCodeAt(pos);</span><span class="s3">\n        </span><span class="s1">if (next == 10)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">if (!space(next))</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return pos;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class SetextHeadingParser {</span><span class="s3">\n    </span><span class="s1">nextLine(cx, line, leaf) {</span><span class="s3">\n        </span><span class="s1">let underline = line.depth &lt; cx.stack.length ? -1 : isSetextUnderline(line);</span><span class="s3">\n        </span><span class="s1">let next = line.next;</span><span class="s3">\n        </span><span class="s1">if (underline &lt; 0)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);</span><span class="s3">\n        </span><span class="s1">cx.nextLine();</span><span class="s3">\n        </span><span class="s1">cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [</span><span class="s3">\n            </span><span class="s1">...cx.parser.parseInline(leaf.content, leaf.start),</span><span class="s3">\n            </span><span class="s1">underlineMark</span><span class="s3">\n        </span><span class="s1">]));</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">finish() {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const DefaultLeafBlocks = {</span><span class="s3">\n    </span><span class="s1">LinkReference(_, leaf) { return leaf.content.charCodeAt(0) == 91 /* '[' */ ? new LinkReferenceParser(leaf) : null; },</span><span class="s3">\n    </span><span class="s1">SetextHeading() { return new SetextHeadingParser; }</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const DefaultEndLeaf = [</span><span class="s3">\n    </span><span class="s1">(_, line) =&gt; isAtxHeading(line) &gt;= 0,</span><span class="s3">\n    </span><span class="s1">(_, line) =&gt; isFencedCode(line) &gt;= 0,</span><span class="s3">\n    </span><span class="s1">(_, line) =&gt; isBlockquote(line) &gt;= 0,</span><span class="s3">\n    </span><span class="s1">(p, line) =&gt; isBulletList(line, p, true) &gt;= 0,</span><span class="s3">\n    </span><span class="s1">(p, line) =&gt; isOrderedList(line, p, true) &gt;= 0,</span><span class="s3">\n    </span><span class="s1">(p, line) =&gt; isHorizontalRule(line, p, true) &gt;= 0,</span><span class="s3">\n    </span><span class="s1">(p, line) =&gt; isHTMLBlock(line, p, true) &gt;= 0</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">const scanLineResult = { text: </span><span class="s3">\&quot;\&quot;</span><span class="s1">, end: 0 };</span><span class="s3">\n</span><span class="s1">/// Block-level parsing functions get access to this context object.</span><span class="s3">\n</span><span class="s1">class BlockContext {</span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/// The parser configuration used.</span><span class="s3">\n    </span><span class="s1">parser, </span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">input, fragments, </span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">ranges) {</span><span class="s3">\n        </span><span class="s1">this.parser = parser;</span><span class="s3">\n        </span><span class="s1">this.input = input;</span><span class="s3">\n        </span><span class="s1">this.ranges = ranges;</span><span class="s3">\n        </span><span class="s1">this.line = new Line();</span><span class="s3">\n        </span><span class="s1">this.atEnd = false;</span><span class="s3">\n        </span><span class="s1">/// For reused nodes on gaps, we can't directly put the original</span><span class="s3">\n        </span><span class="s1">/// node into the tree, since that may be bitter than its parent.</span><span class="s3">\n        </span><span class="s1">/// When this happens, we create a dummy tree that is replaced by</span><span class="s3">\n        </span><span class="s1">/// the proper node in `injectGaps` @internal</span><span class="s3">\n        </span><span class="s1">this.reusePlaceholders = new Map;</span><span class="s3">\n        </span><span class="s1">this.stoppedAt = null;</span><span class="s3">\n        </span><span class="s1">/// The range index that absoluteLineStart points into @internal</span><span class="s3">\n        </span><span class="s1">this.rangeI = 0;</span><span class="s3">\n        </span><span class="s1">this.to = ranges[ranges.length - 1].to;</span><span class="s3">\n        </span><span class="s1">this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;</span><span class="s3">\n        </span><span class="s1">this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);</span><span class="s3">\n        </span><span class="s1">this.stack = [this.block];</span><span class="s3">\n        </span><span class="s1">this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;</span><span class="s3">\n        </span><span class="s1">this.readLine();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get parsedPos() {</span><span class="s3">\n        </span><span class="s1">return this.absoluteLineStart;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">advance() {</span><span class="s3">\n        </span><span class="s1">if (this.stoppedAt != null &amp;&amp; this.absoluteLineStart &gt; this.stoppedAt)</span><span class="s3">\n            </span><span class="s1">return this.finish();</span><span class="s3">\n        </span><span class="s1">let { line } = this;</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">for (let markI = 0;;) {</span><span class="s3">\n                </span><span class="s1">let next = line.depth &lt; this.stack.length ? this.stack[this.stack.length - 1] : null;</span><span class="s3">\n                </span><span class="s1">while (markI &lt; line.markers.length &amp;&amp; (!next || line.markers[markI].from &lt; next.end)) {</span><span class="s3">\n                    </span><span class="s1">let mark = line.markers[markI++];</span><span class="s3">\n                    </span><span class="s1">this.addNode(mark.type, mark.from, mark.to);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (!next)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">this.finishContext();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (line.pos &lt; line.text.length)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">// Empty line</span><span class="s3">\n            </span><span class="s1">if (!this.nextLine())</span><span class="s3">\n                </span><span class="s1">return this.finish();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.fragments &amp;&amp; this.reuseFragment(line.basePos))</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">start: for (;;) {</span><span class="s3">\n            </span><span class="s1">for (let type of this.parser.blockParsers)</span><span class="s3">\n                </span><span class="s1">if (type) {</span><span class="s3">\n                    </span><span class="s1">let result = type(this, line);</span><span class="s3">\n                    </span><span class="s1">if (result != false) {</span><span class="s3">\n                        </span><span class="s1">if (result == true)</span><span class="s3">\n                            </span><span class="s1">return null;</span><span class="s3">\n                        </span><span class="s1">line.forward();</span><span class="s3">\n                        </span><span class="s1">continue start;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));</span><span class="s3">\n        </span><span class="s1">for (let parse of this.parser.leafBlockParsers)</span><span class="s3">\n            </span><span class="s1">if (parse) {</span><span class="s3">\n                </span><span class="s1">let parser = parse(this, leaf);</span><span class="s3">\n                </span><span class="s1">if (parser)</span><span class="s3">\n                    </span><span class="s1">leaf.parsers.push(parser);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">lines: while (this.nextLine()) {</span><span class="s3">\n            </span><span class="s1">if (line.pos == line.text.length)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">if (line.indent &lt; line.baseIndent + 4) {</span><span class="s3">\n                </span><span class="s1">for (let stop of this.parser.endLeafBlock)</span><span class="s3">\n                    </span><span class="s1">if (stop(this, line, leaf))</span><span class="s3">\n                        </span><span class="s1">break lines;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">for (let parser of leaf.parsers)</span><span class="s3">\n                </span><span class="s1">if (parser.nextLine(this, line, leaf))</span><span class="s3">\n                    </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">leaf.content += </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+ line.scrub();</span><span class="s3">\n            </span><span class="s1">for (let m of line.markers)</span><span class="s3">\n                </span><span class="s1">leaf.marks.push(m);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.finishLeaf(leaf);</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">stopAt(pos) {</span><span class="s3">\n        </span><span class="s1">if (this.stoppedAt != null &amp;&amp; this.stoppedAt &lt; pos)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Can't move stoppedAt forward</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.stoppedAt = pos;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">reuseFragment(start) {</span><span class="s3">\n        </span><span class="s1">if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) ||</span><span class="s3">\n            </span><span class="s1">!this.fragments.matches(this.block.hash))</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">let taken = this.fragments.takeNodes(this);</span><span class="s3">\n        </span><span class="s1">if (!taken)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">this.absoluteLineStart += taken;</span><span class="s3">\n        </span><span class="s1">this.lineStart = toRelative(this.absoluteLineStart, this.ranges);</span><span class="s3">\n        </span><span class="s1">this.moveRangeI();</span><span class="s3">\n        </span><span class="s1">if (this.absoluteLineStart &lt; this.to) {</span><span class="s3">\n            </span><span class="s1">this.lineStart++;</span><span class="s3">\n            </span><span class="s1">this.absoluteLineStart++;</span><span class="s3">\n            </span><span class="s1">this.readLine();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.atEnd = true;</span><span class="s3">\n            </span><span class="s1">this.readLine();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// The number of parent blocks surrounding the current block.</span><span class="s3">\n    </span><span class="s1">get depth() {</span><span class="s3">\n        </span><span class="s1">return this.stack.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Get the type of the parent block at the given depth. When no</span><span class="s3">\n    </span><span class="s1">/// depth is passed, return the type of the innermost parent.</span><span class="s3">\n    </span><span class="s1">parentType(depth = this.depth - 1) {</span><span class="s3">\n        </span><span class="s1">return this.parser.nodeSet.types[this.stack[depth].type];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Move to the next input line. This should only be called by</span><span class="s3">\n    </span><span class="s1">/// (non-composite) [block parsers](#BlockParser.parse) that consume</span><span class="s3">\n    </span><span class="s1">/// the line directly, or leaf block parser</span><span class="s3">\n    </span><span class="s1">/// [`nextLine`](#LeafBlockParser.nextLine) methods when they</span><span class="s3">\n    </span><span class="s1">/// consume the current line (and return true).</span><span class="s3">\n    </span><span class="s1">nextLine() {</span><span class="s3">\n        </span><span class="s1">this.lineStart += this.line.text.length;</span><span class="s3">\n        </span><span class="s1">if (this.absoluteLineEnd &gt;= this.to) {</span><span class="s3">\n            </span><span class="s1">this.absoluteLineStart = this.absoluteLineEnd;</span><span class="s3">\n            </span><span class="s1">this.atEnd = true;</span><span class="s3">\n            </span><span class="s1">this.readLine();</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.lineStart++;</span><span class="s3">\n            </span><span class="s1">this.absoluteLineStart = this.absoluteLineEnd + 1;</span><span class="s3">\n            </span><span class="s1">this.moveRangeI();</span><span class="s3">\n            </span><span class="s1">this.readLine();</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">moveRangeI() {</span><span class="s3">\n        </span><span class="s1">while (this.rangeI &lt; this.ranges.length - 1 &amp;&amp; this.absoluteLineStart &gt;= this.ranges[this.rangeI].to) {</span><span class="s3">\n            </span><span class="s1">this.rangeI++;</span><span class="s3">\n            </span><span class="s1">this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">scanLine(start) {</span><span class="s3">\n        </span><span class="s1">let r = scanLineResult;</span><span class="s3">\n        </span><span class="s1">r.end = start;</span><span class="s3">\n        </span><span class="s1">if (start &gt;= this.to) {</span><span class="s3">\n            </span><span class="s1">r.text = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">r.text = this.lineChunkAt(start);</span><span class="s3">\n            </span><span class="s1">r.end += r.text.length;</span><span class="s3">\n            </span><span class="s1">if (this.ranges.length &gt; 1) {</span><span class="s3">\n                </span><span class="s1">let textOffset = this.absoluteLineStart, rangeI = this.rangeI;</span><span class="s3">\n                </span><span class="s1">while (this.ranges[rangeI].to &lt; r.end) {</span><span class="s3">\n                    </span><span class="s1">rangeI++;</span><span class="s3">\n                    </span><span class="s1">let nextFrom = this.ranges[rangeI].from;</span><span class="s3">\n                    </span><span class="s1">let after = this.lineChunkAt(nextFrom);</span><span class="s3">\n                    </span><span class="s1">r.end = nextFrom + after.length;</span><span class="s3">\n                    </span><span class="s1">r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;</span><span class="s3">\n                    </span><span class="s1">textOffset = r.end - r.text.length;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return r;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">readLine() {</span><span class="s3">\n        </span><span class="s1">let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);</span><span class="s3">\n        </span><span class="s1">this.absoluteLineEnd = end;</span><span class="s3">\n        </span><span class="s1">line.reset(text);</span><span class="s3">\n        </span><span class="s1">for (; line.depth &lt; this.stack.length; line.depth++) {</span><span class="s3">\n            </span><span class="s1">let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];</span><span class="s3">\n            </span><span class="s1">if (!handler)</span><span class="s3">\n                </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Unhandled block context </span><span class="s3">\&quot; </span><span class="s1">+ Type[cx.type]);</span><span class="s3">\n            </span><span class="s1">if (!handler(cx, this, line))</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">line.forward();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">lineChunkAt(pos) {</span><span class="s3">\n        </span><span class="s1">let next = this.input.chunk(pos), text;</span><span class="s3">\n        </span><span class="s1">if (!this.input.lineChunks) {</span><span class="s3">\n            </span><span class="s1">let eol = next.indexOf(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">text = eol &lt; 0 ? next : next.slice(0, eol);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">text = next == </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: next;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return pos + text.length &gt; this.to ? text.slice(0, this.to - pos) : text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// The end position of the previous line.</span><span class="s3">\n    </span><span class="s1">prevLineEnd() { return this.atEnd ? this.lineStart : this.lineStart - 1; }</span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">startContext(type, start, value = 0) {</span><span class="s3">\n        </span><span class="s1">this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);</span><span class="s3">\n        </span><span class="s1">this.stack.push(this.block);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Start a composite block. Should only be called from [block</span><span class="s3">\n    </span><span class="s1">/// parser functions](#BlockParser.parse) that return null.</span><span class="s3">\n    </span><span class="s1">startComposite(type, start, value = 0) {</span><span class="s3">\n        </span><span class="s1">this.startContext(this.parser.getNodeType(type), start, value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">addNode(block, from, to) {</span><span class="s3">\n        </span><span class="s1">if (typeof block == </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">block = new Tree(this.parser.nodeSet.types[block], none, none, (to !== null &amp;&amp; to !== void 0 ? to : this.prevLineEnd()) - from);</span><span class="s3">\n        </span><span class="s1">this.block.addChild(block, from - this.block.from);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Add a block element. Can be called by [block</span><span class="s3">\n    </span><span class="s1">/// parsers](#BlockParser.parse).</span><span class="s3">\n    </span><span class="s1">addElement(elt) {</span><span class="s3">\n        </span><span class="s1">this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Add a block element from a [leaf parser](#LeafBlockParser). This</span><span class="s3">\n    </span><span class="s1">/// makes sure any extra composite block markup (such as blockquote</span><span class="s3">\n    </span><span class="s1">/// markers) inside the block are also added to the syntax tree.</span><span class="s3">\n    </span><span class="s1">addLeafElement(leaf, elt) {</span><span class="s3">\n        </span><span class="s1">this.addNode(this.buffer</span><span class="s3">\n            </span><span class="s1">.writeElements(injectMarks(elt.children, leaf.marks), -elt.from)</span><span class="s3">\n            </span><span class="s1">.finish(elt.type, elt.to - elt.from), elt.from);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">finishContext() {</span><span class="s3">\n        </span><span class="s1">let cx = this.stack.pop();</span><span class="s3">\n        </span><span class="s1">let top = this.stack[this.stack.length - 1];</span><span class="s3">\n        </span><span class="s1">top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);</span><span class="s3">\n        </span><span class="s1">this.block = top;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">finish() {</span><span class="s3">\n        </span><span class="s1">while (this.stack.length &gt; 1)</span><span class="s3">\n            </span><span class="s1">this.finishContext();</span><span class="s3">\n        </span><span class="s1">return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addGaps(tree) {</span><span class="s3">\n        </span><span class="s1">return this.ranges.length &gt; 1 ?</span><span class="s3">\n            </span><span class="s1">injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.reusePlaceholders) : tree;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">finishLeaf(leaf) {</span><span class="s3">\n        </span><span class="s1">for (let parser of leaf.parsers)</span><span class="s3">\n            </span><span class="s1">if (parser.finish(this, leaf))</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);</span><span class="s3">\n        </span><span class="s1">this.addNode(this.buffer</span><span class="s3">\n            </span><span class="s1">.writeElements(inline, -leaf.start)</span><span class="s3">\n            </span><span class="s1">.finish(Type.Paragraph, leaf.content.length), leaf.start);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">elt(type, from, to, children) {</span><span class="s3">\n        </span><span class="s1">if (typeof type == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return elt(this.parser.getNodeType(type), from, to, children);</span><span class="s3">\n        </span><span class="s1">return new TreeElement(type, from);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">get buffer() { return new Buffer(this.parser.nodeSet); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function injectGaps(ranges, rangeI, tree, offset, dummies) {</span><span class="s3">\n    </span><span class="s1">let rangeEnd = ranges[rangeI].to;</span><span class="s3">\n    </span><span class="s1">let children = [], positions = [], start = tree.from + offset;</span><span class="s3">\n    </span><span class="s1">function movePastNext(upto, inclusive) {</span><span class="s3">\n        </span><span class="s1">while (inclusive ? upto &gt;= rangeEnd : upto &gt; rangeEnd) {</span><span class="s3">\n            </span><span class="s1">let size = ranges[rangeI + 1].from - rangeEnd;</span><span class="s3">\n            </span><span class="s1">offset += size;</span><span class="s3">\n            </span><span class="s1">upto += size;</span><span class="s3">\n            </span><span class="s1">rangeI++;</span><span class="s3">\n            </span><span class="s1">rangeEnd = ranges[rangeI].to;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {</span><span class="s3">\n        </span><span class="s1">movePastNext(ch.from + offset, true);</span><span class="s3">\n        </span><span class="s1">let from = ch.from + offset, node, reuse = dummies.get(ch.tree);</span><span class="s3">\n        </span><span class="s1">if (reuse) {</span><span class="s3">\n            </span><span class="s1">node = reuse;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (ch.to + offset &gt; rangeEnd) {</span><span class="s3">\n            </span><span class="s1">node = injectGaps(ranges, rangeI, ch, offset, dummies);</span><span class="s3">\n            </span><span class="s1">movePastNext(ch.to + offset, false);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">node = ch.toTree();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">children.push(node);</span><span class="s3">\n        </span><span class="s1">positions.push(from - start);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">movePastNext(tree.to + offset, false);</span><span class="s3">\n    </span><span class="s1">return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/// A Markdown parser configuration.</span><span class="s3">\n</span><span class="s1">class MarkdownParser extends Parser {</span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/// The parser's syntax [node</span><span class="s3">\n    </span><span class="s1">/// types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).</span><span class="s3">\n    </span><span class="s1">nodeSet, </span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">blockParsers, </span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">leafBlockParsers, </span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">blockNames, </span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">endLeafBlock, </span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">skipContextMarkup, </span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">inlineParsers, </span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">inlineNames, </span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">wrappers) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.nodeSet = nodeSet;</span><span class="s3">\n        </span><span class="s1">this.blockParsers = blockParsers;</span><span class="s3">\n        </span><span class="s1">this.leafBlockParsers = leafBlockParsers;</span><span class="s3">\n        </span><span class="s1">this.blockNames = blockNames;</span><span class="s3">\n        </span><span class="s1">this.endLeafBlock = endLeafBlock;</span><span class="s3">\n        </span><span class="s1">this.skipContextMarkup = skipContextMarkup;</span><span class="s3">\n        </span><span class="s1">this.inlineParsers = inlineParsers;</span><span class="s3">\n        </span><span class="s1">this.inlineNames = inlineNames;</span><span class="s3">\n        </span><span class="s1">this.wrappers = wrappers;</span><span class="s3">\n        </span><span class="s1">/// @internal</span><span class="s3">\n        </span><span class="s1">this.nodeTypes = Object.create(null);</span><span class="s3">\n        </span><span class="s1">for (let t of nodeSet.types)</span><span class="s3">\n            </span><span class="s1">this.nodeTypes[t.name] = t.id;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createParse(input, fragments, ranges) {</span><span class="s3">\n        </span><span class="s1">let parse = new BlockContext(this, input, fragments, ranges);</span><span class="s3">\n        </span><span class="s1">for (let w of this.wrappers)</span><span class="s3">\n            </span><span class="s1">parse = w(parse, input, fragments, ranges);</span><span class="s3">\n        </span><span class="s1">return parse;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Reconfigure the parser.</span><span class="s3">\n    </span><span class="s1">configure(spec) {</span><span class="s3">\n        </span><span class="s1">let config = resolveConfig(spec);</span><span class="s3">\n        </span><span class="s1">if (!config)</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">let { nodeSet, skipContextMarkup } = this;</span><span class="s3">\n        </span><span class="s1">let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;</span><span class="s3">\n        </span><span class="s1">if (nonEmpty(config.defineNodes)) {</span><span class="s3">\n            </span><span class="s1">skipContextMarkup = Object.assign({}, skipContextMarkup);</span><span class="s3">\n            </span><span class="s1">let nodeTypes = nodeSet.types.slice(), styles;</span><span class="s3">\n            </span><span class="s1">for (let s of config.defineNodes) {</span><span class="s3">\n                </span><span class="s1">let { name, block, composite, style } = typeof s == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? { name: s } : s;</span><span class="s3">\n                </span><span class="s1">if (nodeTypes.some(t =&gt; t.name == name))</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">if (composite)</span><span class="s3">\n                    </span><span class="s1">skipContextMarkup[nodeTypes.length] =</span><span class="s3">\n                        </span><span class="s1">(bl, cx, line) =&gt; composite(cx, line, bl.value);</span><span class="s3">\n                </span><span class="s1">let id = nodeTypes.length;</span><span class="s3">\n                </span><span class="s1">let group = composite ? [</span><span class="s3">\&quot;</span><span class="s1">Block</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">BlockContext</span><span class="s3">\&quot;</span><span class="s1">] : !block ? undefined</span><span class="s3">\n                    </span><span class="s1">: id &gt;= Type.ATXHeading1 &amp;&amp; id &lt;= Type.SetextHeading2 ? [</span><span class="s3">\&quot;</span><span class="s1">Block</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">LeafBlock</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">Heading</span><span class="s3">\&quot;</span><span class="s1">] : [</span><span class="s3">\&quot;</span><span class="s1">Block</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">LeafBlock</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n                </span><span class="s1">nodeTypes.push(NodeType.define({</span><span class="s3">\n                    </span><span class="s1">id,</span><span class="s3">\n                    </span><span class="s1">name,</span><span class="s3">\n                    </span><span class="s1">props: group &amp;&amp; [[NodeProp.group, group]]</span><span class="s3">\n                </span><span class="s1">}));</span><span class="s3">\n                </span><span class="s1">if (style) {</span><span class="s3">\n                    </span><span class="s1">if (!styles)</span><span class="s3">\n                        </span><span class="s1">styles = {};</span><span class="s3">\n                    </span><span class="s1">if (Array.isArray(style) || style instanceof Tag)</span><span class="s3">\n                        </span><span class="s1">styles[name] = style;</span><span class="s3">\n                    </span><span class="s1">else</span><span class="s3">\n                        </span><span class="s1">Object.assign(styles, style);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">nodeSet = new NodeSet(nodeTypes);</span><span class="s3">\n            </span><span class="s1">if (styles)</span><span class="s3">\n                </span><span class="s1">nodeSet = nodeSet.extend(styleTags(styles));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (nonEmpty(config.props))</span><span class="s3">\n            </span><span class="s1">nodeSet = nodeSet.extend(...config.props);</span><span class="s3">\n        </span><span class="s1">if (nonEmpty(config.remove)) {</span><span class="s3">\n            </span><span class="s1">for (let rm of config.remove) {</span><span class="s3">\n                </span><span class="s1">let block = this.blockNames.indexOf(rm), inline = this.inlineNames.indexOf(rm);</span><span class="s3">\n                </span><span class="s1">if (block &gt; -1)</span><span class="s3">\n                    </span><span class="s1">blockParsers[block] = leafBlockParsers[block] = undefined;</span><span class="s3">\n                </span><span class="s1">if (inline &gt; -1)</span><span class="s3">\n                    </span><span class="s1">inlineParsers[inline] = undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (nonEmpty(config.parseBlock)) {</span><span class="s3">\n            </span><span class="s1">for (let spec of config.parseBlock) {</span><span class="s3">\n                </span><span class="s1">let found = blockNames.indexOf(spec.name);</span><span class="s3">\n                </span><span class="s1">if (found &gt; -1) {</span><span class="s3">\n                    </span><span class="s1">blockParsers[found] = spec.parse;</span><span class="s3">\n                    </span><span class="s1">leafBlockParsers[found] = spec.leaf;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">let pos = spec.before ? findName(blockNames, spec.before)</span><span class="s3">\n                        </span><span class="s1">: spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;</span><span class="s3">\n                    </span><span class="s1">blockParsers.splice(pos, 0, spec.parse);</span><span class="s3">\n                    </span><span class="s1">leafBlockParsers.splice(pos, 0, spec.leaf);</span><span class="s3">\n                    </span><span class="s1">blockNames.splice(pos, 0, spec.name);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (spec.endLeaf)</span><span class="s3">\n                    </span><span class="s1">endLeafBlock.push(spec.endLeaf);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (nonEmpty(config.parseInline)) {</span><span class="s3">\n            </span><span class="s1">for (let spec of config.parseInline) {</span><span class="s3">\n                </span><span class="s1">let found = inlineNames.indexOf(spec.name);</span><span class="s3">\n                </span><span class="s1">if (found &gt; -1) {</span><span class="s3">\n                    </span><span class="s1">inlineParsers[found] = spec.parse;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">let pos = spec.before ? findName(inlineNames, spec.before)</span><span class="s3">\n                        </span><span class="s1">: spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;</span><span class="s3">\n                    </span><span class="s1">inlineParsers.splice(pos, 0, spec.parse);</span><span class="s3">\n                    </span><span class="s1">inlineNames.splice(pos, 0, spec.name);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (config.wrap)</span><span class="s3">\n            </span><span class="s1">wrappers = wrappers.concat(config.wrap);</span><span class="s3">\n        </span><span class="s1">return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">getNodeType(name) {</span><span class="s3">\n        </span><span class="s1">let found = this.nodeTypes[name];</span><span class="s3">\n        </span><span class="s1">if (found == null)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(`Unknown node type '${name}'`);</span><span class="s3">\n        </span><span class="s1">return found;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Parse the given piece of inline text at the given offset,</span><span class="s3">\n    </span><span class="s1">/// returning an array of [`Element`](#Element) objects representing</span><span class="s3">\n    </span><span class="s1">/// the inline content.</span><span class="s3">\n    </span><span class="s1">parseInline(text, offset) {</span><span class="s3">\n        </span><span class="s1">let cx = new InlineContext(this, text, offset);</span><span class="s3">\n        </span><span class="s1">outer: for (let pos = offset; pos &lt; cx.end;) {</span><span class="s3">\n            </span><span class="s1">let next = cx.char(pos);</span><span class="s3">\n            </span><span class="s1">for (let token of this.inlineParsers)</span><span class="s3">\n                </span><span class="s1">if (token) {</span><span class="s3">\n                    </span><span class="s1">let result = token(cx, next, pos);</span><span class="s3">\n                    </span><span class="s1">if (result &gt;= 0) {</span><span class="s3">\n                        </span><span class="s1">pos = result;</span><span class="s3">\n                        </span><span class="s1">continue outer;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">pos++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return cx.resolveMarkers(0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function nonEmpty(a) {</span><span class="s3">\n    </span><span class="s1">return a != null &amp;&amp; a.length &gt; 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function resolveConfig(spec) {</span><span class="s3">\n    </span><span class="s1">if (!Array.isArray(spec))</span><span class="s3">\n        </span><span class="s1">return spec;</span><span class="s3">\n    </span><span class="s1">if (spec.length == 0)</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">let conf = resolveConfig(spec[0]);</span><span class="s3">\n    </span><span class="s1">if (spec.length == 1)</span><span class="s3">\n        </span><span class="s1">return conf;</span><span class="s3">\n    </span><span class="s1">let rest = resolveConfig(spec.slice(1));</span><span class="s3">\n    </span><span class="s1">if (!rest || !conf)</span><span class="s3">\n        </span><span class="s1">return conf || rest;</span><span class="s3">\n    </span><span class="s1">let conc = (a, b) =&gt; (a || none).concat(b || none);</span><span class="s3">\n    </span><span class="s1">let wrapA = conf.wrap, wrapB = rest.wrap;</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">props: conc(conf.props, rest.props),</span><span class="s3">\n        </span><span class="s1">defineNodes: conc(conf.defineNodes, rest.defineNodes),</span><span class="s3">\n        </span><span class="s1">parseBlock: conc(conf.parseBlock, rest.parseBlock),</span><span class="s3">\n        </span><span class="s1">parseInline: conc(conf.parseInline, rest.parseInline),</span><span class="s3">\n        </span><span class="s1">remove: conc(conf.remove, rest.remove),</span><span class="s3">\n        </span><span class="s1">wrap: !wrapA ? wrapB : !wrapB ? wrapA :</span><span class="s3">\n            </span><span class="s1">(inner, input, fragments, ranges) =&gt; wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findName(names, name) {</span><span class="s3">\n    </span><span class="s1">let found = names.indexOf(name);</span><span class="s3">\n    </span><span class="s1">if (found &lt; 0)</span><span class="s3">\n        </span><span class="s1">throw new RangeError(`Position specified relative to unknown parser ${name}`);</span><span class="s3">\n    </span><span class="s1">return found;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">let nodeTypes = [NodeType.none];</span><span class="s3">\n</span><span class="s1">for (let i = 1, name; name = Type[i]; i++) {</span><span class="s3">\n    </span><span class="s1">nodeTypes[i] = NodeType.define({</span><span class="s3">\n        </span><span class="s1">id: i,</span><span class="s3">\n        </span><span class="s1">name,</span><span class="s3">\n        </span><span class="s1">props: i &gt;= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? [</span><span class="s3">\&quot;</span><span class="s1">Block</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">BlockContext</span><span class="s3">\&quot;</span><span class="s1">] : [</span><span class="s3">\&quot;</span><span class="s1">Block</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">LeafBlock</span><span class="s3">\&quot;</span><span class="s1">]]],</span><span class="s3">\n        </span><span class="s1">top: name == </span><span class="s3">\&quot;</span><span class="s1">Document</span><span class="s3">\&quot;\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const none = [];</span><span class="s3">\n</span><span class="s1">class Buffer {</span><span class="s3">\n    </span><span class="s1">constructor(nodeSet) {</span><span class="s3">\n        </span><span class="s1">this.nodeSet = nodeSet;</span><span class="s3">\n        </span><span class="s1">this.content = [];</span><span class="s3">\n        </span><span class="s1">this.nodes = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">write(type, from, to, children = 0) {</span><span class="s3">\n        </span><span class="s1">this.content.push(type, from, to, 4 + children * 4);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">writeElements(elts, offset = 0) {</span><span class="s3">\n        </span><span class="s1">for (let e of elts)</span><span class="s3">\n            </span><span class="s1">e.writeTo(this, offset);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">finish(type, length) {</span><span class="s3">\n        </span><span class="s1">return Tree.build({</span><span class="s3">\n            </span><span class="s1">buffer: this.content,</span><span class="s3">\n            </span><span class="s1">nodeSet: this.nodeSet,</span><span class="s3">\n            </span><span class="s1">reused: this.nodes,</span><span class="s3">\n            </span><span class="s1">topID: type,</span><span class="s3">\n            </span><span class="s1">length</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/// Elements are used to compose syntax nodes during parsing.</span><span class="s3">\n</span><span class="s1">class Element {</span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/// The node's</span><span class="s3">\n    </span><span class="s1">/// [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).</span><span class="s3">\n    </span><span class="s1">type, </span><span class="s3">\n    </span><span class="s1">/// The start of the node, as an offset from the start of the document.</span><span class="s3">\n    </span><span class="s1">from, </span><span class="s3">\n    </span><span class="s1">/// The end of the node.</span><span class="s3">\n    </span><span class="s1">to, </span><span class="s3">\n    </span><span class="s1">/// The node's child nodes @internal</span><span class="s3">\n    </span><span class="s1">children = none) {</span><span class="s3">\n        </span><span class="s1">this.type = type;</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n        </span><span class="s1">this.children = children;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">writeTo(buf, offset) {</span><span class="s3">\n        </span><span class="s1">let startOff = buf.content.length;</span><span class="s3">\n        </span><span class="s1">buf.writeElements(this.children, offset);</span><span class="s3">\n        </span><span class="s1">buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">toTree(nodeSet) {</span><span class="s3">\n        </span><span class="s1">return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class TreeElement {</span><span class="s3">\n    </span><span class="s1">constructor(tree, from) {</span><span class="s3">\n        </span><span class="s1">this.tree = tree;</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get to() { return this.from + this.tree.length; }</span><span class="s3">\n    </span><span class="s1">get type() { return this.tree.type.id; }</span><span class="s3">\n    </span><span class="s1">get children() { return none; }</span><span class="s3">\n    </span><span class="s1">writeTo(buf, offset) {</span><span class="s3">\n        </span><span class="s1">buf.nodes.push(this.tree);</span><span class="s3">\n        </span><span class="s1">buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toTree() { return this.tree; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function elt(type, from, to, children) {</span><span class="s3">\n    </span><span class="s1">return new Element(type, from, to, children);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const EmphasisUnderscore = { resolve: </span><span class="s3">\&quot;</span><span class="s1">Emphasis</span><span class="s3">\&quot;</span><span class="s1">, mark: </span><span class="s3">\&quot;</span><span class="s1">EmphasisMark</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const EmphasisAsterisk = { resolve: </span><span class="s3">\&quot;</span><span class="s1">Emphasis</span><span class="s3">\&quot;</span><span class="s1">, mark: </span><span class="s3">\&quot;</span><span class="s1">EmphasisMark</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const LinkStart = {}, ImageStart = {};</span><span class="s3">\n</span><span class="s1">class InlineDelimiter {</span><span class="s3">\n    </span><span class="s1">constructor(type, from, to, side) {</span><span class="s3">\n        </span><span class="s1">this.type = type;</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n        </span><span class="s1">this.side = side;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const Escapable = </span><span class="s3">\&quot;</span><span class="s1">!</span><span class="s3">\\\&quot;</span><span class="s1">#$%&amp;'()*+,-./:;&lt;=&gt;?@[</span><span class="s3">\\\\</span><span class="s1">]^_`{|}~</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">let Punctuation = /[!</span><span class="s3">\&quot;</span><span class="s1">#$%&amp;'()*+,</span><span class="s3">\\</span><span class="s1">-.</span><span class="s3">\\</span><span class="s1">/:;&lt;=&gt;?@</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\\\\\</span><span class="s1">]^_`{|}~</span><span class="s3">\\</span><span class="s1">xA1</span><span class="s3">\\</span><span class="s1">u2010-</span><span class="s3">\\</span><span class="s1">u2027]/;</span><span class="s3">\n</span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">Punctuation = new RegExp(</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">p{Pc}|</span><span class="s3">\\\\</span><span class="s1">p{Pd}|</span><span class="s3">\\\\</span><span class="s1">p{Pe}|</span><span class="s3">\\\\</span><span class="s1">p{Pf}|</span><span class="s3">\\\\</span><span class="s1">p{Pi}|</span><span class="s3">\\\\</span><span class="s1">p{Po}|</span><span class="s3">\\\\</span><span class="s1">p{Ps}]</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">u</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">catch (_) { }</span><span class="s3">\n</span><span class="s1">const DefaultInline = {</span><span class="s3">\n    </span><span class="s1">Escape(cx, next, start) {</span><span class="s3">\n        </span><span class="s1">if (next != 92 /* '</span><span class="s3">\\\\</span><span class="s1">' */ || start == cx.end - 1)</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">let escaped = cx.char(start + 1);</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; Escapable.length; i++)</span><span class="s3">\n            </span><span class="s1">if (Escapable.charCodeAt(i) == escaped)</span><span class="s3">\n                </span><span class="s1">return cx.append(elt(Type.Escape, start, start + 2));</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">Entity(cx, next, start) {</span><span class="s3">\n        </span><span class="s1">if (next != 38 /* '&amp;' */)</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">let m = /^(?:#</span><span class="s3">\\</span><span class="s1">d+|#x[a-f</span><span class="s3">\\</span><span class="s1">d]+|</span><span class="s3">\\</span><span class="s1">w+);/i.exec(cx.slice(start + 1, start + 31));</span><span class="s3">\n        </span><span class="s1">return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">InlineCode(cx, next, start) {</span><span class="s3">\n        </span><span class="s1">if (next != 96 /* '`' */ || start &amp;&amp; cx.char(start - 1) == 96)</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">let pos = start + 1;</span><span class="s3">\n        </span><span class="s1">while (pos &lt; cx.end &amp;&amp; cx.char(pos) == 96)</span><span class="s3">\n            </span><span class="s1">pos++;</span><span class="s3">\n        </span><span class="s1">let size = pos - start, curSize = 0;</span><span class="s3">\n        </span><span class="s1">for (; pos &lt; cx.end; pos++) {</span><span class="s3">\n            </span><span class="s1">if (cx.char(pos) == 96) {</span><span class="s3">\n                </span><span class="s1">curSize++;</span><span class="s3">\n                </span><span class="s1">if (curSize == size &amp;&amp; cx.char(pos + 1) != 96)</span><span class="s3">\n                    </span><span class="s1">return cx.append(elt(Type.InlineCode, start, pos + 1, [</span><span class="s3">\n                        </span><span class="s1">elt(Type.CodeMark, start, start + size),</span><span class="s3">\n                        </span><span class="s1">elt(Type.CodeMark, pos + 1 - size, pos + 1)</span><span class="s3">\n                    </span><span class="s1">]));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">curSize = 0;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">HTMLTag(cx, next, start) {</span><span class="s3">\n        </span><span class="s1">if (next != 60 /* '&lt;' */ || start == cx.end - 1)</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">let after = cx.slice(start + 1, cx.end);</span><span class="s3">\n        </span><span class="s1">let url = /^(?:[a-z][-</span><span class="s3">\\</span><span class="s1">w+.]+:[^</span><span class="s3">\\</span><span class="s1">s&gt;]+|[a-z</span><span class="s3">\\</span><span class="s1">d.!#$%&amp;'*+/=?^_`{|}~-]+@[a-z</span><span class="s3">\\</span><span class="s1">d](?:[a-z</span><span class="s3">\\</span><span class="s1">d-]{0,61}[a-z</span><span class="s3">\\</span><span class="s1">d])?(?:</span><span class="s3">\\</span><span class="s1">.[a-z</span><span class="s3">\\</span><span class="s1">d](?:[a-z</span><span class="s3">\\</span><span class="s1">d-]{0,61}[a-z</span><span class="s3">\\</span><span class="s1">d])?)*)&gt;/i.exec(after);</span><span class="s3">\n        </span><span class="s1">if (url) {</span><span class="s3">\n            </span><span class="s1">return cx.append(elt(Type.Autolink, start, start + 1 + url[0].length, [</span><span class="s3">\n                </span><span class="s1">elt(Type.LinkMark, start, start + 1),</span><span class="s3">\n                </span><span class="s1">// url[0] includes the closing bracket, so exclude it from this slice</span><span class="s3">\n                </span><span class="s1">elt(Type.URL, start + 1, start + url[0].length),</span><span class="s3">\n                </span><span class="s1">elt(Type.LinkMark, start + url[0].length, start + 1 + url[0].length)</span><span class="s3">\n            </span><span class="s1">]));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let comment = /^!--[^&gt;](?:-[^-]|[^-])*?--&gt;/i.exec(after);</span><span class="s3">\n        </span><span class="s1">if (comment)</span><span class="s3">\n            </span><span class="s1">return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));</span><span class="s3">\n        </span><span class="s1">let procInst = /^</span><span class="s3">\\</span><span class="s1">?[^]*?</span><span class="s3">\\</span><span class="s1">?&gt;/.exec(after);</span><span class="s3">\n        </span><span class="s1">if (procInst)</span><span class="s3">\n            </span><span class="s1">return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));</span><span class="s3">\n        </span><span class="s1">let m = /^(?:![A-Z][^]*?&gt;|!</span><span class="s3">\\</span><span class="s1">[CDATA</span><span class="s3">\\</span><span class="s1">[[^]*?</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">]&gt;|</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">s*[a-zA-Z][</span><span class="s3">\\</span><span class="s1">w-]*</span><span class="s3">\\</span><span class="s1">s*&gt;|</span><span class="s3">\\</span><span class="s1">s*[a-zA-Z][</span><span class="s3">\\</span><span class="s1">w-]*(</span><span class="s3">\\</span><span class="s1">s+[a-zA-Z:_][</span><span class="s3">\\</span><span class="s1">w-.:]*(?:</span><span class="s3">\\</span><span class="s1">s*=</span><span class="s3">\\</span><span class="s1">s*(?:[^</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\&quot;</span><span class="s1">'=&lt;&gt;`]+|'[^']*'|</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\&quot;</span><span class="s1">]*</span><span class="s3">\&quot;</span><span class="s1">))?)*</span><span class="s3">\\</span><span class="s1">s*(</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">s*)?&gt;)/.exec(after);</span><span class="s3">\n        </span><span class="s1">if (!m)</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">Emphasis(cx, next, start) {</span><span class="s3">\n        </span><span class="s1">if (next != 95 &amp;&amp; next != 42)</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">let pos = start + 1;</span><span class="s3">\n        </span><span class="s1">while (cx.char(pos) == next)</span><span class="s3">\n            </span><span class="s1">pos++;</span><span class="s3">\n        </span><span class="s1">let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);</span><span class="s3">\n        </span><span class="s1">let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);</span><span class="s3">\n        </span><span class="s1">let sBefore = /</span><span class="s3">\\</span><span class="s1">s|^$/.test(before), sAfter = /</span><span class="s3">\\</span><span class="s1">s|^$/.test(after);</span><span class="s3">\n        </span><span class="s1">let leftFlanking = !sAfter &amp;&amp; (!pAfter || sBefore || pBefore);</span><span class="s3">\n        </span><span class="s1">let rightFlanking = !sBefore &amp;&amp; (!pBefore || sAfter || pAfter);</span><span class="s3">\n        </span><span class="s1">let canOpen = leftFlanking &amp;&amp; (next == 42 || !rightFlanking || pBefore);</span><span class="s3">\n        </span><span class="s1">let canClose = rightFlanking &amp;&amp; (next == 42 || !leftFlanking || pAfter);</span><span class="s3">\n        </span><span class="s1">return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 /* Mark.Open */ : 0 /* Mark.None */) | (canClose ? 2 /* Mark.Close */ : 0 /* Mark.None */)));</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">HardBreak(cx, next, start) {</span><span class="s3">\n        </span><span class="s1">if (next == 92 /* '</span><span class="s3">\\\\</span><span class="s1">' */ &amp;&amp; cx.char(start + 1) == 10 /* '</span><span class="s3">\\</span><span class="s1">n' */)</span><span class="s3">\n            </span><span class="s1">return cx.append(elt(Type.HardBreak, start, start + 2));</span><span class="s3">\n        </span><span class="s1">if (next == 32) {</span><span class="s3">\n            </span><span class="s1">let pos = start + 1;</span><span class="s3">\n            </span><span class="s1">while (cx.char(pos) == 32)</span><span class="s3">\n                </span><span class="s1">pos++;</span><span class="s3">\n            </span><span class="s1">if (cx.char(pos) == 10 &amp;&amp; pos &gt;= start + 2)</span><span class="s3">\n                </span><span class="s1">return cx.append(elt(Type.HardBreak, start, pos + 1));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">Link(cx, next, start) {</span><span class="s3">\n        </span><span class="s1">return next == 91 /* '[' */ ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1 /* Mark.Open */)) : -1;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">Image(cx, next, start) {</span><span class="s3">\n        </span><span class="s1">return next == 33 /* '!' */ &amp;&amp; cx.char(start + 1) == 91 /* '[' */</span><span class="s3">\n            </span><span class="s1">? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1 /* Mark.Open */)) : -1;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">LinkEnd(cx, next, start) {</span><span class="s3">\n        </span><span class="s1">if (next != 93 /* ']' */)</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">// Scanning back to the next link/image start marker</span><span class="s3">\n        </span><span class="s1">for (let i = cx.parts.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n            </span><span class="s1">let part = cx.parts[i];</span><span class="s3">\n            </span><span class="s1">if (part instanceof InlineDelimiter &amp;&amp; (part.type == LinkStart || part.type == ImageStart)) {</span><span class="s3">\n                </span><span class="s1">// If this one has been set invalid (because it would produce</span><span class="s3">\n                </span><span class="s1">// a nested link) or there's no valid link here ignore both.</span><span class="s3">\n                </span><span class="s1">if (!part.side || cx.skipSpace(part.to) == start &amp;&amp; !/[(</span><span class="s3">\\</span><span class="s1">[]/.test(cx.slice(start + 1, start + 2))) {</span><span class="s3">\n                    </span><span class="s1">cx.parts[i] = null;</span><span class="s3">\n                    </span><span class="s1">return -1;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">// Finish the content and replace the entire range in</span><span class="s3">\n                </span><span class="s1">// this.parts with the link/image node.</span><span class="s3">\n                </span><span class="s1">let content = cx.takeContent(i);</span><span class="s3">\n                </span><span class="s1">let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);</span><span class="s3">\n                </span><span class="s1">// Set any open-link markers before this link to invalid.</span><span class="s3">\n                </span><span class="s1">if (part.type == LinkStart)</span><span class="s3">\n                    </span><span class="s1">for (let j = 0; j &lt; i; j++) {</span><span class="s3">\n                        </span><span class="s1">let p = cx.parts[j];</span><span class="s3">\n                        </span><span class="s1">if (p instanceof InlineDelimiter &amp;&amp; p.type == LinkStart)</span><span class="s3">\n                            </span><span class="s1">p.side = 0 /* Mark.None */;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return link.to;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function finishLink(cx, content, type, start, startPos) {</span><span class="s3">\n    </span><span class="s1">let { text } = cx, next = cx.char(startPos), endPos = startPos;</span><span class="s3">\n    </span><span class="s1">content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));</span><span class="s3">\n    </span><span class="s1">content.push(elt(Type.LinkMark, startPos - 1, startPos));</span><span class="s3">\n    </span><span class="s1">if (next == 40 /* '(' */) {</span><span class="s3">\n        </span><span class="s1">let pos = cx.skipSpace(startPos + 1);</span><span class="s3">\n        </span><span class="s1">let dest = parseURL(text, pos - cx.offset, cx.offset), title;</span><span class="s3">\n        </span><span class="s1">if (dest) {</span><span class="s3">\n            </span><span class="s1">pos = cx.skipSpace(dest.to);</span><span class="s3">\n            </span><span class="s1">// The destination and title must be separated by whitespace</span><span class="s3">\n            </span><span class="s1">if (pos != dest.to) {</span><span class="s3">\n                </span><span class="s1">title = parseLinkTitle(text, pos - cx.offset, cx.offset);</span><span class="s3">\n                </span><span class="s1">if (title)</span><span class="s3">\n                    </span><span class="s1">pos = cx.skipSpace(title.to);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (cx.char(pos) == 41 /* ')' */) {</span><span class="s3">\n            </span><span class="s1">content.push(elt(Type.LinkMark, startPos, startPos + 1));</span><span class="s3">\n            </span><span class="s1">endPos = pos + 1;</span><span class="s3">\n            </span><span class="s1">if (dest)</span><span class="s3">\n                </span><span class="s1">content.push(dest);</span><span class="s3">\n            </span><span class="s1">if (title)</span><span class="s3">\n                </span><span class="s1">content.push(title);</span><span class="s3">\n            </span><span class="s1">content.push(elt(Type.LinkMark, pos, endPos));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (next == 91 /* '[' */) {</span><span class="s3">\n        </span><span class="s1">let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);</span><span class="s3">\n        </span><span class="s1">if (label) {</span><span class="s3">\n            </span><span class="s1">content.push(label);</span><span class="s3">\n            </span><span class="s1">endPos = label.to;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return elt(type, start, endPos, content);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// These return `null` when falling off the end of the input, `false`</span><span class="s3">\n</span><span class="s1">// when parsing fails otherwise (for use in the incremental link</span><span class="s3">\n</span><span class="s1">// reference parser).</span><span class="s3">\n</span><span class="s1">function parseURL(text, start, offset) {</span><span class="s3">\n    </span><span class="s1">let next = text.charCodeAt(start);</span><span class="s3">\n    </span><span class="s1">if (next == 60 /* '&lt;' */) {</span><span class="s3">\n        </span><span class="s1">for (let pos = start + 1; pos &lt; text.length; pos++) {</span><span class="s3">\n            </span><span class="s1">let ch = text.charCodeAt(pos);</span><span class="s3">\n            </span><span class="s1">if (ch == 62 /* '&gt;' */)</span><span class="s3">\n                </span><span class="s1">return elt(Type.URL, start + offset, pos + 1 + offset);</span><span class="s3">\n            </span><span class="s1">if (ch == 60 || ch == 10 /* '&lt;</span><span class="s3">\\</span><span class="s1">n' */)</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">let depth = 0, pos = start;</span><span class="s3">\n        </span><span class="s1">for (let escaped = false; pos &lt; text.length; pos++) {</span><span class="s3">\n            </span><span class="s1">let ch = text.charCodeAt(pos);</span><span class="s3">\n            </span><span class="s1">if (space(ch)) {</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (escaped) {</span><span class="s3">\n                </span><span class="s1">escaped = false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (ch == 40 /* '(' */) {</span><span class="s3">\n                </span><span class="s1">depth++;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (ch == 41 /* ')' */) {</span><span class="s3">\n                </span><span class="s1">if (!depth)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">depth--;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (ch == 92 /* '</span><span class="s3">\\\\</span><span class="s1">' */) {</span><span class="s3">\n                </span><span class="s1">escaped = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return pos &gt; start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseLinkTitle(text, start, offset) {</span><span class="s3">\n    </span><span class="s1">let next = text.charCodeAt(start);</span><span class="s3">\n    </span><span class="s1">if (next != 39 &amp;&amp; next != 34 &amp;&amp; next != 40 /* '</span><span class="s3">\&quot;\\</span><span class="s1">'(' */)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let end = next == 40 ? 41 : next;</span><span class="s3">\n    </span><span class="s1">for (let pos = start + 1, escaped = false; pos &lt; text.length; pos++) {</span><span class="s3">\n        </span><span class="s1">let ch = text.charCodeAt(pos);</span><span class="s3">\n        </span><span class="s1">if (escaped)</span><span class="s3">\n            </span><span class="s1">escaped = false;</span><span class="s3">\n        </span><span class="s1">else if (ch == end)</span><span class="s3">\n            </span><span class="s1">return elt(Type.LinkTitle, start + offset, pos + 1 + offset);</span><span class="s3">\n        </span><span class="s1">else if (ch == 92 /* '</span><span class="s3">\\\\</span><span class="s1">' */)</span><span class="s3">\n            </span><span class="s1">escaped = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseLinkLabel(text, start, offset, requireNonWS) {</span><span class="s3">\n    </span><span class="s1">for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos &lt; end; pos++) {</span><span class="s3">\n        </span><span class="s1">let ch = text.charCodeAt(pos);</span><span class="s3">\n        </span><span class="s1">if (escaped)</span><span class="s3">\n            </span><span class="s1">escaped = false;</span><span class="s3">\n        </span><span class="s1">else if (ch == 93 /* ']' */)</span><span class="s3">\n            </span><span class="s1">return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">if (requireNonWS &amp;&amp; !space(ch))</span><span class="s3">\n                </span><span class="s1">requireNonWS = false;</span><span class="s3">\n            </span><span class="s1">if (ch == 91 /* '[' */)</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">else if (ch == 92 /* '</span><span class="s3">\\\\</span><span class="s1">' */)</span><span class="s3">\n                </span><span class="s1">escaped = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/// Inline parsing functions get access to this context, and use it to</span><span class="s3">\n</span><span class="s1">/// read the content and emit syntax nodes.</span><span class="s3">\n</span><span class="s1">class InlineContext {</span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/// The parser that is being used.</span><span class="s3">\n    </span><span class="s1">parser, </span><span class="s3">\n    </span><span class="s1">/// The text of this inline section.</span><span class="s3">\n    </span><span class="s1">text, </span><span class="s3">\n    </span><span class="s1">/// The starting offset of the section in the document.</span><span class="s3">\n    </span><span class="s1">offset) {</span><span class="s3">\n        </span><span class="s1">this.parser = parser;</span><span class="s3">\n        </span><span class="s1">this.text = text;</span><span class="s3">\n        </span><span class="s1">this.offset = offset;</span><span class="s3">\n        </span><span class="s1">/// @internal</span><span class="s3">\n        </span><span class="s1">this.parts = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Get the character code at the given (document-relative)</span><span class="s3">\n    </span><span class="s1">/// position.</span><span class="s3">\n    </span><span class="s1">char(pos) { return pos &gt;= this.end ? -1 : this.text.charCodeAt(pos - this.offset); }</span><span class="s3">\n    </span><span class="s1">/// The position of the end of this inline section.</span><span class="s3">\n    </span><span class="s1">get end() { return this.offset + this.text.length; }</span><span class="s3">\n    </span><span class="s1">/// Get a substring of this inline section. Again uses</span><span class="s3">\n    </span><span class="s1">/// document-relative positions.</span><span class="s3">\n    </span><span class="s1">slice(from, to) { return this.text.slice(from - this.offset, to - this.offset); }</span><span class="s3">\n    </span><span class="s1">/// @internal</span><span class="s3">\n    </span><span class="s1">append(elt) {</span><span class="s3">\n        </span><span class="s1">this.parts.push(elt);</span><span class="s3">\n        </span><span class="s1">return elt.to;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Add a [delimiter](#DelimiterType) at this given position. `open`</span><span class="s3">\n    </span><span class="s1">/// and `close` indicate whether this delimiter is opening, closing,</span><span class="s3">\n    </span><span class="s1">/// or both. Returns the end of the delimiter, for convenient</span><span class="s3">\n    </span><span class="s1">/// returning from [parse functions](#InlineParser.parse).</span><span class="s3">\n    </span><span class="s1">addDelimiter(type, from, to, open, close) {</span><span class="s3">\n        </span><span class="s1">return this.append(new InlineDelimiter(type, from, to, (open ? 1 /* Mark.Open */ : 0 /* Mark.None */) | (close ? 2 /* Mark.Close */ : 0 /* Mark.None */)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Returns true when there is an unmatched link or image opening</span><span class="s3">\n    </span><span class="s1">/// token before the current position.</span><span class="s3">\n    </span><span class="s1">get hasOpenLink() {</span><span class="s3">\n        </span><span class="s1">for (let i = this.parts.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n            </span><span class="s1">let part = this.parts[i];</span><span class="s3">\n            </span><span class="s1">if (part instanceof InlineDelimiter &amp;&amp; (part.type == LinkStart || part.type == ImageStart))</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Add an inline element. Returns the end of the element.</span><span class="s3">\n    </span><span class="s1">addElement(elt) {</span><span class="s3">\n        </span><span class="s1">return this.append(elt);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Resolve markers between this.parts.length and from, wrapping matched markers in the</span><span class="s3">\n    </span><span class="s1">/// appropriate node and updating the content of this.parts. @internal</span><span class="s3">\n    </span><span class="s1">resolveMarkers(from) {</span><span class="s3">\n        </span><span class="s1">// Scan forward, looking for closing tokens</span><span class="s3">\n        </span><span class="s1">for (let i = from; i &lt; this.parts.length; i++) {</span><span class="s3">\n            </span><span class="s1">let close = this.parts[i];</span><span class="s3">\n            </span><span class="s1">if (!(close instanceof InlineDelimiter &amp;&amp; close.type.resolve &amp;&amp; (close.side &amp; 2 /* Mark.Close */)))</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;</span><span class="s3">\n            </span><span class="s1">let closeSize = close.to - close.from;</span><span class="s3">\n            </span><span class="s1">let open, j = i - 1;</span><span class="s3">\n            </span><span class="s1">// Continue scanning for a matching opening token</span><span class="s3">\n            </span><span class="s1">for (; j &gt;= from; j--) {</span><span class="s3">\n                </span><span class="s1">let part = this.parts[j];</span><span class="s3">\n                </span><span class="s1">if (part instanceof InlineDelimiter &amp;&amp; (part.side &amp; 1 /* Mark.Open */) &amp;&amp; part.type == close.type &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">// Ignore emphasis delimiters where the character count doesn't match</span><span class="s3">\n                    </span><span class="s1">!(emp &amp;&amp; ((close.side &amp; 1 /* Mark.Open */) || (part.side &amp; 2 /* Mark.Close */)) &amp;&amp;</span><span class="s3">\n                        </span><span class="s1">(part.to - part.from + closeSize) % 3 == 0 &amp;&amp; ((part.to - part.from) % 3 || closeSize % 3))) {</span><span class="s3">\n                    </span><span class="s1">open = part;</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!open)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">let type = close.type.resolve, content = [];</span><span class="s3">\n            </span><span class="s1">let start = open.from, end = close.to;</span><span class="s3">\n            </span><span class="s1">// Emphasis marker effect depends on the character count. Size consumed is minimum of the two</span><span class="s3">\n            </span><span class="s1">// markers.</span><span class="s3">\n            </span><span class="s1">if (emp) {</span><span class="s3">\n                </span><span class="s1">let size = Math.min(2, open.to - open.from, closeSize);</span><span class="s3">\n                </span><span class="s1">start = open.to - size;</span><span class="s3">\n                </span><span class="s1">end = close.from + size;</span><span class="s3">\n                </span><span class="s1">type = size == 1 ? </span><span class="s3">\&quot;</span><span class="s1">Emphasis</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">StrongEmphasis</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Move the covered region into content, optionally adding marker nodes</span><span class="s3">\n            </span><span class="s1">if (open.type.mark)</span><span class="s3">\n                </span><span class="s1">content.push(this.elt(open.type.mark, start, open.to));</span><span class="s3">\n            </span><span class="s1">for (let k = j + 1; k &lt; i; k++) {</span><span class="s3">\n                </span><span class="s1">if (this.parts[k] instanceof Element)</span><span class="s3">\n                    </span><span class="s1">content.push(this.parts[k]);</span><span class="s3">\n                </span><span class="s1">this.parts[k] = null;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (close.type.mark)</span><span class="s3">\n                </span><span class="s1">content.push(this.elt(close.type.mark, close.from, end));</span><span class="s3">\n            </span><span class="s1">let element = this.elt(type, start, end, content);</span><span class="s3">\n            </span><span class="s1">// If there are leftover emphasis marker characters, shrink the close/open markers. Otherwise, clear them.</span><span class="s3">\n            </span><span class="s1">this.parts[j] = emp &amp;&amp; open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;</span><span class="s3">\n            </span><span class="s1">let keep = this.parts[i] = emp &amp;&amp; close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;</span><span class="s3">\n            </span><span class="s1">// Insert the new element in this.parts</span><span class="s3">\n            </span><span class="s1">if (keep)</span><span class="s3">\n                </span><span class="s1">this.parts.splice(i, 0, element);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">this.parts[i] = element;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Collect the elements remaining in this.parts into an array.</span><span class="s3">\n        </span><span class="s1">let result = [];</span><span class="s3">\n        </span><span class="s1">for (let i = from; i &lt; this.parts.length; i++) {</span><span class="s3">\n            </span><span class="s1">let part = this.parts[i];</span><span class="s3">\n            </span><span class="s1">if (part instanceof Element)</span><span class="s3">\n                </span><span class="s1">result.push(part);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Find an opening delimiter of the given type. Returns `null` if</span><span class="s3">\n    </span><span class="s1">/// no delimiter is found, or an index that can be passed to</span><span class="s3">\n    </span><span class="s1">/// [`takeContent`](#InlineContext.takeContent) otherwise.</span><span class="s3">\n    </span><span class="s1">findOpeningDelimiter(type) {</span><span class="s3">\n        </span><span class="s1">for (let i = this.parts.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n            </span><span class="s1">let part = this.parts[i];</span><span class="s3">\n            </span><span class="s1">if (part instanceof InlineDelimiter &amp;&amp; part.type == type)</span><span class="s3">\n                </span><span class="s1">return i;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Remove all inline elements and delimiters starting from the</span><span class="s3">\n    </span><span class="s1">/// given index (which you should get from</span><span class="s3">\n    </span><span class="s1">/// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),</span><span class="s3">\n    </span><span class="s1">/// resolve delimiters inside of them, and return them as an array</span><span class="s3">\n    </span><span class="s1">/// of elements.</span><span class="s3">\n    </span><span class="s1">takeContent(startIndex) {</span><span class="s3">\n        </span><span class="s1">let content = this.resolveMarkers(startIndex);</span><span class="s3">\n        </span><span class="s1">this.parts.length = startIndex;</span><span class="s3">\n        </span><span class="s1">return content;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/// Skip space after the given (document) position, returning either</span><span class="s3">\n    </span><span class="s1">/// the position of the next non-space character or the end of the</span><span class="s3">\n    </span><span class="s1">/// section.</span><span class="s3">\n    </span><span class="s1">skipSpace(from) { return skipSpace(this.text, from - this.offset) + this.offset; }</span><span class="s3">\n    </span><span class="s1">elt(type, from, to, children) {</span><span class="s3">\n        </span><span class="s1">if (typeof type == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return elt(this.parser.getNodeType(type), from, to, children);</span><span class="s3">\n        </span><span class="s1">return new TreeElement(type, from);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function injectMarks(elements, marks) {</span><span class="s3">\n    </span><span class="s1">if (!marks.length)</span><span class="s3">\n        </span><span class="s1">return elements;</span><span class="s3">\n    </span><span class="s1">if (!elements.length)</span><span class="s3">\n        </span><span class="s1">return marks;</span><span class="s3">\n    </span><span class="s1">let elts = elements.slice(), eI = 0;</span><span class="s3">\n    </span><span class="s1">for (let mark of marks) {</span><span class="s3">\n        </span><span class="s1">while (eI &lt; elts.length &amp;&amp; elts[eI].to &lt; mark.to)</span><span class="s3">\n            </span><span class="s1">eI++;</span><span class="s3">\n        </span><span class="s1">if (eI &lt; elts.length &amp;&amp; elts[eI].from &lt; mark.from) {</span><span class="s3">\n            </span><span class="s1">let e = elts[eI];</span><span class="s3">\n            </span><span class="s1">if (e instanceof Element)</span><span class="s3">\n                </span><span class="s1">elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">elts.splice(eI++, 0, mark);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return elts;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// These are blocks that can span blank lines, and should thus only be</span><span class="s3">\n</span><span class="s1">// reused if their next sibling is also being reused.</span><span class="s3">\n</span><span class="s1">const NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];</span><span class="s3">\n</span><span class="s1">class FragmentCursor {</span><span class="s3">\n    </span><span class="s1">constructor(fragments, input) {</span><span class="s3">\n        </span><span class="s1">this.fragments = fragments;</span><span class="s3">\n        </span><span class="s1">this.input = input;</span><span class="s3">\n        </span><span class="s1">// Index into fragment array</span><span class="s3">\n        </span><span class="s1">this.i = 0;</span><span class="s3">\n        </span><span class="s1">// Active fragment</span><span class="s3">\n        </span><span class="s1">this.fragment = null;</span><span class="s3">\n        </span><span class="s1">this.fragmentEnd = -1;</span><span class="s3">\n        </span><span class="s1">// Cursor into the current fragment, if any. When `moveTo` returns</span><span class="s3">\n        </span><span class="s1">// true, this points at the first block after `pos`.</span><span class="s3">\n        </span><span class="s1">this.cursor = null;</span><span class="s3">\n        </span><span class="s1">if (fragments.length)</span><span class="s3">\n            </span><span class="s1">this.fragment = fragments[this.i++];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nextFragment() {</span><span class="s3">\n        </span><span class="s1">this.fragment = this.i &lt; this.fragments.length ? this.fragments[this.i++] : null;</span><span class="s3">\n        </span><span class="s1">this.cursor = null;</span><span class="s3">\n        </span><span class="s1">this.fragmentEnd = -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">moveTo(pos, lineStart) {</span><span class="s3">\n        </span><span class="s1">while (this.fragment &amp;&amp; this.fragment.to &lt;= pos)</span><span class="s3">\n            </span><span class="s1">this.nextFragment();</span><span class="s3">\n        </span><span class="s1">if (!this.fragment || this.fragment.from &gt; (pos ? pos - 1 : 0))</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">if (this.fragmentEnd &lt; 0) {</span><span class="s3">\n            </span><span class="s1">let end = this.fragment.to;</span><span class="s3">\n            </span><span class="s1">while (end &gt; 0 &amp;&amp; this.input.read(end - 1, end) != </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">end--;</span><span class="s3">\n            </span><span class="s1">this.fragmentEnd = end ? end - 1 : 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let c = this.cursor;</span><span class="s3">\n        </span><span class="s1">if (!c) {</span><span class="s3">\n            </span><span class="s1">c = this.cursor = this.fragment.tree.cursor();</span><span class="s3">\n            </span><span class="s1">c.firstChild();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let rPos = pos + this.fragment.offset;</span><span class="s3">\n        </span><span class="s1">while (c.to &lt;= rPos)</span><span class="s3">\n            </span><span class="s1">if (!c.parent())</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">if (c.from &gt;= rPos)</span><span class="s3">\n                </span><span class="s1">return this.fragment.from &lt;= lineStart;</span><span class="s3">\n            </span><span class="s1">if (!c.childAfter(rPos))</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">matches(hash) {</span><span class="s3">\n        </span><span class="s1">let tree = this.cursor.tree;</span><span class="s3">\n        </span><span class="s1">return tree &amp;&amp; tree.prop(NodeProp.contextHash) == hash;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">takeNodes(cx) {</span><span class="s3">\n        </span><span class="s1">let cur = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);</span><span class="s3">\n        </span><span class="s1">let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;</span><span class="s3">\n        </span><span class="s1">let prevEnd = end, prevI = blockI;</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">if (cur.to - off &gt; fragEnd) {</span><span class="s3">\n                </span><span class="s1">if (cur.type.isAnonymous &amp;&amp; cur.firstChild())</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let pos = toRelative(cur.from - off, cx.ranges);</span><span class="s3">\n            </span><span class="s1">if (cur.to - off &lt;= cx.ranges[cx.rangeI].to) { // Fits in current range</span><span class="s3">\n                </span><span class="s1">cx.addNode(cur.tree, pos);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let dummy = new Tree(cx.parser.nodeSet.types[Type.Paragraph], [], [], 0, cx.block.hashProp);</span><span class="s3">\n                </span><span class="s1">cx.reusePlaceholders.set(dummy, cur.tree);</span><span class="s3">\n                </span><span class="s1">cx.addNode(dummy, pos);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Taken content must always end in a block, because incremental</span><span class="s3">\n            </span><span class="s1">// parsing happens on block boundaries. Never stop directly</span><span class="s3">\n            </span><span class="s1">// after an indented code block, since those can continue after</span><span class="s3">\n            </span><span class="s1">// any number of blank lines.</span><span class="s3">\n            </span><span class="s1">if (cur.type.is(</span><span class="s3">\&quot;</span><span class="s1">Block</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n                </span><span class="s1">if (NotLast.indexOf(cur.type.id) &lt; 0) {</span><span class="s3">\n                    </span><span class="s1">end = cur.to - off;</span><span class="s3">\n                    </span><span class="s1">blockI = cx.block.children.length;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">end = prevEnd;</span><span class="s3">\n                    </span><span class="s1">blockI = prevI;</span><span class="s3">\n                    </span><span class="s1">prevEnd = cur.to - off;</span><span class="s3">\n                    </span><span class="s1">prevI = cx.block.children.length;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!cur.nextSibling())</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">while (cx.block.children.length &gt; blockI) {</span><span class="s3">\n            </span><span class="s1">cx.block.children.pop();</span><span class="s3">\n            </span><span class="s1">cx.block.positions.pop();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return end - start;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Convert an input-stream-relative position to a</span><span class="s3">\n</span><span class="s1">// Markdown-doc-relative position by subtracting the size of all input</span><span class="s3">\n</span><span class="s1">// gaps before `abs`.</span><span class="s3">\n</span><span class="s1">function toRelative(abs, ranges) {</span><span class="s3">\n    </span><span class="s1">let pos = abs;</span><span class="s3">\n    </span><span class="s1">for (let i = 1; i &lt; ranges.length; i++) {</span><span class="s3">\n        </span><span class="s1">let gapFrom = ranges[i - 1].to, gapTo = ranges[i].from;</span><span class="s3">\n        </span><span class="s1">if (gapFrom &lt; abs)</span><span class="s3">\n            </span><span class="s1">pos -= gapTo - gapFrom;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return pos;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const markdownHighlighting = styleTags({</span><span class="s3">\n    \&quot;</span><span class="s1">Blockquote/...</span><span class="s3">\&quot;</span><span class="s1">: tags.quote,</span><span class="s3">\n    </span><span class="s1">HorizontalRule: tags.contentSeparator,</span><span class="s3">\n    \&quot;</span><span class="s1">ATXHeading1/... SetextHeading1/...</span><span class="s3">\&quot;</span><span class="s1">: tags.heading1,</span><span class="s3">\n    \&quot;</span><span class="s1">ATXHeading2/... SetextHeading2/...</span><span class="s3">\&quot;</span><span class="s1">: tags.heading2,</span><span class="s3">\n    \&quot;</span><span class="s1">ATXHeading3/...</span><span class="s3">\&quot;</span><span class="s1">: tags.heading3,</span><span class="s3">\n    \&quot;</span><span class="s1">ATXHeading4/...</span><span class="s3">\&quot;</span><span class="s1">: tags.heading4,</span><span class="s3">\n    \&quot;</span><span class="s1">ATXHeading5/...</span><span class="s3">\&quot;</span><span class="s1">: tags.heading5,</span><span class="s3">\n    \&quot;</span><span class="s1">ATXHeading6/...</span><span class="s3">\&quot;</span><span class="s1">: tags.heading6,</span><span class="s3">\n    \&quot;</span><span class="s1">Comment CommentBlock</span><span class="s3">\&quot;</span><span class="s1">: tags.comment,</span><span class="s3">\n    </span><span class="s1">Escape: tags.escape,</span><span class="s3">\n    </span><span class="s1">Entity: tags.character,</span><span class="s3">\n    \&quot;</span><span class="s1">Emphasis/...</span><span class="s3">\&quot;</span><span class="s1">: tags.emphasis,</span><span class="s3">\n    \&quot;</span><span class="s1">StrongEmphasis/...</span><span class="s3">\&quot;</span><span class="s1">: tags.strong,</span><span class="s3">\n    \&quot;</span><span class="s1">Link/... Image/...</span><span class="s3">\&quot;</span><span class="s1">: tags.link,</span><span class="s3">\n    \&quot;</span><span class="s1">OrderedList/... BulletList/...</span><span class="s3">\&quot;</span><span class="s1">: tags.list,</span><span class="s3">\n    \&quot;</span><span class="s1">BlockQuote/...</span><span class="s3">\&quot;</span><span class="s1">: tags.quote,</span><span class="s3">\n    \&quot;</span><span class="s1">InlineCode CodeText</span><span class="s3">\&quot;</span><span class="s1">: tags.monospace,</span><span class="s3">\n    \&quot;</span><span class="s1">URL Autolink</span><span class="s3">\&quot;</span><span class="s1">: tags.url,</span><span class="s3">\n    \&quot;</span><span class="s1">HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark</span><span class="s3">\&quot;</span><span class="s1">: tags.processingInstruction,</span><span class="s3">\n    \&quot;</span><span class="s1">CodeInfo LinkLabel</span><span class="s3">\&quot;</span><span class="s1">: tags.labelName,</span><span class="s3">\n    </span><span class="s1">LinkTitle: tags.string,</span><span class="s3">\n    </span><span class="s1">Paragraph: tags.content</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/// The default CommonMark parser.</span><span class="s3">\n</span><span class="s1">const parser = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map(n =&gt; DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n =&gt; DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n =&gt; DefaultInline[n]), Object.keys(DefaultInline), []);</span><span class="s3">\n\n</span><span class="s1">function leftOverSpace(node, from, to) {</span><span class="s3">\n    </span><span class="s1">let ranges = [];</span><span class="s3">\n    </span><span class="s1">for (let n = node.firstChild, pos = from;; n = n.nextSibling) {</span><span class="s3">\n        </span><span class="s1">let nextPos = n ? n.from : to;</span><span class="s3">\n        </span><span class="s1">if (nextPos &gt; pos)</span><span class="s3">\n            </span><span class="s1">ranges.push({ from: pos, to: nextPos });</span><span class="s3">\n        </span><span class="s1">if (!n)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">pos = n.to;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ranges;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/// Create a Markdown extension to enable nested parsing on code</span><span class="s3">\n</span><span class="s1">/// blocks and/or embedded HTML.</span><span class="s3">\n</span><span class="s1">function parseCode(config) {</span><span class="s3">\n    </span><span class="s1">let { codeParser, htmlParser } = config;</span><span class="s3">\n    </span><span class="s1">let wrap = parseMixed((node, input) =&gt; {</span><span class="s3">\n        </span><span class="s1">let id = node.type.id;</span><span class="s3">\n        </span><span class="s1">if (codeParser &amp;&amp; (id == Type.CodeBlock || id == Type.FencedCode)) {</span><span class="s3">\n            </span><span class="s1">let info = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">if (id == Type.FencedCode) {</span><span class="s3">\n                </span><span class="s1">let infoNode = node.node.getChild(Type.CodeInfo);</span><span class="s3">\n                </span><span class="s1">if (infoNode)</span><span class="s3">\n                    </span><span class="s1">info = input.read(infoNode.from, infoNode.to);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let parser = codeParser(info);</span><span class="s3">\n            </span><span class="s1">if (parser)</span><span class="s3">\n                </span><span class="s1">return { parser, overlay: node =&gt; node.type.id == Type.CodeText };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (htmlParser &amp;&amp; (id == Type.HTMLBlock || id == Type.HTMLTag)) {</span><span class="s3">\n            </span><span class="s1">return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return { wrap };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const StrikethroughDelim = { resolve: </span><span class="s3">\&quot;</span><span class="s1">Strikethrough</span><span class="s3">\&quot;</span><span class="s1">, mark: </span><span class="s3">\&quot;</span><span class="s1">StrikethroughMark</span><span class="s3">\&quot; </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/// An extension that implements</span><span class="s3">\n</span><span class="s1">/// [GFM-style](https://github.github.com/gfm/#strikethrough-extension-)</span><span class="s3">\n</span><span class="s1">/// Strikethrough syntax using `~~` delimiters.</span><span class="s3">\n</span><span class="s1">const Strikethrough = {</span><span class="s3">\n    </span><span class="s1">defineNodes: [{</span><span class="s3">\n            </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">Strikethrough</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">style: { </span><span class="s3">\&quot;</span><span class="s1">Strikethrough/...</span><span class="s3">\&quot;</span><span class="s1">: tags.strikethrough }</span><span class="s3">\n        </span><span class="s1">}, {</span><span class="s3">\n            </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">StrikethroughMark</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">style: tags.processingInstruction</span><span class="s3">\n        </span><span class="s1">}],</span><span class="s3">\n    </span><span class="s1">parseInline: [{</span><span class="s3">\n            </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">Strikethrough</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">parse(cx, next, pos) {</span><span class="s3">\n                </span><span class="s1">if (next != 126 /* '~' */ || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126)</span><span class="s3">\n                    </span><span class="s1">return -1;</span><span class="s3">\n                </span><span class="s1">let before = cx.slice(pos - 1, pos), after = cx.slice(pos + 2, pos + 3);</span><span class="s3">\n                </span><span class="s1">let sBefore = /</span><span class="s3">\\</span><span class="s1">s|^$/.test(before), sAfter = /</span><span class="s3">\\</span><span class="s1">s|^$/.test(after);</span><span class="s3">\n                </span><span class="s1">let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);</span><span class="s3">\n                </span><span class="s1">return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter &amp;&amp; (!pAfter || sBefore || pBefore), !sBefore &amp;&amp; (!pBefore || sAfter || pAfter));</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">after: </span><span class="s3">\&quot;</span><span class="s1">Emphasis</span><span class="s3">\&quot;\n        </span><span class="s1">}]</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function parseRow(cx, line, startI = 0, elts, offset = 0) {</span><span class="s3">\n    </span><span class="s1">let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;</span><span class="s3">\n    </span><span class="s1">let parseCell = () =&gt; {</span><span class="s3">\n        </span><span class="s1">elts.push(cx.elt(</span><span class="s3">\&quot;</span><span class="s1">TableCell</span><span class="s3">\&quot;</span><span class="s1">, offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">for (let i = startI; i &lt; line.length; i++) {</span><span class="s3">\n        </span><span class="s1">let next = line.charCodeAt(i);</span><span class="s3">\n        </span><span class="s1">if (next == 124 /* '|' */ &amp;&amp; !esc) {</span><span class="s3">\n            </span><span class="s1">if (!first || cellStart &gt; -1)</span><span class="s3">\n                </span><span class="s1">count++;</span><span class="s3">\n            </span><span class="s1">first = false;</span><span class="s3">\n            </span><span class="s1">if (elts) {</span><span class="s3">\n                </span><span class="s1">if (cellStart &gt; -1)</span><span class="s3">\n                    </span><span class="s1">parseCell();</span><span class="s3">\n                </span><span class="s1">elts.push(cx.elt(</span><span class="s3">\&quot;</span><span class="s1">TableDelimiter</span><span class="s3">\&quot;</span><span class="s1">, i + offset, i + offset + 1));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">cellStart = cellEnd = -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (esc || next != 32 &amp;&amp; next != 9) {</span><span class="s3">\n            </span><span class="s1">if (cellStart &lt; 0)</span><span class="s3">\n                </span><span class="s1">cellStart = i;</span><span class="s3">\n            </span><span class="s1">cellEnd = i + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">esc = !esc &amp;&amp; next == 92;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (cellStart &gt; -1) {</span><span class="s3">\n        </span><span class="s1">count++;</span><span class="s3">\n        </span><span class="s1">if (elts)</span><span class="s3">\n            </span><span class="s1">parseCell();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return count;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function hasPipe(str, start) {</span><span class="s3">\n    </span><span class="s1">for (let i = start; i &lt; str.length; i++) {</span><span class="s3">\n        </span><span class="s1">let next = str.charCodeAt(i);</span><span class="s3">\n        </span><span class="s1">if (next == 124 /* '|' */)</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">if (next == 92 /* '</span><span class="s3">\\\\</span><span class="s1">' */)</span><span class="s3">\n            </span><span class="s1">i++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const delimiterLine = /^</span><span class="s3">\\</span><span class="s1">|?(</span><span class="s3">\\</span><span class="s1">s*:?-+:?</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\\</span><span class="s1">|)+(</span><span class="s3">\\</span><span class="s1">s*:?-+:?</span><span class="s3">\\</span><span class="s1">s*)?$/;</span><span class="s3">\n</span><span class="s1">class TableParser {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">// Null means we haven't seen the second line yet, false means this</span><span class="s3">\n        </span><span class="s1">// isn't a table, and an array means this is a table and we've</span><span class="s3">\n        </span><span class="s1">// parsed the given rows so far.</span><span class="s3">\n        </span><span class="s1">this.rows = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nextLine(cx, line, leaf) {</span><span class="s3">\n        </span><span class="s1">if (this.rows == null) { // Second line</span><span class="s3">\n            </span><span class="s1">this.rows = false;</span><span class="s3">\n            </span><span class="s1">let lineText;</span><span class="s3">\n            </span><span class="s1">if ((line.next == 45 || line.next == 58 || line.next == 124 /* '-:|' */) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">delimiterLine.test(lineText = line.text.slice(line.pos))) {</span><span class="s3">\n                </span><span class="s1">let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);</span><span class="s3">\n                </span><span class="s1">if (firstCount == parseRow(cx, lineText, line.pos))</span><span class="s3">\n                    </span><span class="s1">this.rows = [cx.elt(</span><span class="s3">\&quot;</span><span class="s1">TableHeader</span><span class="s3">\&quot;</span><span class="s1">, leaf.start, leaf.start + leaf.content.length, firstRow),</span><span class="s3">\n                        </span><span class="s1">cx.elt(</span><span class="s3">\&quot;</span><span class="s1">TableDelimiter</span><span class="s3">\&quot;</span><span class="s1">, cx.lineStart + line.pos, cx.lineStart + line.text.length)];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (this.rows) { // Line after the second</span><span class="s3">\n            </span><span class="s1">let content = [];</span><span class="s3">\n            </span><span class="s1">parseRow(cx, line.text, line.pos, content, cx.lineStart);</span><span class="s3">\n            </span><span class="s1">this.rows.push(cx.elt(</span><span class="s3">\&quot;</span><span class="s1">TableRow</span><span class="s3">\&quot;</span><span class="s1">, cx.lineStart + line.pos, cx.lineStart + line.text.length, content));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">finish(cx, leaf) {</span><span class="s3">\n        </span><span class="s1">if (!this.rows)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">cx.addLeafElement(leaf, cx.elt(</span><span class="s3">\&quot;</span><span class="s1">Table</span><span class="s3">\&quot;</span><span class="s1">, leaf.start, leaf.start + leaf.content.length, this.rows));</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/// This extension provides</span><span class="s3">\n</span><span class="s1">/// [GFM-style](https://github.github.com/gfm/#tables-extension-)</span><span class="s3">\n</span><span class="s1">/// tables, using syntax like this:</span><span class="s3">\n</span><span class="s1">///</span><span class="s3">\n</span><span class="s1">/// ```</span><span class="s3">\n</span><span class="s1">/// | head 1 | head 2 |</span><span class="s3">\n</span><span class="s1">/// | ---    | ---    |</span><span class="s3">\n</span><span class="s1">/// | cell 1 | cell 2 |</span><span class="s3">\n</span><span class="s1">/// ```</span><span class="s3">\n</span><span class="s1">const Table = {</span><span class="s3">\n    </span><span class="s1">defineNodes: [</span><span class="s3">\n        </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">Table</span><span class="s3">\&quot;</span><span class="s1">, block: true },</span><span class="s3">\n        </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">TableHeader</span><span class="s3">\&quot;</span><span class="s1">, style: { </span><span class="s3">\&quot;</span><span class="s1">TableHeader/...</span><span class="s3">\&quot;</span><span class="s1">: tags.heading } },</span><span class="s3">\n        \&quot;</span><span class="s1">TableRow</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">TableCell</span><span class="s3">\&quot;</span><span class="s1">, style: tags.content },</span><span class="s3">\n        </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">TableDelimiter</span><span class="s3">\&quot;</span><span class="s1">, style: tags.processingInstruction },</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">parseBlock: [{</span><span class="s3">\n            </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">Table</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">leaf(_, leaf) { return hasPipe(leaf.content, 0) ? new TableParser : null; },</span><span class="s3">\n            </span><span class="s1">endLeaf(cx, line, leaf) {</span><span class="s3">\n                </span><span class="s1">if (leaf.parsers.some(p =&gt; p instanceof TableParser) || !hasPipe(line.text, line.basePos))</span><span class="s3">\n                    </span><span class="s1">return false;</span><span class="s3">\n                </span><span class="s1">let next = cx.scanLine(cx.absoluteLineEnd + 1).text;</span><span class="s3">\n                </span><span class="s1">return delimiterLine.test(next) &amp;&amp; parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">before: </span><span class="s3">\&quot;</span><span class="s1">SetextHeading</span><span class="s3">\&quot;\n        </span><span class="s1">}]</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">class TaskParser {</span><span class="s3">\n    </span><span class="s1">nextLine() { return false; }</span><span class="s3">\n    </span><span class="s1">finish(cx, leaf) {</span><span class="s3">\n        </span><span class="s1">cx.addLeafElement(leaf, cx.elt(</span><span class="s3">\&quot;</span><span class="s1">Task</span><span class="s3">\&quot;</span><span class="s1">, leaf.start, leaf.start + leaf.content.length, [</span><span class="s3">\n            </span><span class="s1">cx.elt(</span><span class="s3">\&quot;</span><span class="s1">TaskMarker</span><span class="s3">\&quot;</span><span class="s1">, leaf.start, leaf.start + 3),</span><span class="s3">\n            </span><span class="s1">...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)</span><span class="s3">\n        </span><span class="s1">]));</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/// Extension providing</span><span class="s3">\n</span><span class="s1">/// [GFM-style](https://github.github.com/gfm/#task-list-items-extension-)</span><span class="s3">\n</span><span class="s1">/// task list items, where list items can be prefixed with `[ ]` or</span><span class="s3">\n</span><span class="s1">/// `[x]` to add a checkbox.</span><span class="s3">\n</span><span class="s1">const TaskList = {</span><span class="s3">\n    </span><span class="s1">defineNodes: [</span><span class="s3">\n        </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">Task</span><span class="s3">\&quot;</span><span class="s1">, block: true, style: tags.list },</span><span class="s3">\n        </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">TaskMarker</span><span class="s3">\&quot;</span><span class="s1">, style: tags.atom }</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">parseBlock: [{</span><span class="s3">\n            </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">TaskList</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">leaf(cx, leaf) {</span><span class="s3">\n                </span><span class="s1">return /^</span><span class="s3">\\</span><span class="s1">[[ xX]</span><span class="s3">\\</span><span class="s1">][ </span><span class="s3">\\</span><span class="s1">t]/.test(leaf.content) &amp;&amp; cx.parentType().name == </span><span class="s3">\&quot;</span><span class="s1">ListItem</span><span class="s3">\&quot; </span><span class="s1">? new TaskParser : null;</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">after: </span><span class="s3">\&quot;</span><span class="s1">SetextHeading</span><span class="s3">\&quot;\n        </span><span class="s1">}]</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const autolinkRE = /(www</span><span class="s3">\\</span><span class="s1">.)|(https?:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/)|([</span><span class="s3">\\</span><span class="s1">w.+-]+@)|(mailto:|xmpp:)/gy;</span><span class="s3">\n</span><span class="s1">const urlRE = /[</span><span class="s3">\\</span><span class="s1">w-]+(</span><span class="s3">\\</span><span class="s1">.[</span><span class="s3">\\</span><span class="s1">w-]+)+(</span><span class="s3">\\</span><span class="s1">/[^</span><span class="s3">\\</span><span class="s1">s&lt;]*)?/gy;</span><span class="s3">\n</span><span class="s1">const lastTwoDomainWords = /[</span><span class="s3">\\</span><span class="s1">w-]+</span><span class="s3">\\</span><span class="s1">.[</span><span class="s3">\\</span><span class="s1">w-]+($|</span><span class="s3">\\</span><span class="s1">/)/;</span><span class="s3">\n</span><span class="s1">const emailRE = /[</span><span class="s3">\\</span><span class="s1">w.+-]+@[</span><span class="s3">\\</span><span class="s1">w-]+(</span><span class="s3">\\</span><span class="s1">.[</span><span class="s3">\\</span><span class="s1">w.-]+)+/gy;</span><span class="s3">\n</span><span class="s1">const xmppResourceRE = /</span><span class="s3">\\</span><span class="s1">/[a-zA-Z</span><span class="s3">\\</span><span class="s1">d@.]+/gy;</span><span class="s3">\n</span><span class="s1">function count(str, from, to, ch) {</span><span class="s3">\n    </span><span class="s1">let result = 0;</span><span class="s3">\n    </span><span class="s1">for (let i = from; i &lt; to; i++)</span><span class="s3">\n        </span><span class="s1">if (str[i] == ch)</span><span class="s3">\n            </span><span class="s1">result++;</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function autolinkURLEnd(text, from) {</span><span class="s3">\n    </span><span class="s1">urlRE.lastIndex = from;</span><span class="s3">\n    </span><span class="s1">let m = urlRE.exec(text);</span><span class="s3">\n    </span><span class="s1">if (!m || lastTwoDomainWords.exec(m[0])[0].indexOf(</span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">) &gt; -1)</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">let end = from + m[0].length;</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">let last = text[end - 1], m;</span><span class="s3">\n        </span><span class="s1">if (/[?!.,:*_~]/.test(last) ||</span><span class="s3">\n            </span><span class="s1">last == </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; count(text, from, end, </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) &gt; count(text, from, end, </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n            </span><span class="s1">end--;</span><span class="s3">\n        </span><span class="s1">else if (last == </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; (m = /&amp;(?:#</span><span class="s3">\\</span><span class="s1">d+|#x[a-f</span><span class="s3">\\</span><span class="s1">d]+|</span><span class="s3">\\</span><span class="s1">w+);$/.exec(text.slice(from, end))))</span><span class="s3">\n            </span><span class="s1">end = from + m.index;</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return end;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function autolinkEmailEnd(text, from) {</span><span class="s3">\n    </span><span class="s1">emailRE.lastIndex = from;</span><span class="s3">\n    </span><span class="s1">let m = emailRE.exec(text);</span><span class="s3">\n    </span><span class="s1">if (!m)</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">let last = m[0][m[0].length - 1];</span><span class="s3">\n    </span><span class="s1">return last == </span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot; </span><span class="s1">|| last == </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot; </span><span class="s1">? -1 : from + m[0].length - (last == </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">? 1 : 0);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/// Extension that implements autolinking for</span><span class="s3">\n</span><span class="s1">/// `www.`/`http://`/`https://`/`mailto:`/`xmpp:` URLs and email</span><span class="s3">\n</span><span class="s1">/// addresses.</span><span class="s3">\n</span><span class="s1">const Autolink = {</span><span class="s3">\n    </span><span class="s1">parseInline: [{</span><span class="s3">\n            </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">Autolink</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">parse(cx, next, absPos) {</span><span class="s3">\n                </span><span class="s1">let pos = absPos - cx.offset;</span><span class="s3">\n                </span><span class="s1">autolinkRE.lastIndex = pos;</span><span class="s3">\n                </span><span class="s1">let m = autolinkRE.exec(cx.text), end = -1;</span><span class="s3">\n                </span><span class="s1">if (!m)</span><span class="s3">\n                    </span><span class="s1">return -1;</span><span class="s3">\n                </span><span class="s1">if (m[1] || m[2]) { // www., http://</span><span class="s3">\n                    </span><span class="s1">end = autolinkURLEnd(cx.text, pos + m[0].length);</span><span class="s3">\n                    </span><span class="s1">if (end &gt; -1 &amp;&amp; cx.hasOpenLink) {</span><span class="s3">\n                        </span><span class="s1">let noBracket = /([^</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]]|</span><span class="s3">\\</span><span class="s1">[[^</span><span class="s3">\\</span><span class="s1">]]*</span><span class="s3">\\</span><span class="s1">])*/.exec(cx.text.slice(pos, end));</span><span class="s3">\n                        </span><span class="s1">end = pos + noBracket[0].length;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (m[3]) { // email address</span><span class="s3">\n                    </span><span class="s1">end = autolinkEmailEnd(cx.text, pos);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else { // mailto:/xmpp:</span><span class="s3">\n                    </span><span class="s1">end = autolinkEmailEnd(cx.text, pos + m[0].length);</span><span class="s3">\n                    </span><span class="s1">if (end &gt; -1 &amp;&amp; m[0] == </span><span class="s3">\&quot;</span><span class="s1">xmpp:</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                        </span><span class="s1">xmppResourceRE.lastIndex = end;</span><span class="s3">\n                        </span><span class="s1">m = xmppResourceRE.exec(cx.text);</span><span class="s3">\n                        </span><span class="s1">if (m)</span><span class="s3">\n                            </span><span class="s1">end = m.index + m[0].length;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (end &lt; 0)</span><span class="s3">\n                    </span><span class="s1">return -1;</span><span class="s3">\n                </span><span class="s1">cx.addElement(cx.elt(</span><span class="s3">\&quot;</span><span class="s1">URL</span><span class="s3">\&quot;</span><span class="s1">, absPos, end + cx.offset));</span><span class="s3">\n                </span><span class="s1">return end + cx.offset;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}]</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/// Extension bundle containing [`Table`](#Table),</span><span class="s3">\n</span><span class="s1">/// [`TaskList`](#TaskList), [`Strikethrough`](#Strikethrough), and</span><span class="s3">\n</span><span class="s1">/// [`Autolink`](#Autolink).</span><span class="s3">\n</span><span class="s1">const GFM = [Table, TaskList, Strikethrough, Autolink];</span><span class="s3">\n</span><span class="s1">function parseSubSuper(ch, node, mark) {</span><span class="s3">\n    </span><span class="s1">return (cx, next, pos) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (next != ch || cx.char(pos + 1) == ch)</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">let elts = [cx.elt(mark, pos, pos + 1)];</span><span class="s3">\n        </span><span class="s1">for (let i = pos + 1; i &lt; cx.end; i++) {</span><span class="s3">\n            </span><span class="s1">let next = cx.char(i);</span><span class="s3">\n            </span><span class="s1">if (next == ch)</span><span class="s3">\n                </span><span class="s1">return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));</span><span class="s3">\n            </span><span class="s1">if (next == 92 /* '</span><span class="s3">\\\\</span><span class="s1">' */)</span><span class="s3">\n                </span><span class="s1">elts.push(cx.elt(</span><span class="s3">\&quot;</span><span class="s1">Escape</span><span class="s3">\&quot;</span><span class="s1">, i, i++ + 2));</span><span class="s3">\n            </span><span class="s1">if (space(next))</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/// Extension providing</span><span class="s3">\n</span><span class="s1">/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)</span><span class="s3">\n</span><span class="s1">/// superscript using `^` markers.</span><span class="s3">\n</span><span class="s1">const Superscript = {</span><span class="s3">\n    </span><span class="s1">defineNodes: [</span><span class="s3">\n        </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">Superscript</span><span class="s3">\&quot;</span><span class="s1">, style: tags.special(tags.content) },</span><span class="s3">\n        </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">SuperscriptMark</span><span class="s3">\&quot;</span><span class="s1">, style: tags.processingInstruction }</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">parseInline: [{</span><span class="s3">\n            </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">Superscript</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">parse: parseSubSuper(94 /* '^' */, </span><span class="s3">\&quot;</span><span class="s1">Superscript</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">SuperscriptMark</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}]</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/// Extension providing</span><span class="s3">\n</span><span class="s1">/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)</span><span class="s3">\n</span><span class="s1">/// subscript using `~` markers.</span><span class="s3">\n</span><span class="s1">const Subscript = {</span><span class="s3">\n    </span><span class="s1">defineNodes: [</span><span class="s3">\n        </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">Subscript</span><span class="s3">\&quot;</span><span class="s1">, style: tags.special(tags.content) },</span><span class="s3">\n        </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">SubscriptMark</span><span class="s3">\&quot;</span><span class="s1">, style: tags.processingInstruction }</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">parseInline: [{</span><span class="s3">\n            </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">Subscript</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">parse: parseSubSuper(126 /* '~' */, </span><span class="s3">\&quot;</span><span class="s1">Subscript</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">SubscriptMark</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}]</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/// Extension that parses two colons with only letters, underscores,</span><span class="s3">\n</span><span class="s1">/// and numbers between them as `Emoji` nodes.</span><span class="s3">\n</span><span class="s1">const Emoji = {</span><span class="s3">\n    </span><span class="s1">defineNodes: [{ name: </span><span class="s3">\&quot;</span><span class="s1">Emoji</span><span class="s3">\&quot;</span><span class="s1">, style: tags.character }],</span><span class="s3">\n    </span><span class="s1">parseInline: [{</span><span class="s3">\n            </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">Emoji</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">parse(cx, next, pos) {</span><span class="s3">\n                </span><span class="s1">let match;</span><span class="s3">\n                </span><span class="s1">if (next != 58 /* ':' */ || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))</span><span class="s3">\n                    </span><span class="s1">return -1;</span><span class="s3">\n                </span><span class="s1">return cx.addElement(cx.elt(</span><span class="s3">\&quot;</span><span class="s1">Emoji</span><span class="s3">\&quot;</span><span class="s1">, pos, pos + 1 + match[0].length));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}]</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export { Autolink, BlockContext, Element, Emoji, GFM, InlineContext, LeafBlock, Line, MarkdownParser, Strikethrough, Subscript, Superscript, Table, TaskList, parseCode, parser };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { EditorSelection, countColumn, Prec, EditorState } from '@codemirror/state';</span><span class="s3">\n</span><span class="s1">import { keymap } from '@codemirror/view';</span><span class="s3">\n</span><span class="s1">import { defineLanguageFacet, foldNodeProp, indentNodeProp, languageDataProp, foldService, syntaxTree, Language, LanguageDescription, ParseContext, indentUnit, LanguageSupport } from '@codemirror/language';</span><span class="s3">\n</span><span class="s1">import { CompletionContext } from '@codemirror/autocomplete';</span><span class="s3">\n</span><span class="s1">import { parser, GFM, Subscript, Superscript, Emoji, MarkdownParser, parseCode } from '@lezer/markdown';</span><span class="s3">\n</span><span class="s1">import { html, htmlCompletionSource } from '@codemirror/lang-html';</span><span class="s3">\n</span><span class="s1">import { NodeProp } from '@lezer/common';</span><span class="s3">\n\n</span><span class="s1">const data = /*@__PURE__*/defineLanguageFacet({ commentTokens: { block: { open: </span><span class="s3">\&quot;</span><span class="s1">&lt;!--</span><span class="s3">\&quot;</span><span class="s1">, close: </span><span class="s3">\&quot;</span><span class="s1">--&gt;</span><span class="s3">\&quot; </span><span class="s1">} } });</span><span class="s3">\n</span><span class="s1">const headingProp = /*@__PURE__*/new NodeProp();</span><span class="s3">\n</span><span class="s1">const commonmark = /*@__PURE__*/parser.configure({</span><span class="s3">\n    </span><span class="s1">props: [</span><span class="s3">\n        </span><span class="s1">/*@__PURE__*/foldNodeProp.add(type =&gt; {</span><span class="s3">\n            </span><span class="s1">return !type.is(</span><span class="s3">\&quot;</span><span class="s1">Block</span><span class="s3">\&quot;</span><span class="s1">) || type.is(</span><span class="s3">\&quot;</span><span class="s1">Document</span><span class="s3">\&quot;</span><span class="s1">) || isHeading(type) != null || isList(type) ? undefined</span><span class="s3">\n                </span><span class="s1">: (tree, state) =&gt; ({ from: state.doc.lineAt(tree.from).to, to: tree.to });</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">/*@__PURE__*/headingProp.add(isHeading),</span><span class="s3">\n        </span><span class="s1">/*@__PURE__*/indentNodeProp.add({</span><span class="s3">\n            </span><span class="s1">Document: () =&gt; null</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">/*@__PURE__*/languageDataProp.add({</span><span class="s3">\n            </span><span class="s1">Document: data</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">function isHeading(type) {</span><span class="s3">\n    </span><span class="s1">let match = /^(?:ATX|Setext)Heading(</span><span class="s3">\\</span><span class="s1">d)$/.exec(type.name);</span><span class="s3">\n    </span><span class="s1">return match ? +match[1] : undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isList(type) {</span><span class="s3">\n    </span><span class="s1">return type.name == </span><span class="s3">\&quot;</span><span class="s1">OrderedList</span><span class="s3">\&quot; </span><span class="s1">|| type.name == </span><span class="s3">\&quot;</span><span class="s1">BulletList</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findSectionEnd(headerNode, level) {</span><span class="s3">\n    </span><span class="s1">let last = headerNode;</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">let next = last.nextSibling, heading;</span><span class="s3">\n        </span><span class="s1">if (!next || (heading = isHeading(next.type)) != null &amp;&amp; heading &lt;= level)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">last = next;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return last.to;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const headerIndent = /*@__PURE__*/foldService.of((state, start, end) =&gt; {</span><span class="s3">\n    </span><span class="s1">for (let node = syntaxTree(state).resolveInner(end, -1); node; node = node.parent) {</span><span class="s3">\n        </span><span class="s1">if (node.from &lt; start)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">let heading = node.type.prop(headingProp);</span><span class="s3">\n        </span><span class="s1">if (heading == null)</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">let upto = findSectionEnd(node, heading);</span><span class="s3">\n        </span><span class="s1">if (upto &gt; end)</span><span class="s3">\n            </span><span class="s1">return { from: end, to: upto };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">function mkLang(parser) {</span><span class="s3">\n    </span><span class="s1">return new Language(data, parser, [headerIndent], </span><span class="s3">\&quot;</span><span class="s1">markdown</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Language support for strict CommonMark.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const commonmarkLanguage = /*@__PURE__*/mkLang(commonmark);</span><span class="s3">\n</span><span class="s1">const extended = /*@__PURE__*/commonmark.configure([GFM, Subscript, Superscript, Emoji, {</span><span class="s3">\n        </span><span class="s1">props: [</span><span class="s3">\n            </span><span class="s1">/*@__PURE__*/foldNodeProp.add({</span><span class="s3">\n                </span><span class="s1">Table: (tree, state) =&gt; ({ from: state.doc.lineAt(tree.from).to, to: tree.to })</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">]</span><span class="s3">\n    </span><span class="s1">}]);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Language support for [GFM](https://github.github.com/gfm/) plus</span><span class="s3">\n</span><span class="s1">subscript, superscript, and emoji syntax.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const markdownLanguage = /*@__PURE__*/mkLang(extended);</span><span class="s3">\n</span><span class="s1">function getCodeParser(languages, defaultLanguage) {</span><span class="s3">\n    </span><span class="s1">return (info) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (info &amp;&amp; languages) {</span><span class="s3">\n            </span><span class="s1">let found = null;</span><span class="s3">\n            </span><span class="s1">// Strip anything after whitespace</span><span class="s3">\n            </span><span class="s1">info = /</span><span class="s3">\\</span><span class="s1">S*/.exec(info)[0];</span><span class="s3">\n            </span><span class="s1">if (typeof languages == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">found = languages(info);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">found = LanguageDescription.matchLanguageName(languages, info, true);</span><span class="s3">\n            </span><span class="s1">if (found instanceof LanguageDescription)</span><span class="s3">\n                </span><span class="s1">return found.support ? found.support.language.parser : ParseContext.getSkippingParser(found.load());</span><span class="s3">\n            </span><span class="s1">else if (found)</span><span class="s3">\n                </span><span class="s1">return found.parser;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return defaultLanguage ? defaultLanguage.parser : null;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class Context {</span><span class="s3">\n    </span><span class="s1">constructor(node, from, to, spaceBefore, spaceAfter, type, item) {</span><span class="s3">\n        </span><span class="s1">this.node = node;</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n        </span><span class="s1">this.spaceBefore = spaceBefore;</span><span class="s3">\n        </span><span class="s1">this.spaceAfter = spaceAfter;</span><span class="s3">\n        </span><span class="s1">this.type = type;</span><span class="s3">\n        </span><span class="s1">this.item = item;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">blank(maxWidth, trailing = true) {</span><span class="s3">\n        </span><span class="s1">let result = this.spaceBefore + (this.node.name == </span><span class="s3">\&quot;</span><span class="s1">Blockquote</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (maxWidth != null) {</span><span class="s3">\n            </span><span class="s1">while (result.length &lt; maxWidth)</span><span class="s3">\n                </span><span class="s1">result += </span><span class="s3">\&quot; \&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">for (let i = this.to - this.from - result.length - this.spaceAfter.length; i &gt; 0; i--)</span><span class="s3">\n                </span><span class="s1">result += </span><span class="s3">\&quot; \&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">return result + (trailing ? this.spaceAfter : </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">marker(doc, add) {</span><span class="s3">\n        </span><span class="s1">let number = this.node.name == </span><span class="s3">\&quot;</span><span class="s1">OrderedList</span><span class="s3">\&quot; </span><span class="s1">? String((+itemNumber(this.item, doc)[2] + add)) : </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">return this.spaceBefore + number + this.type + this.spaceAfter;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getContext(node, doc) {</span><span class="s3">\n    </span><span class="s1">let nodes = [];</span><span class="s3">\n    </span><span class="s1">for (let cur = node; cur; cur = cur.parent) {</span><span class="s3">\n        </span><span class="s1">if (cur.name == </span><span class="s3">\&quot;</span><span class="s1">ListItem</span><span class="s3">\&quot; </span><span class="s1">|| cur.name == </span><span class="s3">\&quot;</span><span class="s1">Blockquote</span><span class="s3">\&quot; </span><span class="s1">|| cur.name == </span><span class="s3">\&quot;</span><span class="s1">FencedCode</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">nodes.push(cur);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let context = [];</span><span class="s3">\n    </span><span class="s1">for (let i = nodes.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n        </span><span class="s1">let node = nodes[i], match;</span><span class="s3">\n        </span><span class="s1">let line = doc.lineAt(node.from), startPos = node.from - line.from;</span><span class="s3">\n        </span><span class="s1">if (node.name == </span><span class="s3">\&quot;</span><span class="s1">FencedCode</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">context.push(new Context(node, startPos, startPos, </span><span class="s3">\&quot;\&quot;</span><span class="s1">, </span><span class="s3">\&quot;\&quot;</span><span class="s1">, </span><span class="s3">\&quot;\&quot;</span><span class="s1">, null));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (node.name == </span><span class="s3">\&quot;</span><span class="s1">Blockquote</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; (match = /^ *&gt;( ?)/.exec(line.text.slice(startPos)))) {</span><span class="s3">\n            </span><span class="s1">context.push(new Context(node, startPos, startPos + match[0].length, </span><span class="s3">\&quot;\&quot;</span><span class="s1">, match[1], </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">, null));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (node.name == </span><span class="s3">\&quot;</span><span class="s1">ListItem</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; node.parent.name == </span><span class="s3">\&quot;</span><span class="s1">OrderedList</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n            </span><span class="s1">(match = /^( *)</span><span class="s3">\\</span><span class="s1">d+([.)])( *)/.exec(line.text.slice(startPos)))) {</span><span class="s3">\n            </span><span class="s1">let after = match[3], len = match[0].length;</span><span class="s3">\n            </span><span class="s1">if (after.length &gt;= 4) {</span><span class="s3">\n                </span><span class="s1">after = after.slice(0, after.length - 4);</span><span class="s3">\n                </span><span class="s1">len -= 4;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">context.push(new Context(node.parent, startPos, startPos + len, match[1], after, match[2], node));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (node.name == </span><span class="s3">\&quot;</span><span class="s1">ListItem</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; node.parent.name == </span><span class="s3">\&quot;</span><span class="s1">BulletList</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n            </span><span class="s1">(match = /^( *)([-+*])( {1,4}</span><span class="s3">\\</span><span class="s1">[[ xX]</span><span class="s3">\\</span><span class="s1">])?( +)/.exec(line.text.slice(startPos)))) {</span><span class="s3">\n            </span><span class="s1">let after = match[4], len = match[0].length;</span><span class="s3">\n            </span><span class="s1">if (after.length &gt; 4) {</span><span class="s3">\n                </span><span class="s1">after = after.slice(0, after.length - 4);</span><span class="s3">\n                </span><span class="s1">len -= 4;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let type = match[2];</span><span class="s3">\n            </span><span class="s1">if (match[3])</span><span class="s3">\n                </span><span class="s1">type += match[3].replace(/[xX]/, ' ');</span><span class="s3">\n            </span><span class="s1">context.push(new Context(node.parent, startPos, startPos + len, match[1], after, type, node));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return context;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function itemNumber(item, doc) {</span><span class="s3">\n    </span><span class="s1">return /^(</span><span class="s3">\\</span><span class="s1">s*)(</span><span class="s3">\\</span><span class="s1">d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function renumberList(after, doc, changes, offset = 0) {</span><span class="s3">\n    </span><span class="s1">for (let prev = -1, node = after;;) {</span><span class="s3">\n        </span><span class="s1">if (node.name == </span><span class="s3">\&quot;</span><span class="s1">ListItem</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">let m = itemNumber(node, doc);</span><span class="s3">\n            </span><span class="s1">let number = +m[2];</span><span class="s3">\n            </span><span class="s1">if (prev &gt;= 0) {</span><span class="s3">\n                </span><span class="s1">if (number != prev + 1)</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">prev = number;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let next = node.nextSibling;</span><span class="s3">\n        </span><span class="s1">if (!next)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">node = next;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function normalizeIndent(content, state) {</span><span class="s3">\n    </span><span class="s1">let blank = /^[ </span><span class="s3">\\</span><span class="s1">t]*/.exec(content)[0].length;</span><span class="s3">\n    </span><span class="s1">if (!blank || state.facet(indentUnit) != </span><span class="s3">\&quot;\\</span><span class="s1">t</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return content;</span><span class="s3">\n    </span><span class="s1">let col = countColumn(content, 4, blank);</span><span class="s3">\n    </span><span class="s1">let space = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">for (let i = col; i &gt; 0;) {</span><span class="s3">\n        </span><span class="s1">if (i &gt;= 4) {</span><span class="s3">\n            </span><span class="s1">space += </span><span class="s3">\&quot;\\</span><span class="s1">t</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">i -= 4;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">space += </span><span class="s3">\&quot; \&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">i--;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return space + content.slice(blank);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">This command, when invoked in Markdown context with cursor</span><span class="s3">\n</span><span class="s1">selection(s), will create a new line with the markup for</span><span class="s3">\n</span><span class="s1">blockquotes and lists that were active on the old line. If the</span><span class="s3">\n</span><span class="s1">cursor was directly after the end of the markup for the old line,</span><span class="s3">\n</span><span class="s1">trailing whitespace and list markers are removed from that line.</span><span class="s3">\n\n</span><span class="s1">The command does nothing in non-Markdown context, so it should</span><span class="s3">\n</span><span class="s1">not be used as the only binding for Enter (even in a Markdown</span><span class="s3">\n</span><span class="s1">document, HTML and code regions might use a different language).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const insertNewlineContinueMarkup = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">let tree = syntaxTree(state), { doc } = state;</span><span class="s3">\n    </span><span class="s1">let dont = null, changes = state.changeByRange(range =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!range.empty || !markdownLanguage.isActiveAt(state, range.from, 0))</span><span class="s3">\n            </span><span class="s1">return dont = { range };</span><span class="s3">\n        </span><span class="s1">let pos = range.from, line = doc.lineAt(pos);</span><span class="s3">\n        </span><span class="s1">let context = getContext(tree.resolveInner(pos, -1), doc);</span><span class="s3">\n        </span><span class="s1">while (context.length &amp;&amp; context[context.length - 1].from &gt; pos - line.from)</span><span class="s3">\n            </span><span class="s1">context.pop();</span><span class="s3">\n        </span><span class="s1">if (!context.length)</span><span class="s3">\n            </span><span class="s1">return dont = { range };</span><span class="s3">\n        </span><span class="s1">let inner = context[context.length - 1];</span><span class="s3">\n        </span><span class="s1">if (inner.to - inner.spaceAfter.length &gt; pos - line.from)</span><span class="s3">\n            </span><span class="s1">return dont = { range };</span><span class="s3">\n        </span><span class="s1">let emptyLine = pos &gt;= (inner.to - inner.spaceAfter.length) &amp;&amp; !/</span><span class="s3">\\</span><span class="s1">S/.test(line.text.slice(inner.to));</span><span class="s3">\n        </span><span class="s1">// Empty line in list</span><span class="s3">\n        </span><span class="s1">if (inner.item &amp;&amp; emptyLine) {</span><span class="s3">\n            </span><span class="s1">let first = inner.node.firstChild, second = inner.node.getChild(</span><span class="s3">\&quot;</span><span class="s1">ListItem</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">ListItem</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">// Not second item or blank line before: delete a level of markup</span><span class="s3">\n            </span><span class="s1">if (first.to &gt;= pos || second &amp;&amp; second.to &lt; pos ||</span><span class="s3">\n                </span><span class="s1">line.from &gt; 0 &amp;&amp; !/[^</span><span class="s3">\\</span><span class="s1">s&gt;]/.test(doc.lineAt(line.from - 1).text)) {</span><span class="s3">\n                </span><span class="s1">let next = context.length &gt; 1 ? context[context.length - 2] : null;</span><span class="s3">\n                </span><span class="s1">let delTo, insert = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">if (next &amp;&amp; next.item) { // Re-add marker for the list at the next level</span><span class="s3">\n                    </span><span class="s1">delTo = line.from + next.from;</span><span class="s3">\n                    </span><span class="s1">insert = next.marker(doc, 1);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">delTo = line.from + (next ? next.to : 0);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">let changes = [{ from: delTo, to: pos, insert }];</span><span class="s3">\n                </span><span class="s1">if (inner.node.name == </span><span class="s3">\&quot;</span><span class="s1">OrderedList</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                    </span><span class="s1">renumberList(inner.item, doc, changes, -2);</span><span class="s3">\n                </span><span class="s1">if (next &amp;&amp; next.node.name == </span><span class="s3">\&quot;</span><span class="s1">OrderedList</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                    </span><span class="s1">renumberList(next.item, doc, changes);</span><span class="s3">\n                </span><span class="s1">return { range: EditorSelection.cursor(delTo + insert.length), changes };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else { // Move second item down, making tight two-item list non-tight</span><span class="s3">\n                </span><span class="s1">let insert = blankLine(context, state, line);</span><span class="s3">\n                </span><span class="s1">return { range: EditorSelection.cursor(pos + insert.length + 1),</span><span class="s3">\n                    </span><span class="s1">changes: { from: line.from, insert: insert + state.lineBreak } };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (inner.node.name == </span><span class="s3">\&quot;</span><span class="s1">Blockquote</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; emptyLine &amp;&amp; line.from) {</span><span class="s3">\n            </span><span class="s1">let prevLine = doc.lineAt(line.from - 1), quoted = /&gt;</span><span class="s3">\\</span><span class="s1">s*$/.exec(prevLine.text);</span><span class="s3">\n            </span><span class="s1">// Two aligned empty quoted lines in a row</span><span class="s3">\n            </span><span class="s1">if (quoted &amp;&amp; quoted.index == inner.from) {</span><span class="s3">\n                </span><span class="s1">let changes = state.changes([{ from: prevLine.from + quoted.index, to: prevLine.to },</span><span class="s3">\n                    </span><span class="s1">{ from: line.from + inner.from, to: line.to }]);</span><span class="s3">\n                </span><span class="s1">return { range: range.map(changes), changes };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let changes = [];</span><span class="s3">\n        </span><span class="s1">if (inner.node.name == </span><span class="s3">\&quot;</span><span class="s1">OrderedList</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">renumberList(inner.item, doc, changes);</span><span class="s3">\n        </span><span class="s1">let continued = inner.item &amp;&amp; inner.item.from &lt; line.from;</span><span class="s3">\n        </span><span class="s1">let insert = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">// If not dedented</span><span class="s3">\n        </span><span class="s1">if (!continued || /^[</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">d.)</span><span class="s3">\\</span><span class="s1">-+*&gt;]*/.exec(line.text)[0].length &gt;= inner.to) {</span><span class="s3">\n            </span><span class="s1">for (let i = 0, e = context.length - 1; i &lt;= e; i++) {</span><span class="s3">\n                </span><span class="s1">insert += i == e &amp;&amp; !continued ? context[i].marker(doc, 1)</span><span class="s3">\n                    </span><span class="s1">: context[i].blank(i &lt; e ? countColumn(line.text, 4, context[i + 1].from) - insert.length : null);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let from = pos;</span><span class="s3">\n        </span><span class="s1">while (from &gt; line.from &amp;&amp; /</span><span class="s3">\\</span><span class="s1">s/.test(line.text.charAt(from - line.from - 1)))</span><span class="s3">\n            </span><span class="s1">from--;</span><span class="s3">\n        </span><span class="s1">insert = normalizeIndent(insert, state);</span><span class="s3">\n        </span><span class="s1">if (nonTightList(inner.node, state.doc))</span><span class="s3">\n            </span><span class="s1">insert = blankLine(context, state, line) + state.lineBreak + insert;</span><span class="s3">\n        </span><span class="s1">changes.push({ from, to: pos, insert: state.lineBreak + insert });</span><span class="s3">\n        </span><span class="s1">return { range: EditorSelection.cursor(from + insert.length + 1), changes };</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (dont)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">dispatch(state.update(changes, { scrollIntoView: true, userEvent: </span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot; </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function isMark(node) {</span><span class="s3">\n    </span><span class="s1">return node.name == </span><span class="s3">\&quot;</span><span class="s1">QuoteMark</span><span class="s3">\&quot; </span><span class="s1">|| node.name == </span><span class="s3">\&quot;</span><span class="s1">ListMark</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function nonTightList(node, doc) {</span><span class="s3">\n    </span><span class="s1">if (node.name != </span><span class="s3">\&quot;</span><span class="s1">OrderedList</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; node.name != </span><span class="s3">\&quot;</span><span class="s1">BulletList</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let first = node.firstChild, second = node.getChild(</span><span class="s3">\&quot;</span><span class="s1">ListItem</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">ListItem</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (!second)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let line1 = doc.lineAt(first.to), line2 = doc.lineAt(second.from);</span><span class="s3">\n    </span><span class="s1">let empty = /^[</span><span class="s3">\\</span><span class="s1">s&gt;]*$/.test(line1.text);</span><span class="s3">\n    </span><span class="s1">return line1.number + (empty ? 0 : 1) &lt; line2.number;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function blankLine(context, state, line) {</span><span class="s3">\n    </span><span class="s1">let insert = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">for (let i = 0, e = context.length - 2; i &lt;= e; i++) {</span><span class="s3">\n        </span><span class="s1">insert += context[i].blank(i &lt; e ? countColumn(line.text, 4, context[i + 1].from) - insert.length : null, i &lt; e);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return normalizeIndent(insert, state);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function contextNodeForDelete(tree, pos) {</span><span class="s3">\n    </span><span class="s1">let node = tree.resolveInner(pos, -1), scan = pos;</span><span class="s3">\n    </span><span class="s1">if (isMark(node)) {</span><span class="s3">\n        </span><span class="s1">scan = node.from;</span><span class="s3">\n        </span><span class="s1">node = node.parent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (let prev; prev = node.childBefore(scan);) {</span><span class="s3">\n        </span><span class="s1">if (isMark(prev)) {</span><span class="s3">\n            </span><span class="s1">scan = prev.from;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prev.name == </span><span class="s3">\&quot;</span><span class="s1">OrderedList</span><span class="s3">\&quot; </span><span class="s1">|| prev.name == </span><span class="s3">\&quot;</span><span class="s1">BulletList</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">node = prev.lastChild;</span><span class="s3">\n            </span><span class="s1">scan = node.to;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">This command will, when invoked in a Markdown context with the</span><span class="s3">\n</span><span class="s1">cursor directly after list or blockquote markup, delete one level</span><span class="s3">\n</span><span class="s1">of markup. When the markup is for a list, it will be replaced by</span><span class="s3">\n</span><span class="s1">spaces on the first invocation (a further invocation will delete</span><span class="s3">\n</span><span class="s1">the spaces), to make it easy to continue a list.</span><span class="s3">\n\n</span><span class="s1">When not after Markdown block markup, this command will return</span><span class="s3">\n</span><span class="s1">false, so it is intended to be bound alongside other deletion</span><span class="s3">\n</span><span class="s1">commands, with a higher precedence than the more generic commands.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const deleteMarkupBackward = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">let tree = syntaxTree(state);</span><span class="s3">\n    </span><span class="s1">let dont = null, changes = state.changeByRange(range =&gt; {</span><span class="s3">\n        </span><span class="s1">let pos = range.from, { doc } = state;</span><span class="s3">\n        </span><span class="s1">if (range.empty &amp;&amp; markdownLanguage.isActiveAt(state, range.from)) {</span><span class="s3">\n            </span><span class="s1">let line = doc.lineAt(pos);</span><span class="s3">\n            </span><span class="s1">let context = getContext(contextNodeForDelete(tree, pos), doc);</span><span class="s3">\n            </span><span class="s1">if (context.length) {</span><span class="s3">\n                </span><span class="s1">let inner = context[context.length - 1];</span><span class="s3">\n                </span><span class="s1">let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);</span><span class="s3">\n                </span><span class="s1">// Delete extra trailing space after markup</span><span class="s3">\n                </span><span class="s1">if (pos - line.from &gt; spaceEnd &amp;&amp; !/</span><span class="s3">\\</span><span class="s1">S/.test(line.text.slice(spaceEnd, pos - line.from)))</span><span class="s3">\n                    </span><span class="s1">return { range: EditorSelection.cursor(line.from + spaceEnd),</span><span class="s3">\n                        </span><span class="s1">changes: { from: line.from + spaceEnd, to: pos } };</span><span class="s3">\n                </span><span class="s1">if (pos - line.from == spaceEnd &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">// Only apply this if we're on the line that has the</span><span class="s3">\n                    </span><span class="s1">// construct's syntax, or there's only indentation in the</span><span class="s3">\n                    </span><span class="s1">// target range</span><span class="s3">\n                    </span><span class="s1">(!inner.item || line.from &lt;= inner.item.from || !/</span><span class="s3">\\</span><span class="s1">S/.test(line.text.slice(0, inner.to)))) {</span><span class="s3">\n                    </span><span class="s1">let start = line.from + inner.from;</span><span class="s3">\n                    </span><span class="s1">// Replace a list item marker with blank space</span><span class="s3">\n                    </span><span class="s1">if (inner.item &amp;&amp; inner.node.from &lt; inner.item.from &amp;&amp; /</span><span class="s3">\\</span><span class="s1">S/.test(line.text.slice(inner.from, inner.to))) {</span><span class="s3">\n                        </span><span class="s1">let insert = inner.blank(countColumn(line.text, 4, inner.to) - countColumn(line.text, 4, inner.from));</span><span class="s3">\n                        </span><span class="s1">if (start == line.from)</span><span class="s3">\n                            </span><span class="s1">insert = normalizeIndent(insert, state);</span><span class="s3">\n                        </span><span class="s1">return { range: EditorSelection.cursor(start + insert.length),</span><span class="s3">\n                            </span><span class="s1">changes: { from: start, to: line.from + inner.to, insert } };</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">// Delete one level of indentation</span><span class="s3">\n                    </span><span class="s1">if (start &lt; pos)</span><span class="s3">\n                        </span><span class="s1">return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } };</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return dont = { range };</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (dont)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">dispatch(state.update(changes, { scrollIntoView: true, userEvent: </span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot; </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A small keymap with Markdown-specific bindings. Binds Enter to</span><span class="s3">\n</span><span class="s1">[`insertNewlineContinueMarkup`](https://codemirror.net/6/docs/ref/#lang-markdown.insertNewlineContinueMarkup)</span><span class="s3">\n</span><span class="s1">and Backspace to</span><span class="s3">\n</span><span class="s1">[`deleteMarkupBackward`](https://codemirror.net/6/docs/ref/#lang-markdown.deleteMarkupBackward).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const markdownKeymap = [</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Enter</span><span class="s3">\&quot;</span><span class="s1">, run: insertNewlineContinueMarkup },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Backspace</span><span class="s3">\&quot;</span><span class="s1">, run: deleteMarkupBackward }</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">const htmlNoMatch = /*@__PURE__*/html({ matchClosingTags: false });</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Markdown language support.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function markdown(config = {}) {</span><span class="s3">\n    </span><span class="s1">let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser } = commonmarkLanguage, completeHTMLTags = true, htmlTagLanguage = htmlNoMatch } = config;</span><span class="s3">\n    </span><span class="s1">if (!(parser instanceof MarkdownParser))</span><span class="s3">\n        </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Base parser provided to `markdown` should be a Markdown parser</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">let extensions = config.extensions ? [config.extensions] : [];</span><span class="s3">\n    </span><span class="s1">let support = [htmlTagLanguage.support], defaultCode;</span><span class="s3">\n    </span><span class="s1">if (defaultCodeLanguage instanceof LanguageSupport) {</span><span class="s3">\n        </span><span class="s1">support.push(defaultCodeLanguage.support);</span><span class="s3">\n        </span><span class="s1">defaultCode = defaultCodeLanguage.language;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (defaultCodeLanguage) {</span><span class="s3">\n        </span><span class="s1">defaultCode = defaultCodeLanguage;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : undefined;</span><span class="s3">\n    </span><span class="s1">extensions.push(parseCode({ codeParser, htmlParser: htmlTagLanguage.language.parser }));</span><span class="s3">\n    </span><span class="s1">if (addKeymap)</span><span class="s3">\n        </span><span class="s1">support.push(Prec.high(keymap.of(markdownKeymap)));</span><span class="s3">\n    </span><span class="s1">let lang = mkLang(parser.configure(extensions));</span><span class="s3">\n    </span><span class="s1">if (completeHTMLTags)</span><span class="s3">\n        </span><span class="s1">support.push(lang.data.of({ autocomplete: htmlTagCompletion }));</span><span class="s3">\n    </span><span class="s1">return new LanguageSupport(lang, support);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function htmlTagCompletion(context) {</span><span class="s3">\n    </span><span class="s1">let { state, pos } = context, m = /&lt;[:</span><span class="s3">\\</span><span class="s1">-</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">u00b7-</span><span class="s3">\\</span><span class="s1">uffff]*$/.exec(state.sliceDoc(pos - 25, pos));</span><span class="s3">\n    </span><span class="s1">if (!m)</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">let tree = syntaxTree(state).resolveInner(pos, -1);</span><span class="s3">\n    </span><span class="s1">while (tree &amp;&amp; !tree.type.isTop) {</span><span class="s3">\n        </span><span class="s1">if (tree.name == </span><span class="s3">\&quot;</span><span class="s1">CodeBlock</span><span class="s3">\&quot; </span><span class="s1">|| tree.name == </span><span class="s3">\&quot;</span><span class="s1">FencedCode</span><span class="s3">\&quot; </span><span class="s1">|| tree.name == </span><span class="s3">\&quot;</span><span class="s1">ProcessingInstructionBlock</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n            </span><span class="s1">tree.name == </span><span class="s3">\&quot;</span><span class="s1">CommentBlock</span><span class="s3">\&quot; </span><span class="s1">|| tree.name == </span><span class="s3">\&quot;</span><span class="s1">Link</span><span class="s3">\&quot; </span><span class="s1">|| tree.name == </span><span class="s3">\&quot;</span><span class="s1">Image</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">tree = tree.parent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">from: pos - m[0].length, to: pos,</span><span class="s3">\n        </span><span class="s1">options: htmlTagCompletions(),</span><span class="s3">\n        </span><span class="s1">validFor: /^&lt;[:</span><span class="s3">\\</span><span class="s1">-</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">u00b7-</span><span class="s3">\\</span><span class="s1">uffff]*$/</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">let _tagCompletions = null;</span><span class="s3">\n</span><span class="s1">function htmlTagCompletions() {</span><span class="s3">\n    </span><span class="s1">if (_tagCompletions)</span><span class="s3">\n        </span><span class="s1">return _tagCompletions;</span><span class="s3">\n    </span><span class="s1">let result = htmlCompletionSource(new CompletionContext(EditorState.create({ extensions: htmlNoMatch }), 0, true));</span><span class="s3">\n    </span><span class="s1">return _tagCompletions = result ? result.options : [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { commonmarkLanguage, deleteMarkupBackward, insertNewlineContinueMarkup, markdown, markdownKeymap, markdownLanguage };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>